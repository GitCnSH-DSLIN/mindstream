unit uL3ParserVsNewParser;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit 
  being tested.

}

interface

uses
  TestFramework, System.SysUtils, Vcl.Graphics, Winapi.Windows, System.Variants,
  Vcl.Dialogs, Vcl.Controls, Vcl.Forms, Winapi.Messages, System.Classes, uMain,
  l3Parser;

type
 TTokenRec = record
  rToken : string;
  rTokenType : Tl3TokenType;
 constructor Create(const aToken : string; const aTokenType : Tl3TokenType);
 class operator Equal(const Left, Right : TTokenRec) : Boolean;
 class operator NotEqual(const Left, Right : TTokenRec) : Boolean;
 end;

type
 TokenArray = array of TTokenRec;

type
 TL3ParserVsTNewParser = class(TTestCase)
  private
   function FileName: string;
   function IsArraysEqual(const aArrayLeft, aArrayRight : TokenArray) : Boolean;
  published
   procedure First;
   procedure CheckTokenEquals;
   procedure CheckTokenNotEquals;
   procedure CheckArraysIsEqual;
   procedure CheckArraysIsNotEqual;
   procedure CheckArraysLengthIsNotEqual;
   procedure CheckL3Parser;
 end;

implementation

uses
 l3Filer
 , l3Types
 ;
{ TL3ParserVsTNewParser }

const
 cParseOptions = [l3_poCheckKeyWords,
                  l3_poCheckInt,
                  //l3_poCheckFloat,
                  //l3_poCheckHex,
                  //l3_poCheckComment,
                  //l3_poCheckStringBracket,
                  l3_poAddDigits2WordChars,
                  l3_poNullAsEOF];

procedure TL3ParserVsTNewParser.First;
begin
 Check(True);
end;

function TL3ParserVsTNewParser.IsArraysEqual(const aArrayLeft : TokenArray;
  const aArrayRight: TokenArray): Boolean;
var
 l_i : integer;
begin
 Result := False;
 if Length(aArrayLeft) <> Length(aArrayRight) then
  Exit;

 for l_i := Low(aArrayLeft) to High(aArrayRight) do
  if (aArrayLeft[l_i] <> aArrayRight[l_i]) then
   Exit;

 Result := True;
end;

procedure TL3ParserVsTNewParser.CheckArraysIsEqual;
var
 l_l3ParserTokens, l_NewParserTokens : TokenArray;
begin
 SetLength(l_l3ParserTokens, Length(l_l3ParserTokens) + 1);
 SetLength(l_NewParserTokens, Length(l_NewParserTokens) + 1);

 l_l3ParserTokens[0].Create('qwe', l3_ttSymbol);
 l_NewParserTokens[0].Create('qwe', l3_ttSymbol);

 SetLength(l_l3ParserTokens, Length(l_l3ParserTokens) + 1);
 SetLength(l_NewParserTokens, Length(l_NewParserTokens) + 1);

 l_l3ParserTokens[1].Create('asd', l3_ttSymbol);
 l_NewParserTokens[1].Create('asd', l3_ttSymbol);

 Check(IsArraysEqual(l_l3ParserTokens, l_NewParserTokens));
end;

procedure TL3ParserVsTNewParser.CheckArraysIsNotEqual;
var
 l_l3ParserTokens, l_NewParserTokens : TokenArray;
begin
 SetLength(l_l3ParserTokens, Length(l_l3ParserTokens) + 1);
 SetLength(l_NewParserTokens, Length(l_NewParserTokens) + 1);

 l_l3ParserTokens[0].Create('qwe', l3_ttSymbol);
 l_NewParserTokens[0].Create('asd', l3_ttSymbol);

 SetLength(l_l3ParserTokens, Length(l_l3ParserTokens) + 1);
 SetLength(l_NewParserTokens, Length(l_NewParserTokens) + 1);

 l_l3ParserTokens[1].Create('qwe', l3_ttSymbol);
 l_NewParserTokens[1].Create('asd', l3_ttSymbol);

 Check(not IsArraysEqual(l_l3ParserTokens, l_NewParserTokens));
end;

procedure TL3ParserVsTNewParser.CheckArraysLengthIsNotEqual;
var
 l_l3ParserTokens, l_NewParserTokens : TokenArray;
begin
 SetLength(l_l3ParserTokens, Length(l_l3ParserTokens) + 1);
 SetLength(l_NewParserTokens, Length(l_NewParserTokens) + 2);

 Check(not IsArraysEqual(l_l3ParserTokens, l_NewParserTokens));
end;

procedure TL3ParserVsTNewParser.CheckL3Parser;
var
 l_Parser : Tl3CustomParser;
 l_Filer : Tl3DosFiler;
 l_TokenType : Tl3TokenType;
 l_Tokens : string;
 l_SR: TSearchRec;
 l_Path : string;

 l_l3ParserTokens, l_NewParserTokens : TokenArray;

 procedure DoSome(aName: string);
 begin
  l_Filer := Tl3DosFiler.Make(aName);
  l_Parser := Tl3CustomParser.Create;
  l_Filer.Open;
  l_Parser.Filer := l_Filer;
  l_Tokens := ' ';
  l_TokenType := l3_ttBOF;
  try
   while not (l_TokenType = l3_ttEOF) do
   begin
    l_TokenType := l_Parser.NextToken;
    l_Tokens := l_Tokens + '; ' + l_Parser.TokenString;
   end;
  finally
   FreeAndNil(l_Filer);
   FreeAndNil(l_Parser);
  end;
 end;
begin
 l_Tokens := '';
 l_Path :=  '*.txt';
{ if FindFirst(l_Path, faAnyFile, l_SR) = 0 then
 begin
   repeat
     if (l_SR.Attr <> faDirectory) then
     begin
      DoSome(l_SR.Name);
     end;
   until FindNext(l_SR) <> 0;
   FindClose(l_SR.FindHandle);
 end;       }

 DoSome('Test_4_1.txt');
 ShowMessage(l_Tokens);
end;

procedure TL3ParserVsTNewParser.CheckTokenEquals;
var
 l_Token1, l_Token2 : TTokenRec;
begin
 l_Token1 := TTokenRec.Create('qwe', l3_ttSymbol);
 l_Token2 := TTokenRec.Create('qwe', l3_ttSymbol);

 Check(l_Token1 = l_Token2);
end;

procedure TL3ParserVsTNewParser.CheckTokenNotEquals;
var
 l_Token1, l_Token2 : TTokenRec;
begin
 l_Token1 := TTokenRec.Create('qwe', l3_ttSymbol);
 l_Token2 := TTokenRec.Create('asd', l3_ttSymbol);

 Check(l_Token1 <> l_Token2);
end;

function TL3ParserVsTNewParser.FileName: string;
begin
 Result := 'test';
end;

{ TTokenRec }

constructor TTokenRec.Create(const aToken: string;
  const aTokenType: Tl3TokenType);
begin
 Self.rToken := aToken;
 Self.rTokenType := aTokenType;
end;

class operator TTokenRec.Equal(const Left, Right: TTokenRec): Boolean;
begin
 Result := False;
 if (Left.rToken = Right.rToken) and (Left.rTokenType = Right.rTokenType) then
  Result := True;
end;

class operator TTokenRec.NotEqual(const Left, Right: TTokenRec): Boolean;
begin
 Result := False;
 if (Left.rToken <> Right.rToken) or (Left.rTokenType <> Right.rTokenType) then
  Result := True;
end;

initialization
  // Register any test cases with the test runner
 RegisterTest(TL3ParserVsTNewParser.Suite);
end.

