PROGRAM CacheFunction.ms.script

USES
 axiom_push.ms.dict
;

USES
 WordsRTTI.ms.dict
;

USES
 Testing.ms.dict
;

Test&Dump CacheFunction.ms.script.test

 : Cache.do
   TtfwWord IN aCacheWhere
    %REMARK 'Где кешировать результат'
   TtfwWord IN aCacheWhat
    %REMARK 'Что кешировать'
   ^ IN aLambda
    %REMARK 'Лямбда, которая вычисляет результат'

  STRING VAR l_CacheWhat
  [ 'cached' 
     aCacheWhat .Parent.Words 
      .filter> ( class::TkwCompiledMain SWAP pop:Object:Inherits ! ) 
      .filter> ( pop:Word:Parent class::TkwCompiledMain SWAP pop:Object:Inherits ! )
       .for> pop:Word:Name 
     aCacheWhat pop:Word:Name 
  ] ':' strings:CatSep >>> l_CacheWhat

  VAR l_FieldVar
  aCacheWhere %% l_CacheWhat >>> l_FieldVar

  if ( l_FieldVar NotValid ) then
  begin
   VAR l_NewVar
   l_CacheWhat false aCacheWhere pop:NewWordDefinitor:CheckVar >>> l_NewVar
   @SELF l_NewVar pop:Word:SetProducer
   aLambda DO 
   l_NewVar pop:Word:SetValue
   l_NewVar DO
  end // l_FieldVar NotValid
  else
  begin
   l_FieldVar DO
  end

 ; // Cache.do

 MACRO Cache
  axiom:PushSymbol @SELF
  axiom:PushSymbol Cache.do
 ; // Cache

 : A

  STRING FUNCTION X
   'A.X' >>> Result
  ; // X

  // ERROR 'fake A'
 ; // A
 
 : B

  STRING FUNCTION X
   'B.X' >>> Result
  ; // X

  // ERROR 'fake B'
 ; // B
 
 STRING FUNCTION X
   STRING IN aPrefix
   TtfwWord IN aWord
  aPrefix aWord Cache ( aWord %% 'X' DO ) Cat >>> Result
 ; // X

 STRING FUNCTION Y
   TtfwWord IN aWord
  aWord Cache ( aWord %% 'X' DO ) >>> Result
 ; // Y

 '1' @ A X .
 '2' @ B X .

 @ A DumpElement
 @ B DumpElement

 '3' @ A X .
 '4' @ B X .

 @ A Y .
 @ B Y .

 @ A DumpElement
 @ B DumpElement

 @ A Y .
 @ B Y .

; // CacheFunction.ms.script.test

CacheFunction.ms.script.test
