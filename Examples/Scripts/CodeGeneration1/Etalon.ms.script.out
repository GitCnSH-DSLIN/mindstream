VOID TestWithDump Etalon.ms.script.test
 STRING CONST cCompareUtilCmd
  'q:\afc.cmd'
 VOID PROCEDURE Etalon
  ^ IN aLambda
  VOID PROCEDURE EtalonPrim
   aLambda
   Etalon.do
   INC
   l_EtalonCount
   l_Level
   g_EtalonPath
   l_EtalonCount
   Array:Item
   pop:Word:SetValuePrim
  ; // VOID PROCEDURE EtalonPrim
  
  INTEGER VAR l_EtalonCount
  ARRAY VAR l_EtalonPathCopy
  INTEGER VAR l_EtalonPathCount
  INTEGER VAR l_Level
  ARRAY [
   g_EtalonPath
   NOP
   SWAP
   Array:Iterate
  ]
  l_EtalonPathCopy
  pop:Word:SetValue
  l_EtalonPathCopy
  Array:Count
  l_EtalonPathCount
  pop:Word:SetValue
  g_EtalonLevel
  >=
  0
  ?ASSURE
  ARRAY [
   'g_EtalonLevel is bad: '
   g_EtalonLevel
   IntToStr
  ]
  SaveVarAndDo
  g_EtalonLevel
  (
   INTEGER VAR l_Index
   INTEGER VAR l_Value
   INC
   g_EtalonLevel
   if
    (
     g_EtalonLevel
     >
     l_EtalonPathCount
    )
   then
    BEGIN
     0
     >>>[]
     g_EtalonPath
    END
   aLambda
   Etalon.do
   l_EtalonPathCount
   Print
   g_EtalonPath
   Array:Count
   l_Index
   pop:Word:SetValue
   DEC
   l_Index
   l_Index
   >=
   0
   ?ASSURE
   'Индекс не может быть отрицательным'
   l_Index
   g_EtalonPath
   Array:Item
   l_Value
   pop:Word:SetValue
   l_Value
   >=
   0
   ?ASSURE
   'Значение не может быть отрицательным'
   INC
   l_Value
   l_Index
   g_EtalonPath
   l_Value
   Array:Item
   pop:Word:SetValuePrim
  )
  EXIT
  SaveVarAndDo
  g_EtalonLevel
  (
   BOOLEAN VAR l_SameLevel
   INC
   g_EtalonLevel
   g_EtalonPath
   Array:Count
   l_Level
   pop:Word:SetValue
   l_Level
   g_EtalonLevel
   ==
   l_SameLevel
   pop:Word:SetValue
   if
    l_SameLevel
   then
    BEGIN
     SaveVarAndDo
     g_EtalonPath
     (
      l_EtalonPathCopy
      g_EtalonPath
      pop:Word:SetValue
      DEC
      l_Level
      l_Level
      g_EtalonPath
      Array:Item
      l_EtalonCount
      pop:Word:SetValue
      EtalonPrim
     )
    END
   else
    BEGIN
     SaveVarAndDo
     g_EtalonPath
     (
      l_EtalonPathCopy
      g_EtalonPath
      pop:Word:SetValue
      0
      l_EtalonCount
      pop:Word:SetValue
      l_EtalonCount
      >>>[]
      g_EtalonPath
      EtalonPrim
     )
    END
  )
 ; // VOID PROCEDURE Etalon
 
 VOID PROCEDURE Etalon.do
  IN aLambda
  STRING CONST cPathSep
   '\'
  STRING CONST cPrnExt
   '.prn'
  VOID PROCEDURE DeleteEmptyFile
   STRING IN aFileName
   aFileName
   FileIsEmpty
   ?
   (
    aFileName
    sysutils:FileExists
    ?
    (
     aFileName
     DeleteFile
     DROP
    )
   )
  ; // VOID PROCEDURE DeleteEmptyFile
  
  BOOLEAN FUNCTION FileIsEmpty
   STRING IN aFileName
   aFileName
   FileSize
   0
   ==
   Result
   pop:Word:SetValue
  ; // BOOLEAN FUNCTION FileIsEmpty
  
  STRING VAR l_CurrentDir
  STRING VAR l_EtalonFileName
  STRING VAR l_OutDir
  STRING VAR l_OutFileName
  script:FileName
  sysutils:ExtractFilePath
  l_CurrentDir
  pop:Word:SetValue
  script:FileName
  sysutils:ExtractFileName
  l_EtalonFileName
  pop:Word:SetValue
  if
   (
    l_CurrentDir
    IsNil
   )
  then
   BEGIN
    sysutils:GetCurrentDir
    l_CurrentDir
    pop:Word:SetValue
   END
  ARRAY [
   l_EtalonFileName
   ARRAY [
    g_EtalonPath
    IntToStr
    SWAP
    Array:Map
    (
     '.'
     SWAP
     Cat
    )
    SWAP
    Array:Iterate
   ]
   strings:Cat
  ]
  strings:Cat
  l_EtalonFileName
  pop:Word:SetValue
  l_EtalonFileName
  l_OutFileName
  pop:Word:SetValue
  l_OutFileName
  cPrnExt
  Cat
  l_OutFileName
  pop:Word:SetValue
  ARRAY [
   l_CurrentDir
   'Etalons'
   ARRAY [
    l_EtalonFileName
    cPrnExt
    '.etalon'
   ]
   strings:Cat
  ]
  cPathSep
  strings:CatSep
  l_EtalonFileName
  pop:Word:SetValue
  ARRAY [
   l_CurrentDir
   'Out'
  ]
  cPathSep
  strings:CatSep
  l_OutDir
  pop:Word:SetValue
  l_OutDir
  sysutils:ForceDirectories
  ?ASSURE
  ARRAY [
   'Не удалось создать директорию '
   l_OutDir
  ]
  ARRAY [
   l_OutDir
   l_OutFileName
  ]
  cPathSep
  strings:CatSep
  l_OutFileName
  pop:Word:SetValue
  SaveVarAndDo
  g_OutFile
  (
   l_OutFileName
   File:OpenWrite
   g_OutFile
   pop:Word:SetValue
   DumpStackTo
   ARRAY (
    g_EtalonPath
   )
   Out
   DumpStackTo
   (
    aLambda
    DO
   )
   Out
   nil
   g_OutFile
   pop:Word:SetValue
  )
  EXIT
  if
   (
    l_EtalonFileName
    sysutils:FileExists
   )
  then
   BEGIN
    ''
    l_EtalonFileName
    l_OutFileName
    CompareFiles
    !
    ?
    (
    )
   END
  else
   BEGIN
    32
    l_EtalonFileName
    l_OutFileName
    CopyFile
   END
  l_EtalonFileName
  DeleteEmptyFile
  l_OutFileName
  DeleteEmptyFile
 ; // VOID PROCEDURE Etalon.do
 
 INTEGER VAR g_EtalonLevel
 ARRAY VAR g_EtalonPath
 FILE VAR g_OutFile
 VOID PROCEDURE Out
  IN aValue
  g_OutFile
  IsNil
  ?FAIL
  'Файл для вывода не открыт'
  aValue
  ToPrintable
  g_OutFile
  File:WriteLn
 ; // VOID PROCEDURE Out
 
 Etalon.ms.script.test
 DumpElement
 (
  nil
  g_OutFile
  pop:Word:SetValue
 )
 (
  0
  g_EtalonLevel
  pop:Word:SetValue
 )
 (
  ARRAY [
   0
  ]
  g_EtalonPath
  pop:Word:SetValue
 )
 Etalon
 (
  script:FileName
  sysutils:ExtractFileName
 )
 Etalon
 (
  (
   1
   2
   +
  )
  Etalon
  'Inner1'
  Etalon
  'Inner2'
  'Outer1'
 )
 Etalon
 'Outer2'
 EXIT
 Etalon
 'Hello world'
 Etalon
 NOP
 Etalon
 ARRAY [
 ]
 Etalon
 1
 Etalon
 'Another string'
 Etalon
 ''
 Etalon
 (
  'Root'
  Etalon
  'Nested1'
  Etalon
  (
   'Nested2'
   Etalon
   'Nested2.1'
   Etalon
   'Nested2.2'
   Etalon
   'Nested2.3'
  )
  Etalon
  'Nested3'
  Etalon
  'Nested4'
 )
; // VOID TestWithDump Etalon.ms.script.test

1
1
2
1
2
