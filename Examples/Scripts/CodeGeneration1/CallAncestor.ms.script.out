VOID TestWithDump CallAncestorTest
 IMMEDIATE VOID MACRO .call.ancestor
  STRING VAR l_WordName
  Ctx:KeyWordDefiningNow
  pop:KeyWord:Name
  l_WordName
  pop:Word:SetValue
  l_WordName
  IsNil
  !
  ?ASSURE
  ARRAY [
   'No name for word calling '
   .call.ancestor
   pop:Word:Name
  ]
  l_WordName
  Ctx:WordDefiningNow
  .call.ancestor.do
 ; // IMMEDIATE VOID MACRO .call.ancestor
 
 VOID PROCEDURE .call.ancestor.do
  TtfwWord IN aWord
  STRING IN aWordName
  TtfwWord VAR l_FoundWord
  TtfwWord VAR l_WordParent
  aWord
  pop:Word:Parent
  l_WordParent
  pop:Word:SetValue
  l_WordParent
  IsNil
  !
  ?ASSURE
  ARRAY [
   'No parent for '
   aWordName
  ]
  nil
  l_FoundWord
  pop:Word:SetValue
  l_WordParent
  .Inherited.Words
  (
   TtfwWord IN l_Ancestor
   TtfwWord VAR l_AncestorMember
   l_Ancestor
   %%
   aWordName
   l_AncestorMember
   pop:Word:SetValue
   if
    (
     l_AncestorMember
     IsNil
     !
    )
   then
    BEGIN
     l_FoundWord
     IsNil
     ?ASSURE
     ARRAY [
      'Method '
      aWordName
      ' was already found in '
      l_FoundWord
      pop:Word:Parent
      pop:Word:Name
     ]
     l_AncestorMember
     l_FoundWord
     pop:Word:SetValue
    END
  )
  SWAP
  Array:Iterate
  l_FoundWord
  IsNil
  !
  ?ASSURE
  ARRAY [
   'Method '
   aWordName
   ' not found in '
   l_WordParent
   pop:Word:Name
  ]
  l_FoundWord
  CompileValue
 ; // VOID PROCEDURE .call.ancestor.do
 
 TtfwWord FUNCTION .find.ancestor.method
  STRING IN aWordName
  nil
  Result
  pop:Word:SetValue
 ; // TtfwWord FUNCTION .find.ancestor.method
 
 : A
  : X
   INTEGER IN aValue
   aValue
   3
   +
  ; // : X
  
 ; // : A
 
 : B
  Inherits %G
   A
  ; // Inherits %G
  
  : X
   INTEGER IN aValue
   aValue
   2
   +
   X
  ; // : X
  
 ; // : B
 
 : C
  Inherits %G
   B
  ; // Inherits %G
  
  : X
   INTEGER IN aValue
   aValue
   2
   +
   X
  ; // : X
  
 ; // : C
 
 CallAncestorTest
 DumpElement
 1
 A ::
 'X'
 .
 2
 B ::
 'X'
 .
 2
 C ::
 'X'
 .
; // VOID TestWithDump CallAncestorTest

4
7
9
