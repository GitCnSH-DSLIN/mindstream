UNIT Object.ms.dict

USES
 Bind.ms.dict
;

EXPORTS
 Bind.ms.dict

USES
 core.ms.dict
 macro.ms.dict
 NoCapsLock.ms.dict
 implementation.ms.dict
 params.ms.dict
 axiom_push.ms.dict
 Documentation.ms.dict
 WordsRTTI.ms.dict
 arrays.ms.dict
 io.ms.dict
 Debug.ms.dict
 CompileTimeVar.ms.dict
;

EXPORTS
 CompileTimeVar.ms.dict

EXPORTS
 implementation.ms.dict

USES
 InheritsAndImplementsNew.ms.dict
;

EXPORTS
 InheritsAndImplementsNew.ms.dict

// Понятное дело, что всю обвязку потом упрячем в отдельный словарь object.ms.dict

NamedWordProducer %FIELDS %Flds
NamedWordProducer %PROPERTIES %Props
NamedWordProducer %METHODS %Methods
NamedWordProducer %CONSTRUCTORS %Constructors

OBJECT FUNCTION DoMember 
 OBJECT IN aMember
 aMember DO >>> Result
; // DoMember

BOOLEAN FUNCTION FilterMember 
 OBJECT IN aMember
 Result := ( aMember NotValid ! )
; // FilterMember
 
WordAlias %R .Implemented.Words
WordAlias %G .Inherited.Words

ARRAY FUNCTION %ClassRTTIList
 IN %S
 Literal IN aName
 VAR l_List
 %S %% ( aName |N ) >>> l_List
 if ( l_List NotValid ) then
  ( Result := [ ] )
 else 
  ( Result := ( l_List CodeIterator ) )
; // %ClassRTTIList

ARRAY FUNCTION %Flds
 IN %S
 %SUMMARY 'Возвращает итератор полей класса' ;
 %S %ClassRTTIList %Flds >>> Result
; // %Flds

ARRAY FUNCTION %Props 
 IN %S
 %SUMMARY 'Возвращает итератор свойств класса' ;
 %S %ClassRTTIList %Props >>> Result
; // %Props

ARRAY FUNCTION %Methods 
 IN %S
 %SUMMARY 'Возвращает итератор методов класса' ;
 %S %ClassRTTIList %Methods >>> Result
; // %Methods

ARRAY FUNCTION %Constructors 
 IN %S
 %SUMMARY 'Возвращает итератор конструкторов класса' ;
 %S %ClassRTTIList %Constructors >>> Result
; // %Constructors

MACRO class_impl
  Literal IN aName
 %SUMMARY 'Реализация класса.
 Тут мы будем хранить всю информацию о классе - предки, поля, методы'
 ;

 @SELF Ctx:SetWordProducerForCompiledClass
 axiom:PushSymbol : 
 aName |N Ctx:Parser:PushSymbol
// // axiom:PushSymbol ;
; // class_impl

STRING CompileTime-VAR g_CurrentClass ''
STRING CompileTime-VAR g_CurrentClassImpl ''

CONST cFieldPrefix 'c:'

PRIVATE STRING operator MakeFieldOffsetName
 STRING IN aName
 [ cFieldPrefix g_CurrentClass ':Offset:' aName ] strings:Cat >>> Result
; // MakeFieldOffsetName

INTEGER type FieldOffset
// - смещение поля

VOID operator define_member
 STRING IN aName
 FieldOffset IN aOffset
 axiom:PushSymbol private
 axiom:PushSymbol Const
 aName MakeFieldOffsetName Ctx:Parser:PushSymbol
 aOffset Ctx:Parser:PushInt

 axiom:PushSymbol implementation
 g_CurrentClassImpl Ctx:Parser:PushSymbol
 axiom:PushSymbol Const
 aName MakeFieldOffsetName Ctx:Parser:PushSymbol
 aOffset Ctx:Parser:PushInt
 axiom:PushSymbol end.

; // define_member

FieldOffset CompileTime-VAR g_ClassFieldOffset 0

ARRAY CompileTime-VAR g_CurrentClassMembers [ ]

ARRAY CompileTime-VAR g_CurrentClassProperties [ ]

ARRAY CompileTime-VAR g_CurrentClassMethods [ ]

ARRAY CompileTime-VAR g_CurrentClassConstructors [ ]

MACRO member
 Literal IN aName
 STRING VAR l_Name
 aName |N >>> l_Name
 Ctx:ClearTypeInfo
 l_Name g_ClassFieldOffset define_member
 Inc g_ClassFieldOffset
 l_Name array:AddTo g_CurrentClassMembers
; // member

PRIVATE STRING operator MakeMethodSignaturePrim
 STRING IN aClass
 STRING IN aName
 [ aClass ':' aName ] strings:Cat >>> Result
; // MakeMethodSignaturePrim

CONST cClassImplPrefix '_:'

STRING FUNCTION ClassImplName
  STRING IN aName
 [ cClassImplPrefix aName ] strings:Cat >>> Result
; // ClassImplName

TtfwWord type ObjectClass

Const ClassRefSuffix 'Class'

STRING FUNCTION ClassRefName
  STRING IN aName
 [ aName ClassRefSuffix ] strings:Cat >>> Result
; // ClassRefName

CONST cSelf 'Self'

MACRO class-method
  Literal IN aName

 %SUMMARY 'Метод класса' ;

 STRING VAR l_Name
 aName |N >>> l_Name

 l_Name bindAndRestoreContext

 //l_Name @SELF bindInPlace
 
 @SELF Ctx:SetWordProducerForCompiledClass

 axiom:PushSymbol :

 STRING VAR l_ClassName

 g_CurrentClass >>> l_ClassName
 
 if ( l_ClassName IsNil ) then
 begin
  NameOf ObjectClass >>> l_ClassName
 end
 else
 begin
  l_ClassName ClassRefName >>> l_ClassName
 end
 
 l_ClassName l_Name MakeMethodSignaturePrim >>> l_Name
 l_Name Ctx:Parser:PushSymbol

 l_ClassName Ctx:Parser:PushSymbol
 axiom:PushSymbol in
 cSelf Ctx:Parser:PushSymbol

 //l_Name array:AddTo g_CurrentClassMethods
; // class-method

CONST cObjectName 'Object'

CONST cInstanceSizeName 'Instance:Size'

STRING FUNCTION InstanceSizeName
 [ cFieldPrefix cInstanceSizeName ] strings:Cat >>> Result
; // InstanceSizeName

//FORWARD classExpander
// - так почему-то не работает, хотя должно бы

MACRO class
 Literal IN aName
 ( g_CurrentClass = '' ) ?ASSURE 'Вложенные классы пока не поддерживаются'
 g_CurrentClassMembers := [ ]
 g_CurrentClassProperties := [ ]
 g_CurrentClassMethods := [ ]
 g_CurrentClassConstructors := [ ]
 g_ClassFieldOffset := 0
 aName |N >>> g_CurrentClass
 g_CurrentClass ClassImplName >>> g_CurrentClassImpl

 if ( g_CurrentClass !== cObjectName ) then
 begin
  axiom:PushSymbol TtfwWord 
  axiom:PushSymbol type
  g_CurrentClass ClassRefName Ctx:Parser:PushSymbol
 end // g_CurrentClass !== cObjectName

 axiom:PushSymbol class_impl
 [
  g_CurrentClassImpl

  'FieldOffset'
  'CompileTime-VAR'
  InstanceSizeName
 ] Ctx:Parser:PushArray

  0 Ctx:Parser:PushInt

 [
   if ( g_CurrentClass !== cObjectName ) then
   begin
    '%INHERITS'
    '@' 
    cObjectName ClassImplName
    ';'
   end
  ';'
 ] Ctx:Parser:PushArray

 [
  'array' 
  'type' 
  g_CurrentClass
 ] Ctx:Parser:PushArray

 if ( g_CurrentClass !== cObjectName ) then
 begin
  'classExpander' Ctx:Parser:PushSymbol
  g_CurrentClassImpl Ctx:Parser:PushSymbol
 end

; // class

class Object

STRING class-method Name
 Self |N ':' string:Split >>> Result DROP
; // ObjectClass:Name

MACRO classExpander
  ^ IN anImpl

 %SUMMARY 'Тут можно копировать поля и методы' ;
 anImpl |@ %G .for> ( 
  ObjectClass IN anItem 

  anItem MembersIterator .filter> ( pop:Word:Producer pop:Word:Name NameOf CONST == ) .for> ( 
   TtfwWord IN aMember
   //aMember pop:Word:Producer pop:Word:Name Msg
   //aMember pop:Word:Name Msg
  )

  anItem %Flds .for> ( 
   IN aField 
   axiom:PushSymbol member
   aField |N Ctx:Parser:PushSymbol
  ) // anItem %Flds .for>

  anItem %Props .for> ( 
   IN aProp
   axiom:PushSymbol WordAlias
   g_CurrentClass aProp |N MakeMethodSignaturePrim Ctx:Parser:PushSymbol
   anItem .Name aProp |N MakeMethodSignaturePrim Ctx:Parser:PushSymbol
  ) // anItem %Props .for>

  anItem %Methods .for> ( 
   IN aProp
   axiom:PushSymbol WordAlias
   g_CurrentClass aProp |N MakeMethodSignaturePrim Ctx:Parser:PushSymbol
   anItem .Name aProp |N MakeMethodSignaturePrim Ctx:Parser:PushSymbol
  ) // anItem %Methods .for>

  anItem %Constructors .for> ( 
   IN aProp
   axiom:PushSymbol WordAlias
   g_CurrentClass aProp |N MakeMethodSignaturePrim Ctx:Parser:PushSymbol
   anItem .Name aProp |N MakeMethodSignaturePrim Ctx:Parser:PushSymbol
  ) // anItem %Constructors .for>

 )
; // classExpander

INTEGER class-method InstanceSize
 Self %% InstanceSizeName DO >>> Result
; // InstanceSize

: ListToNameAsString
 STRING IN aName
 ARRAY IN aList
 aName
  aList .for> NameAsString
 ';'
; // ListToNameAsString

MACRO RunCompileProps&Methods
 [
  'implementation'
  g_CurrentClassImpl
   '%FIELDS' g_CurrentClassMembers ListToNameAsString

   '%PROPERTIES' g_CurrentClassProperties ListToNameAsString

   '%METHODS' g_CurrentClassMethods ListToNameAsString

   '%CONSTRUCTORS' g_CurrentClassConstructors ListToNameAsString

  'end.'
 ] Ctx:Parser:PushArray
; // RunCompileProps&Methods

MACRO class-end
 axiom:PushSymbol RunCompileProps&Methods

 axiom:PushSymbol [EXECUTE]
 axiom:PushSymbol (
 g_CurrentClass ClassImplName Ctx:Parser:PushSymbol
 axiom:PushSymbol ::
 InstanceSizeName Ctx:Parser:PushSymbol
 axiom:PushSymbol :=
 g_ClassFieldOffset Ctx:Parser:PushInt
 axiom:PushSymbol )

 g_CurrentClass := ''
; // class-end

PRIVATE VOID operator MakeMethodSignature
 STRING IN aName
 STRING VAR l_Signature
 g_CurrentClass aName MakeMethodSignaturePrim >>> l_Signature
 if ( l_Signature IsWordDeclared ) then
 begin
  axiom:PushSymbol REDEFINITION
 end
 axiom:PushSymbol :
 l_Signature Ctx:Parser:PushSymbol
; // MakeMethodSignature

CONST cResult 'Result'

MACRO constructor
  Literal IN aName
  ^ IN aParams

 %SUMMARY 'Конструктор объектов';

 STRING VAR l_Name
 aName |N >>> l_Name
 @SELF Ctx:SetWordProducerForCompiledClass
 g_CurrentClass Ctx:Parser:PushSymbol
 l_Name MakeMethodSignature
 @SELF NameOf right aParams axiom:Params:PushWithOtherStereo

 axiom:PushSymbol WordAlias
 cSelf Ctx:Parser:PushSymbol
 cResult Ctx:Parser:PushSymbol

 l_Name array:AddTo g_CurrentClassConstructors
; // constructor

PRIVATE VOID operator MakeSelfParam
 g_CurrentClass Ctx:Parser:PushSymbol
 axiom:PushSymbol in
 cSelf Ctx:Parser:PushSymbol
; // MakeSelfParam

MACRO method
  Literal IN aName

 %SUMMARY 'Метод объекта' ;

 STRING VAR l_Name
 aName |N >>> l_Name

 l_Name @SELF bindInPlace
 
 //@SELF Ctx:SetWordProducerForCompiledClass

 l_Name MakeMethodSignature
 MakeSelfParam
 l_Name array:AddTo g_CurrentClassMethods
; // method

MACRO readonly
  Literal IN aName

 %SUMMARY 'read-only свойство объекта' ;

 STRING VAR l_Name
 aName |N >>> l_Name

 l_Name @SELF bindInPlace

 //@SELF Ctx:SetWordProducerForCompiledClass

 l_Name MakeMethodSignature
 MakeSelfParam
 l_Name array:AddTo g_CurrentClassProperties
; // readonly

MACRO new[
 axiom:PushSymbol [
 axiom:PushSymbol @
 g_CurrentClassImpl Ctx:Parser:PushSymbol
; // new[

: FieldByOffset
 Object in Self
 FieldOffset right anOffset
 anOffset Self [i]
; // FieldByOffset

PRIVATE operator do-get-member
  STRING IN aName
 
 %SUMMARY 'Определяет способ доступа к члену класса' ;
 axiom:PushSymbol FieldByOffset
 axiom:PushSymbol (
 g_CurrentClass ClassImplName Ctx:Parser:PushSymbol
 axiom:PushSymbol ::
 aName MakeFieldOffsetName Ctx:Parser:PushSymbol 
 axiom:PushSymbol )
; // do-get-member

MACRO get-member
  Literal IN aName

 %SUMMARY 'Компилирует способ доступа к члену класса' ;
 aName |N do-get-member
; // get-member

MACRO read
 Literal IN aName
 cSelf Ctx:Parser:PushSymbol 
 aName |N do-get-member
 axiom:PushSymbol >>>
 cResult Ctx:Parser:PushSymbol
 axiom:PushSymbol ;
; // read

FieldOffset member VMT

ObjectClass readonly class read VMT

STRING readonly ClassName
 Self .class .Name >>> Result
; // ClassName

INTEGER readonly InstanceSize
 Self .class .InstanceSize >>> Result
; // InstanceSize

constructor new ( )
 new[ ] >>> Result
; // new

VIRTUAL STRING method ToPrintable
 //Self ToPrintable >>> Result
 Self .ClassName >>> Result
; // ToPrintable

VIRTUAL void method Print
 Self .ToPrintable Print
; // Print

class-end // Object
