PROGRAM CallInherited.ms.script

USES
 axiom_push.ms.dict
 WordsRTTI.ms.dict
 classRelations.ms.dict
 Testing.ms.dict
;

Test&Dump CallInheritedTest

 TtfwWord FUNCTION find.inherited
   TtfwWord IN Self
  nil >>> Result
  Self .Inherited.Words .for> (
   TtfwWord IN anAncestor
   Result IsNil ?ASSURE [ 'Множественное наследование не поддерживается для ' Self ToPrintable Self |N ' второй предок ' anAncestor |N ]
   anAncestor >>> Result
  )
  Result IsNil ! ?ASSURE [ 'Не найден предок для ' Self |N ]
 ; // find.inherited

 STACK_CHANGING_MACRO compile.inherited
   TtfwWord IN Self
  Self find.inherited CompileValue
 ; // compile.inherited

MACRO call.inherited
 // - понятно, что это надо делать через честную компиляцию ссылки на Inherited
                              
 'Self' Ctx:Parser:PushSymbol
 axiom:PushSymbol [EXECUTE]
 '@SELF' Ctx:Parser:PushSymbol
 axiom:PushSymbol compile.inherited
; // call.inherited

 : A
  INTEGER IN Self
  Self 1 +
 ; // A

 : B
  INTEGER IN Self

  Inherits A

  Self 2 +
  call.inherited +
 ; // B

 : C
  INTEGER IN Self

  Inherits B

  Self 3 +
  call.inherited +
 ; // C

 : D
  INTEGER IN Self

  Inherits C

  Self 4 +
  call.inherited +
 ; // D

 : E
  INTEGER IN Self

  Inherits ( C D )

  Self 5 +
  call.inherited +
 ; // E

 1 A .
 2 B .
 3 C .
 4 D .
 5 E .

; // CallInheritedTest

CallInheritedTest
