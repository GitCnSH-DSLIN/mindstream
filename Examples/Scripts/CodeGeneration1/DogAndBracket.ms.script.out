[ TkwInteger TkwInteger TkwInteger TkwInteger TkwInteger TkwInteger TkwInteger TkwInteger TkwAdd TkwString ]
123
+
2
1
6
5
4
3
2
1
VOID Test DogAndBracketTest
 IMMEDIATE VOID MACRO @(
  NameOf
  (
  NameOf
  )
  DogAndBracket
 ; // IMMEDIATE VOID MACRO @(
 
 IMMEDIATE VOID MACRO @[
  NameOf
  [
  NameOf
  ]
  DogAndBracket
 ; // IMMEDIATE VOID MACRO @[
 
 VOID PROCEDURE axiom:Push
  TOKEN IN aSymbol
  TOKEN_TYPE IN aTokenType
  aTokenType
  CASE
   Tl3TokenType::l3_ttSymbol
    (
     aSymbol
     Ctx:Parser:PushSymbol
    )
   Tl3TokenType::l3_ttString
    (
     aSymbol
     Ctx:Parser:PushString
    )
   Tl3TokenType::l3_ttInteger
    (
     aSymbol
     Ctx:Parser:PushInt
    )
   DEFAULT
    (
     ERROR
     [
      'Неожиданный тип токена: '
      aTokenType
      Tl3TokenType:ValueToName
     ]
    )
  END
 ; // VOID PROCEDURE axiom:Push
 
 VOID PROCEDURE DogAndBracket
  STRING IN aBracketClose
  STRING IN aBracketOpen
  ARRAY VAR l_A
  INTERFACE VAR l_Parser
  Ctx:Parser
  >>>
  l_Parser
  l_A :=
  [
  ]
  l_Parser
  pop:Parser:NextToken
  WHILE
  true
  BEGIN
   STRING VAR l_Token
   TOKEN_TYPE VAR l_TokenType
   l_Parser
   pop:Parser:TokenLongString
   >>>
   l_Token
   l_Parser
   pop:Parser:TokenType
   >>>
   l_TokenType
   if
    (
     l_TokenType
     =
     Tl3TokenType::l3_ttSymbol
    )
   then
    BEGIN
     (
      l_Token
      =
      NameOf
      (
     )
     ?FAIL
     'Вложенные скобки пока не поддерживаются'
     (
      l_Token
      =
      NameOf
      [
     )
     ?FAIL
     'Вложенные скобки пока не поддерживаются'
     if
      (
       l_Token
       =
       aBracketClose
      )
     then
      BEGIN
       aBracketOpen
       Ctx:Parser:PushSymbol
       l_A
       .slice>
       2
       IT
       BEGIN
        TOKEN IN aSymbol
        TOKEN_TYPE IN aTokenType
        axiom:PushSymbol
        @
        aSymbol
        aTokenType
        axiom:Push
       END
       l_Token
       Ctx:Parser:PushSymbol
       BREAK
      END
    END
   l_TokenType
   >>>[]
   l_A
   if
    (
     l_TokenType
     =
     Tl3TokenType::l3_ttInteger
    )
   then
    BEGIN
     l_Parser
     pop:Parser:TokenInt
     >>>[]
     l_A
    END
   else
    BEGIN
     l_Token
     >>>[]
     l_A
    END
   l_Parser
   pop:Parser:NextToken
  END
 ; // VOID PROCEDURE DogAndBracket
 
 IMMEDIATE VOID TYPE TOKEN
  TtfwValueTypes
  Ctx:IncludeValueTypes
 ; // IMMEDIATE VOID TYPE TOKEN
 
 IMMEDIATE VOID TYPE TOKEN_TYPE
  TtfwValueTypes
  Ctx:IncludeValueTypes
 ; // IMMEDIATE VOID TYPE TOKEN_TYPE
 
 (
  @
  1
  @
  2
  @
  3
  @
  4
  @
  5
  @
  6
  @
  1
  @
  2
  @
  +
  @
  '123'
 )
 [
  @
  1
  @
  2
  @
  3
  @
  4
  @
  5
  @
  6
  @
  1
  @
  2
  @
  +
  @
  '123'
 ]
 WHILE
 (
  StackLevel
  >
  0
 )
 Print
 DogAndBracketTest
 DumpElement
; // VOID Test DogAndBracketTest

