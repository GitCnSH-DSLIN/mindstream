PROGRAM CallAncestor.ms.script

USES
 classRelations.ms.dict
;

USES
 WordsRTTI.ms.dict
;

USES
 Testing.ms.dict
;

Test&Dump CallAncestorTest

 TtfwWord FUNCTION .find.ancestor.method
   STRING IN aWordName
  nil >>> Result
 ; // .find.ancestor.method

 PROCEDURE .call.ancestor.do
  STRING IN aWordName
  TtfwWord IN aWord

  TtfwWord VAR l_WordParent
  aWord pop:Word:Parent >>> l_WordParent
  l_WordParent IsNil ! ?ASSURE [ 'No parent for ' aWordName ]

  TtfwWord VAR l_FoundWord
  nil >>> l_FoundWord

  l_WordParent .Inherited.Words .for> ( 
   TtfwWord IN l_Ancestor

   TtfwWord VAR l_AncestorMember 
   l_Ancestor %% aWordName >>> l_AncestorMember
   if ( l_AncestorMember IsNil ! ) then
   begin
    l_FoundWord IsNil ?ASSURE [ 'Method ' aWordName ' was already found in ' l_FoundWord pop:Word:Parent pop:Word:Name ]
    l_AncestorMember >>> l_FoundWord
   end // l_AncestorMember IsNil !
  ) // l_WordParent .Inherited.Words .for>

  l_FoundWord IsNil ! ?ASSURE [ 'Method ' aWordName ' not found in ' l_WordParent pop:Word:Name ]
  l_FoundWord CompileValue
 ; // .call.ancestor.do

 MACRO .call.ancestor
  STRING VAR l_WordName
  Ctx:KeyWordDefiningNow pop:KeyWord:Name >>> l_WordName
  l_WordName IsNil ! ?ASSURE [ 'No name for word calling ' @SELF pop:Word:Name ]

  l_WordName Ctx:WordDefiningNow .call.ancestor.do
 ; // .call.ancestor

 : A
  : X
    INTEGER IN aValue
   aValue 3 +
  ; // X
 ; // A

 : B Inherits A
  : X
    INTEGER IN aValue
   aValue 2 + .call.ancestor
   // A :: X
  ; // X
 ; // B

/*{ : C // Inherits A
  : X
    INTEGER IN aValue
   aValue 2 + .call.ancestor A :: X
  ; // X
 ; // C}*/

 1 A :: X .
 2 B :: X .

; // CallAncestorTest

CallAncestorTest
