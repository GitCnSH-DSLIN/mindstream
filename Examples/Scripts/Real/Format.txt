-2. Пример парсера лежит тут - mindstream\Scripting\Script.Parser.pas. Его надо брать за основу.
-1. Реализованный парсер конечно же есть. И не один. Но мы будем писать НОВЫЙ.Тому есть много ВЕСКИХ причин.
0. Токен - базовый элемент грамматики языка.
1. Все "токены" разделяются пробелами или табуляциями. Или новой строкой (#13#10 или #10 или #13). Пример:
 1. A B C - три токена - A B C
 2. A B + - три токена - A B +
 3. A B+ - два токена - A B+
 4. A+ B - два токена - A+ B
 5. A+B - один токен - A+B
1a. Сначала парсер бъёт входной поток по пробелам или новым строкам, а потом только анализирует содержимое полученных токенов.
2. Токен // - определяет строковый комментарий. Парсер должен пропустить все символы от // до конца строки (#13#10 или #10 или #13).
3. Токен /* - определяет блочный комментарий. Парсер должен пропустить все символы от /* до */.
4. Токен false - представляет собой булевское значение false.
5. Токен true - представляет собой булевское значение true.
6. Конструкция вида [x] далее означает повторение значения x от 0 до N. Где x - может принимать ЛЮБОЕ значение. К токенам это не относится. Это скажем так - мета-язык для описания токенов.
6a. Также договоримся, что a - это символ, а N - цифра.
7. Токен вида '[a]' - представляет собою строку. a - может быть ЛЮБЫМ сиволом кроме ', включая #13 и 10. Пример:
 1. 'abc' - строка abc.
 2. 'abc d' - строка abc d.
 3. 'ab
 c' - строка abc#13#10c.
8. Поддчеркну! Строки бывают МНОГОСТРОЧНЫМИ. Как в примере 7.3.
9. Токен вида [[#[N]]['[a]'][#[N]]] - также даёт строку. Пример:
 1. #12#13#14 - даёт строку #12#13#14.
 2. #12#13#14'a' - даёт строку #12#13#14a.
 3. #12#13#14'ab' - даёт строку #12#13#14ab.
 3. #12#13#14'ab'#15 - даёт строку #12#13#14ab#15.
 4. #12#13#14'ab'#15'cd' - даёт строку #12#13#14ab#15cd.
10. Токен вида '[''][a]['']' - даёт строку с кавычками. Примеры:
 1. '''' - даёт строку '.
 2. '''''' - даёт строку ''.
 3. '''a''' - даёт строку 'a'.
 4. 'a''' - даёт строку a'.
 5. '''a' - даёт строку 'a.
11. Договоримся, что конструкция вида (x) - далее означает повторение значения x от 1 до N.
12. Токен вида (N) - даёт НЕОТРИЦАТЕЛЬНОЕ число. Пример:
 1. 1 - число 1.
 2. 2 - число 2.
 3. 0 - число 0.
 4. 20 - число 20.
 5. 200 - число 200.
13. Токен вида -(N) - даёт НЕПОЛОЖИТЕЛЬНОЕ число. 
    МИНУС от числа отрываться НЕ МОЖЕТ. -1 - валидное число, а - 1 - невалидное. Это ДВА токена - - и 1.
    Пример:
 1. -1 - число -1.
 2. -2 - число -2.
 3. -0 - число 0.
 4. -20 - число -20.
 5. -200 - число -200.
14. Токен вида $(H) (где H шестнадцатиричная цифра от 0 до F) - даёт НЕОТРИЦАТЕЛЬНОЕ шестнадцаттричное число. Пример:
 1. $0 - число 0.
 2. $1 - число 1.
 3. $2 - число 2.
 4. $A - число 10.
 5. $F - число 15.
 6. $10 - число 16.
 7. $FF - число 255.
14a. Отрицательных нестнадцатиричных чисел - НЕ БЫВАЕТ. -$(H) - НЕВАЛИДНЫЙ ТОКЕН.
15. Токен вида #$(H) - даёт символ в шестнадцатиричном представлении. Ну и далее по индукции со строками. Пример:
 1. #$0 - строка 0.
 2. #$A - строка #10.
 3. #$D - строка #13.
 4. #$D'a' - строка #13a.
 5. 'a'#$D - строка a#13.
 6. ''''#$D - строка '#13.
 7. #$D'''' - строка #13'.
16. Токен вида "[a]" - представляет собой ИДЕНТИФИКАТОР. 
    Идентификатор может включать в себя пробелы и #13 и #10.
    Идентификаторы - РЕГИСТРОЗАВИСИМЫЕ. 
    Кавычка " - ВКЛЮЧАЕТСЯ в имя идентификатора. Идентификатор означает САМ СЕБЯ. Пример:
 1. "" - идентификатор "".
 2. "a" - идентификатор "a".
 3. "ab" - идентификатор "ab".
 4. "a+b" - идентификатор "a+b".
 5. "a+A" - идентификатор "a+A".
 6. "a
 b" - идентификатор "a#13#10b".
 7. "a
 b
 c" - идентификатор "a#13#10b#13#10c".
17. Итак - ПОКА у нас есть строки, числа, булевские значения и идентификаторы.
18. Далее есть "специальные конструкции". Пока к делу не относящиеся.
19. Перечислим их.
20. Конструкция USES [Token] ; - означает использование словарЕЙ (от 0 до N). 
    Token - это ЛЮБОЙ валидный токен определённый выше КРОМЕ чисел и булевских значений. 
    Пока должна скиповаться. 
    Примеры:
 1. USES A ;
 2. USES A B ;
 3. USES A B 'C' ;
 4. USES A 
 B
 C ;
 5. USES A 
 B
 'C' ;
 6. USES A 
 B
 "C" ;
 7. USES ;
 8. USES 
 ;
21. Конструкция INCLUDE String - означает использования словарЯ.
    Ровно ОДНОГО.
    Пока должна скиповаться.
    Примеры:
 1. INCLUDE 'a'
 2. INCLUDE 'ab'
 3. INCLUDE 'a'#13#10
 4. INCLUDE 'a
 '
 5. INCLUDE $A
22. Конструкция CONST Identifier Value - означает определение константы.
    Identifier - валидный идентификатор вида [a] или "[a]".
    Value - значение константы. Строка, булевское true или false, число. Другая константа (определённая ранее).
    Примеры.
 1. CONST A 1 - константа с именем A и численным значением 1.
 2. CONST A 2 - константа с именем A и численным значением 2.
 3. CONST A 0 - константа с именем A и численным значением 0.
 4. CONST A -1 - константа с именем A и численным значением -1.
 4a. CONST A $A - константа с именем A и численным значением 10.
 4b. CONST A $FF - константа с именем A и численным значением 255.
 5. CONST "A" 1 - константа с именем "A" и численным значением 1.
 6. CONST "A" 2 - константа с именем "A" и численным значением 2.
 7. CONST "A" 0 - константа с именем "A" и численным значением 0.
 8. CONST "A" -1 - константа с именем "A" и численным значением -1.
 9. CONST A 'a' - константа с именем A и строковым значением a.
 10. CONST "A" 'a' - константа с именем "A" и строковым значением a.
 11. CONST A '' - константа с именем A и строковым значением (пусто).
 12. CONST "A" '' - константа с именем "A" и строковым значением (пусто).
 13. CONST A '''' - константа с именем A и строковым значением '.
 14. CONST "A" '''' - константа с именем "A" и строковым значением '.
 15. CONST A false - константа с именем A и булевым значением false.
 16. CONST "A" false - константа с именем "A" и булевым значением false.
 17. CONST A true - константа с именем A и булевым значением true.
 18. CONST "A" true - константа с именем "A" и булевым значением true.
 19. CONST A B - константа с именем A и значением ДРУГОЙ константы B.
 20. CONST "A" B - константа с именем "A" и значением ДРУГОЙ константы B.
 21. CONST A "B" - константа с именем A и значением ДРУГОЙ константы "B".
 22. CONST "A" "B" - константа с именем "A" и значением ДРУГОЙ константы "B".
23. Далее следуют определения слов. http://programmingmindstream.blogspot.ru/2015/12/1147.html
24. Конструкция : Identifier - начинает определение слова.
25. Конструкция ; - заканчивает определение слова.
26. Конструкция ref; - заканчивает определение слова. Будем ПОКА считать, что это аналог конструкции ;.
27. Примеры:
 1. : A ; - определяет слово A.
 2. : "A" ; - определяет слово "A".
 3. : A ref; - определяет слово A.
 4. : "A" ref; - определяет слово "A".
 5. : A : B ; ; - определяет слово A и вложенное слово B.
 6. : "A" : B ; ; - определяет слово "A" и вложенное слово B.
 7. : A : "B" ; ; - определяет слово A и вложенное слово "B".
 8. : "A" : "B" ; ; - определяет слово "A" и вложенное слово "B".
 9. : A CONST C 1 ; - определяет слово A и вложенную целочисленную константу C.
 10. : A CONST C 'a' ; - определяет слово A и вложенную строковую константу C.
 11. : A CONST C false ; - определяет слово A и вложенную булевскую константу C.
28. Конструкция FORWARD Identifier - "предварительно декларирует слово Identifier".
    Чтобы на него могли сослаться другие, зависимыеотнего слова.
    Примеры:
 1. FORWARD A // - предварительно декларируем слово A
    ...
    : A
    ; // - определяем слово A
 2. FORWARD "A" // - предварительно декларируем слово "A"
    ...
    : "A"
    ; // - определяем слово "A"
 3. FORWARD "A B" // - предварительно декларируем слово "A B"
    ...
    : "A B"
    ; // - определяем слово "A B"
 4. FORWARD A // - предварительно декларируем слово A
    : B
     A // - ссылаемся на слово A
    ; // - определяем слово B
    : A
    ; // - определяем слово A
29. Конструкция Seq: ( Identifier1 .. IdentifierN ) - определяет список ссылок на слова.
    Примеры:
 1. : A
    ; // A
    : B
    ; // B
    : C
     Seq: ( A B ) // - список слов A и B
    ; // C
 2. : A
     Seq: ( ) // - пустой список
    ; // A
 3. : A
     Seq: () // - ТАКЖЕ пустой список
    ; // A
 4. : A
    ; // A
    : B
    ; // B
    : C
     Seq: ( A 1 B ) // - список слов A, числа 1 и B
    ; // C
 5. : A
    ; // A
    : B
    ; // B
    : C
     Seq: ( A 'a' B ) // - список слов A, строки a и B
    ; // C
 6. : A
    ; // A
    : B
    ; // B
    : C
     Seq: ( A false B ) // - список слов A, булевского значения false и B
    ; // C
30. Конструкция WL String1 String2 - является "слабой ссылкой" на слово. Загружаемой OnDemand.
    String1 - имя слова.
    String2 - имя файла из которого надо загрузить слово.
    Если слово String1 не найдено в файле String2, то должен вернуться nil.
    Примеры:
 1. : A
      WL 'WordName' 'WordFile' // - ссылка на слово WordName из файла WordFile.
    ; // A
 2. : X1
    ; // X1 
    : A
      Seq: ( WL 'WordName' 'WordFile' // - ссылка на слово WordName из файла WordFile.
       X1 // - ссылка на слово X1 из НАШЕГО ЖЕ файла
      )
    ; // A