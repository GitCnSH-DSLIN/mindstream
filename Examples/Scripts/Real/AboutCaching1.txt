<div dir="ltr" style="text-align: left;" trbidi="on">
О кешировании. Поговорим устройство "слова".<br />
<br />
Предыдущая серия была тут - <a href="http://programmingmindstream.blogspot.ru/2015/12/1147.html">http://programmingmindstream.blogspot.ru/2015/12/1147.html</a>.<br />
<br />
Там мы ввели понятия "слова", "переменной" и "константы", а также научились ими пользоваться.<br />
<br />
Теперь поговорим на тему "а что же вообще говоря такое слово".<br />
<br />
"Слово" или "элемент словаря" это вообще говоря - "словарная запись", которая представляется в словаре в виде "ключ-значение".<br />
<br />
Т.е. слово:<br />
<br />
<pre class="brush:delphi">: A
 ACode
; // A
</pre>
<br />
В словаре будет представлено парой:<br />
<br />
( A ACode )<br />
<br />
Где:<br />
&nbsp;A - имя слова.<br />
&nbsp;ACode - код слова.<br />
<br />
А <b>точнее говоря</b>&nbsp;- тройкой:<br />
<br />
( : A ACode )<br />
<br />
Где:<br />
&nbsp;: - <b>стереотип</b> слова.<br />
&nbsp;A - имя слова.<br />
&nbsp;ACode - код слова.<br />
<br />
Что такое <b>стереотип</b> слова?<br />
<br />
Это скажем так "категория" к которой это "слово" относится.<br />
<br />
Стереотип может определять различные <b>ограничения</b> на работу со словом.<br />
<br />
Из разряда того, что например:<br />
&nbsp;"константы" - умеют только вычислять значения.<br />
&nbsp;"переменные" - умеют как отдавать значения, так и хранить их.<br />
&nbsp;"слова" - умеют вычислять значения, а также могут содержать вложенные элементы.<br />
<br />
Также стереотипы определяют наборы <b>операций</b> применимых к элементу словаря (об этом поговорим ещё позже).<br />
<br />
Проиллюстрируем использование <b>стереотипов</b> примером:<br />
<br />
<pre class="brush:delphi">: A
 ACode
; // A

VAR B

CONST C 1
</pre>
<br />
Этот пример будет представлен в словаре так:<br />
<br />
&nbsp;( : A ACode )<br />
&nbsp;( VAR B {BValue} )<br />
&nbsp;( CONST C 1 )<br />
<br />
А пример:<br />
<br />
<pre class="brush:delphi">: A
 ACode
; // A

VAR B

CONST C 1
CONST D C
</pre>
<br />
Будет представлен в словаре так:<br />
<br />
&nbsp;( : A ACode )<br />
&nbsp;( VAR B {BValue} )<br />
&nbsp;( CONST C 1 )<br />
&nbsp;( CONST D ref C )<br />
<br />
<b>Обратите</b> внимание, что элемент D <b>не</b> представлен значением "1", а <b>ссылается</b> на элемент C - "ref C".<br />
<br />
Мы этот факт потом ещё обсудим.<br />
<br />
А что же со <b>вложенными</b> словами?<br />
<br />
Как они представляются в словаре?<br />
<br />
Вот тут "оказывается", что слова представляются даже не <b>тройкой</b>, а <b>четвёркой:</b><br />
&nbsp;( Стереотип Имя_Слова Код_Слова Вложенный_Словарь ).<br />
<br />
Проиллюстрируем примером.<br />
<br />
Код:<br />
<br />
<pre class="brush:delphi">: A
 VAR X
 ACode
; // A
</pre>
<br />
Представляется как:<br />
<br />
( : A ACode Dict( VAR X {XValue} ) )<br />
<br />
Где Dict( ... ) - внутренний словарь слова A.<br />
<br />
Ну и новый пример:<br />
<br />
<pre class="brush:delphi">: A
 VAR X
 ACode
; // A

VAR B

CONST C 1
CONST D C
</pre>
<br />
Будет представлен в словаре так:<br />
<br />
&nbsp;( : A ACode Dict( VAR X {XValue} ) )<br />
&nbsp;( VAR B {BValue} Dict( ) )<br />
&nbsp;( CONST C 1 Dict( ) )<br />
&nbsp;( CONST D ref C Dict( ) )<br />
<br />
Тут возникает закономерный вопрос - "а раз словарь это ключ-значение, то нельзя ли получить поступ ко вложеным элементам слова?"<br />
<br />
Ответ - "да можно, потому, что у нас присутствует полная <a href="https://ru.wikipedia.org/wiki/%D0%9E%D1%82%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)">рефлексия</a> кода".<br />
<br />
Как это сделать?<br />
<br />
Для этого у нас есть три замечательных слова аксиоматики:<br />
<br />
&nbsp;<b>@</b> - получает адрес слова.<br />
&nbsp;<b>DO</b> - выполняет слово по адресу (обратная к <b>@</b>).<br />
&nbsp;<b>%%</b> - получает по адресу слова вложенный элемент по его имени.<br />
<br />
Вот как определено слово <b>%%</b>:<br />
<br />
<pre class="brush:delphi">OBJECT operator %%
 OBJECT IN aWord
 ^ IN aName
 
 OBJECT VAR l_Member
 aName DO aWord pop:Word:FindMember &gt;&gt;&gt; l_Member
 
 if ( l_Member pop:object:IsNil ) then
  ( Result := nil )
 else
  ( Result := ( l_Member pop:KeyWord:Word ) ) 
; // %%
</pre>
<br />
Видим, что оно принимает <b>два параметра</b> - <b>aWord</b> и <b>aName</b>.<br />
<br />
&nbsp;<b>aWord</b> - слово для которого мы ищем вложенный элемент.<br />
&nbsp;<b>aName</b> - имя вложенного элемента.<br />
<br />
И возвращает значение типа <b>OBJECT</b> - адрес найденного вложеного элемента, или <b>nil</b>, если такой элемент не найден.<br />
<br />
Приведём пример использования:<br />
<br />
<pre class="brush:delphi">: A
 : X
  2
 ; // X
 1
; // A

@ A // - берём адрес слова A
%% // - операция %%
'X' // - имя искомого слова X
DO // - выполняем слово, которое нашлось
Print // - печатаем значение
</pre>
<br />
Что получится?<br />
<br />
В консоль напечатается целочисленное значение "2", которое возвращает слово X.<br />
<br />
А что делать если искомого вложенного слова нет?<br />
<br />
Ответ - проверить возвращаемое значение на <b>nil</b>.<br />
<br />
Пример:<br />
<br />
<pre class="brush:delphi">: A
 : X
  2
 ; // X
 1
; // A

VAR l_ElementAddr // - переменная для сохранения адреса элемента

@ A %% 'X' &gt;&gt;&gt; l_ElementAddr // - получаем адрес элемента X
if NOT ( l_ElementAddr IsNil ) then
// - проверяем его
begin
 l_ElementAddr DO // - напечатается 2
end

@ A %% 'Y' &gt;&gt;&gt; l_ElementAddr // - получаем адрес элемента Y
if NOT ( l_ElementAddr IsNil ) then
// - проверяем его
begin
 l_ElementAddr DO // - ничего, не напечатается, 
                  //   т.к. сюда не попадём, 
                  //   т.к. у элемента A нет элемента Y
end
</pre>
<br />
А можно ли обойтись без <b>@</b> и <b>DO</b>?<br />
<br />
Ответ - можно.<br />
<br />
Для этого у нас есть слово - <b>::</b>.<br />
<br />
Вот как оно определено:<br />
<br />
<pre class="brush:delphi">^@ operator ::
 ^@ IN aSelf
 ^L IN aName

 OBJECT VAR l_Self
 aSelf |^@ &gt;&gt;&gt; l_Self
 
 STRING VAR l_Name
 aName |N &gt;&gt;&gt; l_Name
 
 OBJECT VAR l_Res
 l_Self %% l_Name &gt;&gt;&gt; l_Res
 
 ASSURE 
  NOT ( l_Res pop:object:IsNil ) 
  [ 'Не найдено поле: ' l_Self LIST %P Reverted ==&gt; ( |N '::' ) l_Self |N '::' l_Name ]
 l_Res &gt;&gt;&gt; Result
; // ::
</pre>
<br />
Пример использования:<br />
<br />
<pre class=brush:delphi>
: A
 : X
  2
 ; // X
 1
; // A

A :: X Print // - напечатает значение "2", которое возвращает X
A :: Y Print // - упадёт с Run-Time ошибкой, что "поле Y не найдено"
</pre>
<br/>
Более того - при помощи <b>::</b> можно не только <b>читать</b>, но и <b>писать</b> значения вложенных элементов (если они поддерживают запись).<br/><br/>
Пример:<br/><br/>
<br /></div>
