<div dir="ltr" style="text-align: left;" trbidi="on">
О кешировании. Поговорим устройство "слова".<br />
<br />
Предыдущая серия была тут - <a href="http://programmingmindstream.blogspot.ru/2015/12/1147.html">http://programmingmindstream.blogspot.ru/2015/12/1147.html</a>.<br />
<br />
Там мы ввели понятия "слова", "переменной" и "константы", а также научились ими пользоваться.<br />
<br />
Теперь поговорим на тему "а что же вообще говоря такое слово".<br />
<br />
"Слово" или "элемент словаря" это вообще говоря - "словарная запись", которая представляется в словаре в виде "ключ-значение".<br />
<br />
Т.е. слово:<br />
<br />
<pre class="brush:delphi">: A
 ACode
; // A
</pre>
<br />
В словаре будет представлено парой:<br />
<br />
( A ACode )<br />
<br />
Где:<br />
&nbsp;A - имя слова.<br />
&nbsp;ACode - код слова.<br />
<br />
А <b>точнее говоря</b>&nbsp;- тройкой:<br />
<br />
( : A ACode )<br />
<br />
Где:<br />
&nbsp;: - <b>стереотип</b> слова.<br />
&nbsp;A - имя слова.<br />
&nbsp;ACode - код слова.<br />
<br />
Что такое <b>стереотип</b> слова?<br />
<br />
Это скажем так "категория" к которой это "слово" относится.<br />
<br />
Стереотип может определять различные <b>ограничения</b> на работу со словом.<br />
<br />
Из разряда того, что например:<br />
&nbsp;"константы" - умеют только вычислять значения.<br />
&nbsp;"переменные" - умеют как отдавать значения, так и хранить их.<br />
&nbsp;"слова" - умеют вычислять значения, а также могут содержать вложенные элементы.<br />
<br />
Также стереотипы определяют наборы <b>операций</b> применимых к элементу словаря (об этом поговорим ещё позже).<br />
<br />
Проиллюстрируем использование <b>стереотипов</b> примером:<br />
<br />
<pre class="brush:delphi">: A
 ACode
; // A

VAR B

CONST C 1
</pre>
<br />
Этот пример будет представлен в словаре так:<br />
<br />
&nbsp;( : A ACode )<br />
&nbsp;( VAR B {BValue} )<br />
&nbsp;( CONST C 1 )<br />
<br />
А пример:<br />
<br />
<pre class="brush:delphi">: A
 ACode
; // A

VAR B

CONST C 1
CONST D C
</pre>
<br />
Будет представлен в словаре так:<br />
<br />
&nbsp;( : A ACode )<br />
&nbsp;( VAR B {BValue} )<br />
&nbsp;( CONST C 1 )<br />
&nbsp;( CONST D ref C )<br />
<br />
<b>Обратите</b> внимание, что элемент D <b>не</b> представлен значением "1", а <b>ссылается</b> на элемент C - "ref C".<br />
<br />
Мы этот факт потом ещё обсудим.<br />
<br />
А что же со <b>вложенными</b> словами?<br />
<br />
Как они представляются в словаре?<br />
<br />
Вот тут "оказывается", что слова представляются даже не <b>тройкой</b>, а <b>четвёркой:</b><br />
&nbsp;( Стереотип Имя_Слова Код_Слова Вложенный_Словарь ).<br />
<br />
Проиллюстрируем примером.<br />
<br />
Код:<br />
<br />
<pre class="brush:delphi">: A
 VAR X
 ACode
; // A
</pre>
<br />
Представляется как:<br />
<br />
( : A ACode Dict( VAR X {XValue} ) )<br />
<br />
Где Dict( ... ) - внутренний словарь слова A.<br />
<br />
Ну и новый пример:<br />
<br />
<pre class="brush:delphi">: A
 VAR X
 ACode
; // A

VAR B

CONST C 1
CONST D C
</pre>
<br />
Будет представлен в словаре так:<br />
<br />
&nbsp;( : A ACode Dict( VAR X {XValue} ) )<br />
&nbsp;( VAR B {BValue} Dict( ) )<br />
&nbsp;( CONST C 1 Dict( ) )<br />
&nbsp;( CONST D ref C Dict( ) )<br />
<br />
Тут возникает закономерный вопрос - "а раз словарь это ключ-значение, то нельзя ли получить поступ ко вложеным элементам слова?"<br />
<br />
Ответ - "да можно, потому, что у нас присутствует полная <a href="https://ru.wikipedia.org/wiki/%D0%9E%D1%82%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)">рефлексия</a> кода".<br />
<br />
Как это сделать?<br />
<br />
Для этого у нас есть три замечательных слова аксиоматики:<br />
<br />
&nbsp;<b>@</b> - получает адрес слова.<br />
&nbsp;<b>DO</b> - выполняет слово по адресу (обратная к <b>@</b>).<br />
&nbsp;<b>%%</b> - получает по адресу слова вложенный элемент по имени.<br />
<br /></div>
