<div dir="ltr" style="text-align: left;" trbidi="on">
Предыдущая серия была тут - <a href="http://programmingmindstream.blogspot.ru/2015/12/1163-wordworker-operator.html">#1163. :, PROCEDURE, FUNCTION. Параметры справа и слева.Часть 1</a>.<br />
<br />
Там мы рассмотрели ключевые слова <b>:</b>, <b>;</b>, <b>FUNCTION</b>, <b>PROCEDURE</b>.<br />
<br />
А также "параметры слева".<br />
<br />
Рассмотрим теперь "параметры справа".<br />
<br />
Пусть у нас есть пример с "параметрами слева":

<br />
<br />
<pre class="brush:delphi">INTEGER FUNCTION Plus
 INTEGER IN A
 INTEGER IN B
 A B + &gt;&gt;&gt; Result // - складываем A и B и помещаем в Result
; // Plus

1 2 Plus . // - вызываем нашу функцию и печатаем результат
</pre>
<br />
Тут мы имеет "типичную" <a href="https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%B0%D1%8F_%D0%BF%D0%BE%D0%BB%D1%8C%D1%81%D0%BA%D0%B0%D1%8F_%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D1%8C">ОПЗ</a>.
<br />
<br />
А что делать, если мы хотим пользоваться <a href="https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%84%D0%B8%D0%BA%D1%81%D0%BD%D0%B0%D1%8F_%D0%BD%D0%BE%D1%82%D0%B0%D1%86%D0%B8%D1%8F">инфиксной нотацией</a>?<br />
<br />
Вот тут нам помогут <b>параметры справа</b>.<br />
<br />
Перепишем наш пример с использованием <b>параметров справа</b>:<br />
<br />
<pre class="brush:delphi">INTEGER FUNCTION Plus
 INTEGER IN A // - параметр слева
 ^ IN B // - параметр СПРАВА передаётся по ССЫЛКЕ, а не по ЗНАЧЕНИЮ. 
        //   Его надо разыменовывать.
 A // - значение параметра A
 B DO // - разыменовываем значение B. Т.е. зовём метод DO на том слове на которое указывает B
 + &gt;&gt;&gt; Result // - складываем A и B и помещаем в Result
; // Plus

1 Plus 2 . // - вызываем нашу функцию ИНФИКСНО и печатаем результат
</pre>
<br />
Также можно написать:<br />
<br />
<pre class="brush:delphi">1 Plus ( 2 Plus ( 3 Plus 4 ) ) .
</pre>
<br />
Скобки пока обязательны.<br />
<br />
Как обойтись без скобок - напишу отдельно.<br />
<br />
Также наш пример можно переписать так:<br />
<br />
<pre class="brush:delphi">INTEGER FUNCTION Plus
 INTEGER IN A // - параметр слева
 ^ IN B // - параметр СПРАВА передаётся по ССЫЛКЕ, а не по ЗНАЧЕНИЮ. 
        //   Его надо разыменовывать.
 A // - значение параметра A
 B |^ // - разыменовываем значение B. Т.е. зовём метод |^ на том слове на которое указывает B
 + &gt;&gt;&gt; Result // - складываем A и B и помещаем в Result
; // Plus

1 Plus 2 . // - вызываем нашу функцию ИНФИКСНО и печатаем результат
</pre>
<br />
Тут используется |^ вместо DO.<br />
<br />
Они вообще говоря равноценны.<br />
<br />
Про <b>отличия</b> я напишу несколько позже.<br />
<br />
Метод&nbsp;|^ в аксиоматике определяется так:<br />
<br />
<pre class="brush:delphi">: |^
  ^@ IN aRef
  
 %SUMMARY 'Разыменовывает параметр слева' ;
 aRef pop:Word:GetRef DO
; // |^
</pre>
<br />
Детали реализации |^ я также опишу позже.
<br />
<br />
Но пока отмечу, что |^ использует DO. Т.е. |^ является производным от DO.<br />
<br />
Пойдём далее.<br />
<br />
Зачем параметры справа передаются по ссылке,а не по значению?<br />
<br />
Тому есть много причин.<br />
<br />
В частности - "<a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%B5%D0%BD%D0%B8%D0%B2%D1%8B%D0%B5_%D0%B2%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F">ленивые вычисления</a>".<br />
<br />
Рассмотрим реализацию булевских операций AND и OR.<br />
<br />
Вот она:<br />
<br />
<pre class="brush:delphi">BOOLEAN operator AND 
  BOOLEAN IN aFirst
  ^ IN aSecond
 %SUMMARY 'Двусторонний, а не обратный польский &amp;&amp;' ;
 if aFirst then
  (
   if ( aSecond DO ) then
    ( true &gt;&gt;&gt; Result )
   else
    ( false &gt;&gt;&gt; Result )
   )
 else
  ( false &gt;&gt;&gt; Result )
; // AND

BOOLEAN operator OR 
  BOOLEAN IN aFirst
  ^ IN aSecond
 // Двусторонний, а не обратный польский ||
 if aFirst then
  ( Result := true )
 else
  if ( aSecond DO ) then
   ( Result := true )
  else
   ( Result := false )
; // OR

</pre>
Тут видно, что параметр aSecond будет вычисляться ТОЛЬКО если он нужен для вычисления всего выражения.<br />
<br />
Т.е. если по параметру aFirst - результат выражения будет <b>ещё неясен</b>.
<br />
<br />
Слово operator является аналогом слов : и FUNCTION. ОН лишь подчёркивает "операторную сущность" определяемых слов.<br />
<br />
В частности операторам можно задавать "<a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BE%D1%80%D0%B8%D1%82%D0%B5%D1%82_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8">приоритет выполнения</a>" как например в <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%BB%D0%BE%D0%B3_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)">Prolog</a>. Чтобы например избавиться от скобок в примере со словом Plus выше. Но об этом расскажу отдельно.<br />
<br />
Но пока будем считать, что operator определён как:<br />
<br />
<pre class="brush:delphi">WordAlias operator :
WordAlias OPERATOR :
</pre>
<br />
И что мы получаем с <b>ленивыми вычислениями</b>?<br />
<br />
Если написать без ленивых вычислений:<br />
<br />
<pre class="brush:delphi">if ( ( anObject &lt;&gt; nil ) ( anObject .SomeMethod ) &amp;&amp; ) then
</pre>
<br />
То получим Access Violation.<br />
<br />
А с ленивыми вычислениями:<br />
<br />
<pre class="brush:delphi">if ( ( anObject &lt;&gt; nil ) AND ( anObject .SomeMethod ) ) then
</pre>
<br />
Access Violation - не будет.<br />
<br />
Надеюсь - понятно почему.
<br />
<br />
Пойдём далее.<br />
<br />
Тот факт, что передаётся ссылка на слово, а не значение означает то, что если в качестве слова падали переменную, то мы можем писать в неё.<br />
<br />
Реализуем например методы инкремента и декремента.<br />
<br />
Так как они описаны в аксиоматике:</div>
