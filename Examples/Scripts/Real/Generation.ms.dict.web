UNIT Generation.ms.dict

USES
 params.ms.dict
;

USES
 axiom_push.ms.dict
;

USES
 core.ms.dict
;

USES
 Log.ms.dict
;

USES
 WordsRTTI.ms.dict
;

USES 
 ElementsRTTI.ms.dict
;

USES
 CompileTimeVar.ms.dict
;

USES
 SaveVarAndDo.ms.dict
;

CONST cPathSep '\'

USES
 Chars.ms.dict
;

USES
 Out.ms.dict
;

USES
 axiom:SysUtils
;

USES
 arrays.ms.dict
;

USES
 IsNil.ms.dict
;

TtfwWord FUNCTION .FindMemberRecur
  STRING IN aName
  TtfwWord IN aGen

 TtfwKeyWord VAR l_Member
 aName aGen pop:Word:FindMember &gt;&gt;&gt; l_Member

 if ( l_Member .IsNil ) then
  ( nil &gt;&gt;&gt; Result )
 else
  ( l_Member pop:KeyWord:Word &gt;&gt;&gt; Result )

 if ( Result .IsNil ) then
  ( 
   aGen .Inherited.Words .for&gt; ( 
    IN anItem 
    VAR l_Found 
    aName anItem call.me &gt;&gt;&gt; l_Found
    ( Result .IsNil ) 
    OR ( l_Found .IsNil ) 
    OR ( Result = l_Found ) 
     ?ASSURE [ 'Multiply inheritance. Word: ' aName ' generator ' aGen .WordName ' parent generator ' anItem .WordName ]
    l_Found &gt;&gt;&gt; Result
   ) 
  )

; // .FindMemberRecur

ARRAY CompileTime-VAR g_GeneratedFiles []
%REMARK 'Ранее сгенерированные файлы'

TtfwWord VAR g_CurrentGenerator
%REMARK 'Текущий генератор'

: WithGen:
  ^ IN aGen
  ^ IN aLambda
 TF g_CurrentGenerator (
  aGen &gt;&gt;&gt; g_CurrentGenerator
  aLambda DO
 ) // TF g_CurrentGenerator
; // WithGen:

WordAlias .All .True
%REMARK 'Функтор определяющий, что все значения подходят.'

WordAlias GenCached: CacheMethod
%REMARK 'Кеширует значение учитывая текущий генератор. Пока определено как Cached:'

: .?
  ^ IN aWord

 VAR l_Word

 aWord |N g_CurrentGenerator .FindMemberRecur &gt;&gt;&gt; l_Word

 if ( l_Word .IsNil ) then
  ( aWord DO )
 else
  ( l_Word DO )
; // .?

STRING FUNCTION Ext
 '.dump' &gt;&gt;&gt; Result
; // Ext

PROCEDURE ForceDirectories
  STRING IN aPath
 aPath sysutils:ForceDirectories ?ASSURE [ 'Не удалось создать директорию ' aPath ]  
; // ForceDirectories

FILE FUNCTION TryOpen:
  STRING IN aFileName
  ^ IN aOpenLambda
 %SUMMARY
  'Открывает файл aFileName методом aOpenLambda обрабатывая ошибки открытия.' 
  'Пытается открыть файл повторно несколько раз.'
 ;
 VAR l_TryCount
 20 &gt;&gt;&gt; l_TryCount
 
 while ( l_TryCount &gt; 0 )
 begin
  TRY
   aFileName aOpenLambda DO &gt;&gt;&gt; Result 
   0 &gt;&gt;&gt; l_TryCount
  EXCEPT
   Dec l_TryCount
   nil &gt;&gt;&gt; Result
   if ( l_TryCount 0 == ) then
    RAISE
   else
   begin
    [ 'Файл ' aFileName ' был занят. Ожидаем его освобождения. Попытка номер: ' l_TryCount IntToStr ] strings:Cat &gt;&gt;std::out
    500 SLEEP
   end // ( l_TryCount 0 == )
  END // TRY..EXCEPT
 end // ( l_TryCount &gt; 0 )
; // TryOpen: 

FILE FUNCTION MakePathAndOpenWrite
  STRING IN aFileName
 %SUMMARY 
  'Открывает файл aFileName на запись.' 
  'Если надо - создаёт полный путь на файловой системе.'
 ;
 aFileName sysutils:ExtractFilePath ForceDirectories
 aFileName TryOpen: File:OpenWrite &gt;&gt;&gt; Result
; // MakePathAndOpenWrite

CONST cRoot 'w:'

PROCEDURE BackupFile
  STRING IN aFileName
  VAR l_To
 aFileName &gt;&gt;&gt; l_To
 l_To cRoot 'W:' string:Replace &gt;&gt;&gt; l_To
 l_To 'W:' 'C:\Temp\GenBackup' string:Replace &gt;&gt;&gt; l_To
 if ( aFileName sysutils:FileExists ) then
 begin
  $20 l_To aFileName CopyFile
 end // ( aFileName sysutils:FileExists )
 else
 begin
  FILE VAR l_In
  l_To MakePathAndOpenWrite &gt;&gt;&gt; l_In
  // - делаем пустышку
  TRY
  FINALLY
   nil &gt;&gt;&gt; l_In
  END // TRY..FINALLY
 end // ( aFileName sysutils:FileExists )
; // BackupFile

PROCEDURE CopyChangedFile
  STRING IN aTo
  STRING IN aFrom
  BOOLEAN IN aNeedBackup
 aTo .NotIsNil ?ASSURE aFrom
 aFrom .NotIsNil ?ASSURE aTo
 if (
     ( aTo sysutils:FileExists ! )
     OR ( cEmptyStr aTo aFrom CompareFiles ! ) 
    ) then
 begin
  if aNeedBackup then
  begin
   aTo BackupFile
  end // aNeedBackup
  $20 aTo aFrom CopyFile
 end 
; // CopyChangedFile

STRING elem_func FinalFileNamePrim
 cEmptyStr &gt;&gt;&gt; Result 
; // FinalFileNamePrim

STRING FUNCTION .CutSuffix
  STRING IN aString
  STRING IN aSuffix
 RULES
  ( aString .IsNil )
   ''
  ( aSuffix .IsNil )
   aString
  DEFAULT
  begin   
   aString &gt;&gt;&gt; Result 
   if ( aSuffix Result EndsStr ) then
   begin
    Result string:Len aSuffix string:Len - 
    0
    Result
    string:Substring &gt;&gt;&gt; Result
   end // ( aSuffix Result EndsStr )
   Result
  end // DEFAULT
 ; // RULES
 &gt;&gt;&gt; Result 
; // .CutSuffix

STRING FUNCTION .CutPrefix
  STRING IN aString
  STRING IN aPrefix
 RULES
  ( aString .IsNil )
   ''
  ( aPrefix .IsNil )
   aString
  DEFAULT
  begin   
   aString &gt;&gt;&gt; Result 
   if ( aPrefix Result StartsStr ) then
   begin
    Result string:Len aPrefix string:Len - 
    aPrefix string:Len
    Result
    string:Substring &gt;&gt;&gt; Result
   end // ( aPrefix Result StartsStr )
   Result
  end // DEFAULT
 ; // RULES
 &gt;&gt;&gt; Result 
; // .CutPrefix

USES
 CountIt.ms.dict
;

STRING elem_func LUID
 VAR l_UID
 Self .UID &gt;&gt;&gt; l_UID
 RULES
  DEFAULT
   l_UID
 ; // RULES
 &gt;&gt;&gt; Result
; // LUID

BOOLEAN elem_func IsSameModelElement
  ModelElement IN anOther
 RULES
  ( Self anOther ?== )
   true
  ( Self .LUID anOther .LUID == )
   true
  DEFAULT
   false 
 ; // RULES  
 &gt;&gt;&gt; Result 
; // IsSameModelElement

BOOLEAN elem_func IsArray
 Self .IsStereotype st_Vector
 &gt;&gt;&gt; Result
; // IsArray

BOOLEAN elem_func IsOpenArray
 Self .IsArray
 AND ( Self .GetUP "array type" 'open' == )
 &gt;&gt;&gt; Result
; // IsOpenArray

USES
 FirstElement.ms.dict
;

ModelElement elem_func FirstAttribute
 Cached:
 (
  Self .Attributes .FirstElement
 )
 &gt;&gt;&gt; Result
; // FirstAttribute

BOOLEAN elem_func IsMixInParamType
 Self .IsStereotype st_ImpurityParamType 
 &gt;&gt;&gt; Result
; // IsMixInParamType

: g_MixInParamTypes
 @SELF
; // g_MixInParamTypes
  
BOOLEAN elem_func IsIterator
 Self .IsStereotype st_Iterator &gt;&gt;&gt; Result
; // IsIterator

FORWARD .IteratorAction

STRING elem_func TypeName
 Cached:
 (
  RULES
   ( Self .IsNil )
    ''
   ( Self IsString )
    Self
   ( Self .IsOpenArray )
    ( [ 'array of ' Self .FirstAttribute .Target call.me ] strings:Cat )
   ( Self .IsIterator )
    ( Self .IteratorAction call.me )
   DEFAULT  
    (
     STRING VAR l_ExtName
     Self .GetUP 'extprop:pas:TypeName' &gt;&gt;&gt; l_ExtName
     RULES
      ( l_ExtName .IsNotNil )
       l_ExtName
      DEFAULT
       ( Self .Name )
     ; // RULES
    )
  ; // RULES  
 )
 &gt;&gt;&gt; Result
 if ( Self .IsMixInParamType ) then
 begin
  VAR l_Field
  @ g_MixInParamTypes %% ( Self .Name ) &gt;&gt;&gt; l_Field
  if ( l_Field .IsNotNil ) then
  begin
   l_Field DO &gt;&gt;&gt; l_Field
   if ( l_Field .IsNotNil ) then
   begin
    l_Field call.me &gt;&gt;&gt; Result
   end // ( l_Field .IsNotNil )
  end // ( l_Field .IsNotNil )
 end // ( Self .IsMixInParamType )
; // TypeName

BOOLEAN elem_func IsSameType
  ModelElement IN anOther
 RULES
  ( Self anOther .IsSameModelElement )
   true
  ( Self IsString )
   RULES
    ( anOther IsString )
     false
    DEFAULT 
     ( Self anOther .TypeName == )
   ; // RULES
  ( anOther IsString )
   RULES
    ( Self IsString )
     false
    DEFAULT 
     ( Self .TypeName anOther == )
   ; // RULES
  ( Self .TypeName anOther .TypeName == )
   true
  DEFAULT
   false 
 ; // RULES  
 &gt;&gt;&gt; Result 
; // IsSameType

USES
 GarantModel.ms.dict
 GarantMetaModel.ms.dict
;

WordAlias [[ [
%REMARK 'Начинает определение константного массива. Пока просто мапируется на неконстантный.'
WordAlias ]] ]
%REMARK 'Заканчивает определение константного массива. Пока просто мапируется на неконстантный.'

USES
 axiom:WordBox
;

ModelElement elem_func WeakRef
 %SUMMARY 
  'Возвращает СЛАБУЮ ссылку на элемент.'
 ;
 RULES
  ( Self IsIntf )
   ( Self pop:WordBox:Boxed )
  DEFAULT
   Self 
 ; // RULES
 &gt;&gt;&gt; Result
; // WeakRef

ARRAY elem_func CachedElementToArray
 Cached:
 (
  [[ Self .WeakRef ]]
 ) 
 &gt;&gt;&gt; Result 
; // CachedElementToArray

ARRAY elem_func ElementToArray
 RULES
  ( Self .IsNil )
   [empty]
  ( Self IsIntf ) 
   [[ Self ]]
  DEFAULT
   ( Self .CachedElementToArray )
 ; // RULES
 &gt;&gt;&gt; Result 
; // ElementToArray

WordAlias .ToArray .ElementToArray

ARRAY elem_func ElementToArray:
  ^ IN aLambda
 Self aLambda DO .ElementToArray
 &gt;&gt;&gt; Result 
; // ElementToArray:

WordAlias .ToArray: .ElementToArray:

ARRAY FUNCTION ToArray:
  ^ IN Self
 VAR l_Value 
 Self DO &gt;&gt;&gt; l_Value 
 RULES
  ( l_Value IsIntf )
   [[ l_Value ]]
  DEFAULT
   ( l_Value .ToArray )
 ; // RULES  
 &gt;&gt;&gt; Result 
; // ToArray:

WordAlias .KeepInStack NOP

ARRAY FUNCTION array:Copy
  IN anArray
 RULES
  ( anArray .IsNil )
   [nil]
  DEFAULT 
   (
    VAR l_Empty
    true &gt;&gt;&gt; l_Empty
    [ 
     anArray .for&gt; ( 
      // .KeepInStack
      // - это теперь не нужно, непустой функтор и так есть
      false &gt;&gt;&gt; l_Empty
     ) // anArray .for&gt;
    ] 
    RULES
     l_Empty
      ( DROP [nil] )
    ; // RULES
   ) 
 ; // RULES 
 &gt;&gt;&gt; Result
; // array:Copy

ARRAY FUNCTION array:CopyNotNil
  IN anArray
 [ anArray .for&gt; .KeepInStack ] 
 &gt;&gt;&gt; Result
; // array:CopyNotNil

USES
 Controls.ms.dict
;

elem_iterator InheritsEx
 Cached:
 (
  VAR l_Inherits
  Self .Inherits &gt;&gt;&gt; l_Inherits
  RULES
   ( l_Inherits .IsEmpty )
    RULES
     ( Self .IsControlOverride )
      [empty]
     ( Self .IsControlPrim )
      begin
       VAR l_Name
       if ( Self .IsComponent ) then
       begin
        Self .GetUP "ComponentClass" &gt;&gt;&gt; l_Name
       end // ( Self .IsComponent )
       else
       begin
        Self .GetUP "ControlClass" &gt;&gt;&gt; l_Name
       end // ( Self .IsComponent )
       AllModelControls
       .filter&gt; ( .Name l_Name == )
       array:Copy
      end // ( Self .IsControlPrim )
     ( Self .IsScriptKeyword )
      ( ToArray: GarantModel::TtfwRegisterableWord )
     DEFAULT
      [empty]
    ; // RULES 
   DEFAULT
    l_Inherits
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // InheritsEx

BOOLEAN elem_func InheritsFrom
  ModelElement IN anAncestor
 anAncestor :Cached:
 ( 
  RULES
   ( Self .IsNil )
    false
   ( Self anAncestor .IsSameType )
    true
   (
    Self .InheritsEx
    .filter&gt; ( anAncestor call.me )
    .NotEmpty
   )
    true
   DEFAULT
    false 
  ; // RULES
 ) 
 &gt;&gt;&gt; Result
; // InheritsFrom

USES
 UseNewGenExcluded.ms.dict
;

BOOLEAN elem_func IsControllerInterfaces
 ( Self .IsStereotype st_ControllerInterfaces )
 &gt;&gt;&gt; Result
; // IsControllerInterfaces

USES
 ForceUseNewGen.ms.dict
;

BOOLEAN elem_func IsUtilityPack
 Cached:
 (
  RULES
   ( Self .IsStereotype st_UtilityPack )
    true
   ( Self .IsScriptKeywordsPack ) 
    true
   DEFAULT
    false
  ; // RULES 
 ) 
 &gt;&gt;&gt; Result
; // IsUtilityPack

BOOLEAN elem_func UseNewGenExcluded
 RULES
  //( Self .IsControllerInterfaces )
  // true
  ( Self GarantModel::vcmData .InheritsFrom )
   true
  ( Self GarantModel::TddComboBoxConfigItem .InheritsFrom )
   true
  ( Self GarantModel::Tl3ProtoObjectForTie ?== )
   false
  ( Self GarantModel::Tl3ProtoObjectForTie .InheritsFrom )
   true
  DEFAULT
   begin
    if ( g_UseNewGenExcluded .IsNil ) then
     Init_g_UseNewGenExcluded
     
    g_UseNewGenExcluded .IsNil ?FAIL 'Не инициализирован g_UseNewGenExcluded'
    
    g_UseNewGenExcluded
    .filter&gt; ( Self .LUID == )
    .NotEmpty
   end // DEFAULT 
 ; // RULES  
 &gt;&gt;&gt; Result
; // UseNewGenExcluded

CONST cNotFinished 'NOT_FINISHED_'
CONST cNotCompleted 'NOT_COMPLETED_'

STRING FUNCTION .CutFinished
  STRING IN Self
 Self
 cNotFinished .CutPrefix
 cNotCompleted .CutPrefix
 &gt;&gt;&gt; Result
; // .CutFinished

STRING elem_func CustomFinalFileName
  BOOLEAN IN aForCopy
 Self .? .FinalFileNamePrim &gt;&gt;&gt; Result
 if ( Result .IsNotNil ) then
 begin
  Result '\' .CutPrefix &gt;&gt;&gt; Result
  [ cRoot 
  // - это потому, что в пути нету диска, а для ExtractFileName он нужен
  Result ] cPathSep strings:CatSep &gt;&gt;&gt; Result
 end // ( Result .IsNotNil )
 if ( Result .IsNotNil ) then
 begin
  if aForCopy then
   if ( Self .UseNewGenExcluded ) then
   begin
    VAR l_Path
    VAR l_Name
    Result sysutils:ExtractFilePath &gt;&gt;&gt; l_Path
    Result sysutils:ExtractFileName &gt;&gt;&gt; l_Name
    
    l_Name .CutFinished
    &gt;&gt;&gt; l_Name
    cNotCompleted l_Name Cat
    &gt;&gt;&gt; l_Name
    
    l_Path l_Name Cat &gt;&gt;&gt; Result
   end // (Self .UseNewGenExcluded )
 end // ( Result .IsNotNil )  
; // CustomFinalFileName

STRING elem_func FinalFileName
 Self true .CustomFinalFileName
 &gt;&gt;&gt; Result
; // FinalFileName

STRING CompileTime-VAR g_TempFileName ''
STRING CompileTime-VAR g_RealFileName ''
STRING CompileTime-VAR g_FinalFileName ''
STRING CompileTime-VAR g_FinalFileNameForUC ''
BOOLEAN CompileTime-VAR g_UCRead false
ModelElement CompileTime-VAR g_CurrentGeneratedElement nil

CONST cGenScriptsFolder 'W:\common\GenScripts\'

BOOLEAN elem_func CanCopyToFinalFile
 false &gt;&gt;&gt; Result
; // CanCopyToFinalFile

PROCEDURE DoDeleteFile
  STRING IN aFileName
  BOOLEAN IN aNeedBackup
 if aNeedBackup then
 begin
  aFileName BackupFile
 end // aNeedBackup
 aFileName DeleteFile DROP
; // DoDeleteFile

elem_proc GenerateWordToFileWith:
 ^ IN aLambda
 
 TF g_Indent (
  '' &gt;&gt;&gt; g_Indent
  STRING VAR l_FileName 
  [ Self .WordName .? Ext ] strings:Cat &gt;&gt;&gt; l_FileName
 
  STRING VAR l_TempPath
  'C:\Temp\GenScripts\' &gt;&gt;&gt; l_TempPath
  l_TempPath ForceDirectories
  
  STRING VAR l_RealPath
  cGenScriptsFolder &gt;&gt;&gt; l_RealPath
  l_RealPath ForceDirectories
  
  TF g_TempFileName (
   [ l_TempPath l_FileName ] cPathSep strings:CatSep &gt;&gt;&gt; g_TempFileName
   
   TF g_RealFileName (
    [ l_RealPath l_FileName ] cPathSep strings:CatSep &gt;&gt;&gt; g_RealFileName
    
    if ( g_TempFileName .TextNotInArray: g_GeneratedFiles ) then
    begin
     g_TempFileName .AddToArray: g_GeneratedFiles
     TF g_FinalFileName (
      TF g_FinalFileNameForUC (
       Self .FinalFileName &gt;&gt;&gt; g_FinalFileName
       Self false .CustomFinalFileName &gt;&gt;&gt; g_FinalFileNameForUC
       TF g_OutFile (
        g_TempFileName MakePathAndOpenWrite &gt;&gt;&gt; g_OutFile
        TF g_UCRead (
         TF g_NeedOutLn (
          TF g_CurrentGeneratedElement (
           Self &gt;&gt;&gt; g_CurrentGeneratedElement
           Self aLambda DO
          )
         ) // TF g_NeedOutLn
        ) // TF g_UCRead
       ) // TF g_OutFile
       g_RealFileName g_TempFileName false CopyChangedFile
       if ( g_FinalFileName .IsNotNil ) then
       begin
        if ( Self .? .CanCopyToFinalFile ) then
        begin
         g_FinalFileName g_TempFileName true CopyChangedFile
         
         VAR l_Path
         VAR l_Name
         
         g_FinalFileName sysutils:ExtractFilePath &gt;&gt;&gt; l_Path
         g_FinalFileName sysutils:ExtractFileName &gt;&gt;&gt; l_Name
         
         VAR l_NameToDelete
         VAR l_FileToDelete
         
         if ( cNotCompleted l_Name StartsStr ! ) then
         begin
          l_Name cNotFinished .CutPrefix &gt;&gt;&gt; l_NameToDelete
          [ l_Path cNotCompleted l_NameToDelete ] strings:Cat &gt;&gt;&gt; l_FileToDelete
          if ( l_FileToDelete g_FinalFileName SameText ! ) then
          begin
           if ( l_FileToDelete sysutils:FileExists ) then
           begin
            l_FileToDelete true DoDeleteFile
           end // ( l_FileToDelete sysutils:FileExists )
          end // ( l_FileToDelete g_FinalFileName SameText ! )
         end // ( cNotCompleted l_Name StartsStr ! )
         
         if ( cNotFinished l_Name StartsStr ! ) then
         begin
          l_Name cNotCompleted .CutPrefix &gt;&gt;&gt; l_NameToDelete
          [ l_Path cNotFinished l_NameToDelete ] strings:Cat &gt;&gt;&gt; l_FileToDelete
          if ( l_FileToDelete g_FinalFileName SameText ! ) then
          begin
           if ( l_FileToDelete sysutils:FileExists ) then
           begin
            l_FileToDelete true DoDeleteFile
           end // ( l_FileToDelete sysutils:FileExists )
          end // ( l_FileToDelete g_FinalFileName SameText ! )
         end // ( cNotFinished l_Name StartsStr ! )
         
        end // ( Self .? .CanCopyToFinalFile )
       end // ( g_FinalFileName .IsNotNil )
      ) // TF g_FinalFileNameForUC
     ) // TF g_FinalFileName
    end // g_TempFileName .TextNotInArray: g_GeneratedFiles
   ) // TF g_RealFileName
  ) // TF g_TempFileName
 ) // TF g_Indent 
; // GenerateWordToFileWith:

elem_proc DeleteWordFile
 
  STRING VAR l_FileName 
  [ Self .WordName .? Ext ] strings:Cat &gt;&gt;&gt; l_FileName
  
  STRING VAR l_RealPath
  cGenScriptsFolder &gt;&gt;&gt; l_RealPath
  
  TF g_RealFileName (
   [ l_RealPath l_FileName ] cPathSep strings:CatSep &gt;&gt;&gt; g_RealFileName
   
   if ( g_RealFileName sysutils:FileExists ) then
   begin
    g_RealFileName true DoDeleteFile
   end // ( g_RealFileName sysutils:FileExists )
  ) // TF g_RealFileName 
; // DeleteWordFile

BOOLEAN elem_func IsServiceImplementation
 Self .IsStereotype st_ServiceImplementation 
 &gt;&gt;&gt; Result
; // IsServiceImplementation

BOOLEAN elem_func IsService
 Self .IsStereotype st_Service 
 &gt;&gt;&gt; Result
; // IsService

BOOLEAN elem_func IsTestCase
 Self .IsStereotype st_TestCase 
 &gt;&gt;&gt; Result
; // IsTestCase

BOOLEAN elem_func IsTestLibrary
 Self .IsStereotype st_TestLibrary
 &gt;&gt;&gt; Result
; // IsTestLibrary

BOOLEAN elem_func IsTestUnit
 Self .IsStereotype st_TestUnit
 &gt;&gt;&gt; Result
; // IsTestUnit

BOOLEAN elem_func IsUnit
 Self .IsStereotype st_Unit
 &gt;&gt;&gt; Result
; // IsUnit

BOOLEAN elem_func IsImpl
 Self .IsStereotype st_Impl
 &gt;&gt;&gt; Result
; // IsImpl

BOOLEAN elem_func IsLibrary
 Self .IsStereotype st_Library
 &gt;&gt;&gt; Result
; // IsLibrary

BOOLEAN elem_func IsVCMModule
 Self .IsStereotype st_VCMModule
 &gt;&gt;&gt; Result
; // IsVCMModule

BOOLEAN elem_func IsVCMCustomForm
 Self .IsStereotype st_VCMCustomForm 
 &gt;&gt;&gt; Result
; // IsVCMCustomForm

BOOLEAN elem_func IsVCMDataModule
 Self .IsStereotype st_VCMDataModule
 &gt;&gt;&gt; Result
; // IsVCMDataModule

BOOLEAN elem_func IsVCMForm
 Self .IsStereotype st_VCMForm 
 &gt;&gt;&gt; Result
; // IsVCMForm

BOOLEAN elem_func IsVCMContainer
 Self .IsStereotype st_VCMContainer
 &gt;&gt;&gt; Result
; // IsVCMContainer

BOOLEAN elem_func IsVCMMainForm
 Self .IsStereotype st_VCMMainForm
 &gt;&gt;&gt; Result
; // IsVCMMainForm

BOOLEAN elem_func IsUseCaseController
 Self .IsStereotype st_UseCaseController 
 &gt;&gt;&gt; Result
; // IsUseCaseController

BOOLEAN elem_func IsViewAreaController
 Self .IsStereotype st_ViewAreaController 
 &gt;&gt;&gt; Result
; // IsViewAreaController

BOOLEAN elem_func IsUseCaseControllerImp
 Self .IsStereotype st_UseCaseControllerImp 
 &gt;&gt;&gt; Result
; // IsUseCaseControllerImp

BOOLEAN elem_func IsViewAreaControllerImp
 Self .IsStereotype st_ViewAreaControllerImp 
 &gt;&gt;&gt; Result
; // IsViewAreaControllerImp

BOOLEAN elem_func IsSimpleClass
 Cached:
 (
  RULES
   ( Self .IsUseCaseControllerImp )
    ( Self .Abstraction at_abstract != )
   ( Self .IsViewAreaControllerImp )
    ( Self .Abstraction at_abstract != )
   ( Self .IsStereotype st_SimpleClass ) 
    true
   ( Self .IsStereotype st_ObjStub ) 
    true
   ( Self .IsService ) 
    true
   ( Self .IsServiceImplementation ) 
    true
   ( Self .IsScriptKeyword ) 
    true
   ( Self .IsTestCase ) 
    true
   ( Self .IsGuiControl ) 
    true
   ( Self .IsVCMForm ) 
    true
   ( Self .IsStereotype st_VCMFinalForm ) 
    true
   ( Self .IsVCMContainer ) 
    true
   ( Self .IsStereotype st_VCMFinalContainer ) 
    true
   DEFAULT
    false 
  ; // RULES
 )  
 &gt;&gt;&gt; Result
; // IsSimpleClass
 
BOOLEAN elem_func IsInternalInterfaces
 Self .IsStereotype st_InternalInterfaces
 &gt;&gt;&gt; Result
; // IsInternalInterfaces

BOOLEAN elem_func IsInterfaces
 Cached:
 (
  RULES
   ( Self .IsStereotype st_Interfaces ) 
    true
   ( Self .IsInternalInterfaces )
    true
   DEFAULT
    false
  ; // RULES 
 )
 &gt;&gt;&gt; Result
; // IsInterfaces

: .SecondElement
  ARRAY IN anArray
 ModelElement VAR l_Found
 nil &gt;&gt;&gt; l_Found
 INTEGER VAR l_Index
 0 &gt;&gt;&gt; l_Index
 anArray .trunc&gt; ( DROP l_Index &lt; 2 ) .for&gt; (
   IN anItem
  ( l_Index 1 == ) ? 
   ( anItem &gt;&gt;&gt; l_Found ) 
  INC l_Index 
 ) // anArray .trunc&gt; ( DROP l_Index &lt; 2 ) .for&gt;
 l_Found
; // .SecondElement

ModelElement CompileTime-VAR g_DefaultInterfaceAncestor nil

BOOLEAN elem_func IsTypedef
 Self .IsStereotype st_Typedef 
 &gt;&gt;&gt; Result
; // IsTypedef

BOOLEAN elem_func IsPointer
 Self .UPisTrue "isPointer"
 &gt;&gt;&gt; Result
; // IsPointer

ModelElement elem_func MainAncestorPrim
 Self .InheritsEx .FirstElement 
 &gt;&gt;&gt; Result
; // MainAncestorPrim

BOOLEAN elem_func IsInterface
 Cached:
 (
  RULES
   ( Self .IsStereotype st_ObjStub ) 
    false
   ( Self .IsStereotype st_Facet )
    true
   ( Self .IsStereotype st_Interface )
    true
   ( Self .Name 'object' == )
    true
   ( Self .IsTypedef )
    RULES
     ( Self .IsPointer )
      false
     DEFAULT
      ( Self .MainAncestorPrim call.me )
    ; // RULES  
   DEFAULT
    false 
  ; // RULES 
 )  
 &gt;&gt;&gt; Result
; // IsInterface

BOOLEAN elem_func IsPureMixIn
 Self .IsStereotype st_PureMixIn 
 &gt;&gt;&gt; Result
; // IsPureMixIn

BOOLEAN elem_func IsTestCaseMixIn
 Self .IsStereotype st_TestCaseMixIn
 &gt;&gt;&gt; Result
; // IsTestCaseMixIn

BOOLEAN elem_func IsMixIn
 Cached:
 (
  RULES
   ( Self .IsStereotype st_Impurity )
    true
   ( Self .IsTestCaseMixIn )
    true
   ( Self .IsVCMCustomForm )
    RULES
     ( Self .Abstraction at_abstract == )
      RULES
       ( Self .MainAncestorPrim .IsNil )
        true
       ( Self .MainAncestorPrim call.me )
        true
       DEFAULT
        false
      ; // RULES
     DEFAULT
      false
    ; // RULES
/*{   ( Self .IsUseCaseController )
    ( Self .Abstraction at_abstract == )
   ( Self .IsViewAreaController )
    ( Self .Abstraction at_abstract == )}*/
   ( Self .IsUseCaseControllerImp )
    ( Self .Abstraction at_abstract == )
   ( Self .IsViewAreaControllerImp )
    ( Self .Abstraction at_abstract == )
   DEFAULT
    false 
  ; // RULES 
 )
 &gt;&gt;&gt; Result
; // IsMixIn

ModelElement elem_func DefaultAncestor
 Cached:
 (
  RULES
   ( Self .IsMixIn )
    nil
   ( Self .IsVCMFormSetFactory )
    GarantModel::TvcmFormSetFactory
   ( Self .IsVCMFormsPack )
    GarantModel::TvcmModule 
   ( Self .IsVCMContainer )
    GarantModel::TvcmContainerForm
   ( Self .IsVCMMainForm )
    GarantModel::TvcmMainForm
   ( Self .IsVCMDataModule )
    GarantModel::TDataModule
   ( Self .IsVCMCustomForm )
    GarantModel::TvcmEntityForm
   ( Self .Abstraction at_abstract == )
    nil
   ( Self .IsViewAreaController )
    GarantModel::IvcmViewAreaController
   ( Self .IsUseCaseController )
    GarantModel::IvcmUseCaseController
   DEFAULT
    nil
  ; // RULES
 ) 
 &gt;&gt;&gt; Result
; // DefaultAncestor

ModelElement elem_func MainAncestor
 Cached:
 (
  RULES
   ( Self .IsPointer )
    ( Self .MainAncestorPrim )
   ( Self .IsTypedef )
    ( Self .MainAncestorPrim )
   ( Self .IsPureMixIn )
    ( Self .MainAncestorPrim )
   ( Self .IsInterface )
    (
     RULES
      (
       ( g_DefaultInterfaceAncestor .IsNotNil )
       AND ( g_DefaultInterfaceAncestor Self != )
       AND ( Self .MainAncestorPrim .IsNil )
      )
       g_DefaultInterfaceAncestor
      DEFAULT
       ( Self .MainAncestorPrim )
     ; // RULES 
    ) 
   DEFAULT
    ( Self .MainAncestorPrim )
  ; // RULES
   
  &gt;&gt;&gt; Result
  
  RULES
   ( Result .IsNil )
    ( Self .DefaultAncestor )
   DEFAULT
    Result 
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // MainAncestor

BOOLEAN elem_func IsRange
 Self .IsStereotype st_Range 
 &gt;&gt;&gt; Result
; // IsRange

BOOLEAN elem_func IsEnum
 Self .IsStereotype st_Enum 
 &gt;&gt;&gt; Result
; // IsEnum

BOOLEAN elem_func IsFunction
 Self .IsStereotype st_Function 
 &gt;&gt;&gt; Result
; // IsFunction

BOOLEAN elem_func IsRecord
 RULES
  ( Self .IsStereotype st_Struct )
   true
  ( Self .IsTypedef )
   RULES
    ( Self .IsPointer )
     false
    DEFAULT
     ( Self .MainAncestor call.me )
   ; // RULES  
  DEFAULT
   false 
 ; // RULES 
 &gt;&gt;&gt; Result
; // IsRecord

BOOLEAN elem_func IsDefine
 Self .IsStereotype st_Define 
 &gt;&gt;&gt; Result
; // IsDefine

BOOLEAN elem_func IsUndef
 Self .IsStereotype st_Undef 
 &gt;&gt;&gt; Result
; // IsUndef

BOOLEAN elem_func IsUnion
 Self .IsStereotype st_Union 
 &gt;&gt;&gt; Result
; // IsUnion

BOOLEAN elem_func IsRecordOrUnion
 RULES
  ( Self .IsRecord )
   true
  ( Self .IsUnion )
   true
  DEFAULT
   false
 ; // RULES
 &gt;&gt;&gt; Result
; // IsRecordOrUnion

BOOLEAN elem_func IsStaticObject
 Self .IsStereotype st_StaticObject 
 &gt;&gt;&gt; Result
; // IsStaticObject

BOOLEAN elem_func IsRecordOrUnionOrStaticObject
 RULES
  ( Self .IsRecordOrUnion )
   true
  ( Self .IsStaticObject )
   true
  DEFAULT
   false 
 ; // RULES
 &gt;&gt;&gt; Result
; // IsRecordOrUnionOrStaticObject

BOOLEAN elem_func CannotFinalizeProperty
 RULES
  ( Self .IsRecordOrUnionOrStaticObject )
   true
  ( Self .IsMixInParamType )
   true
  ( Self .IsOpenArray )
   false
  ( Self .IsArray )
   true  
  DEFAULT
   false 
 ; // RULES
 &gt;&gt;&gt; Result
; // CannotFinalizeProperty

BOOLEAN elem_func IsElementProxy
 Self .IsStereotype st_ElementProxy 
 &gt;&gt;&gt; Result
; // IsElementProxy

BOOLEAN elem_func IsSetOf
 Self .IsStereotype st_SetOf 
 &gt;&gt;&gt; Result
; // IsSetOf

BOOLEAN elem_func IsException
 Self .IsStereotype st_Exception 
 &gt;&gt;&gt; Result
; // IsException

BOOLEAN elem_func IsVCMGUI
 Self .IsStereotype st_VCMGUI 
 &gt;&gt;&gt; Result
; // IsVCMGUI

BOOLEAN elem_func IsTestTarget
 Self .IsStereotype st_TestTarget 
 &gt;&gt;&gt; Result
; // IsTestTarget

BOOLEAN elem_func IsVCMUseCaseRealization
 Self .IsStereotype st_VCMUseCaseRealization
 &gt;&gt;&gt; Result
; // IsVCMUseCaseRealization

BOOLEAN elem_func IsVCMUseCase
 Self .IsStereotype st_VCMUseCase
 &gt;&gt;&gt; Result
; // IsVCMUseCase

BOOLEAN elem_func IsVCMTestTarget
 Self .IsStereotype st_VCMTestTarget 
 &gt;&gt;&gt; Result
; // IsVCMTestTarget

BOOLEAN elem_func IsExeTarget
 Self .IsStereotype st_ExeTarget 
 &gt;&gt;&gt; Result
; // IsExeTarget

BOOLEAN elem_func IsExe
 RULES
  ( Self .IsExeTarget )
   true
  ( Self .IsTestTarget )
   true 
  ( Self .IsVCMGUI )
   true 
  DEFAULT
   false
 ; // RULES 
 &gt;&gt;&gt; Result
; // IsExe

BOOLEAN elem_func IsAdapterTarget
 Self .IsStereotype st_AdapterTarget &gt;&gt;&gt; Result
; // IsAdapterTarget

BOOLEAN elem_func IsDLL
 Self .IsAdapterTarget &gt;&gt;&gt; Result
; // IsDLL

BOOLEAN elem_func IsTarget
 Cached:
 (
  RULES
   ( Self .IsVCMGUI ) 
    true
   ( Self .IsExe ) 
    true
   ( Self .IsDLL ) 
    true
   DEFAULT
    false
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // IsTarget

BOOLEAN elem_func IsEvdSchemaElement
 Self .IsAtom
 &gt;&gt;&gt; Result
; // IsEvdSchemaElement

BOOLEAN elem_func IsClassOrMixIn
 Cached:
 (
  RULES
   ( Self .IsSimpleClass )
    true
   ( Self .IsMixIn )
    true
   DEFAULT
    false
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // IsClassOrMixIn

BOOLEAN elem_func IsTestClass
 Self .IsStereotype st_TestClass 
 &gt;&gt;&gt; Result
; // IsTestClass

BOOLEAN elem_func IsUserType
 Self .IsStereotype st_UserType 
 &gt;&gt;&gt; Result
; // IsUserType

BOOLEAN elem_func IsScriptKeywords
 Self .IsStereotype st_ScriptKeywords 
 &gt;&gt;&gt; Result
; // IsScriptKeywords

BOOLEAN elem_func IsTestResults
 Self .IsStereotype st_TestResults 
 &gt;&gt;&gt; Result
; // IsTestResults

BOOLEAN elem_func IsVCMOperationPrim
 RULES
  ( Self .IsStereotype st_VCMOperationPrim )
   true
  ( 
   ( Self .Parent .IsNotNil ) 
   AND ( Self .Parent .IsVCMOperations )
  ) 
   true
  DEFAULT
   false 
 ; // RULES
 &gt;&gt;&gt; Result
; // IsVCMOperationPrim

WordAlias .IsVCMOperation .IsVCMOperationPrim

BOOLEAN elem_func NeedOwnFilePrim
 Cached:
 (
  RULES
   ( Self .IsNil )
    false
    
   ( Self .IsScriptKeywords ) 
    false 
    
   ( Self .IsUserType ) 
    true
    
   ( Self .IsTestClass ) 
    true
    
   ( Self .IsEvdSchemaElement ) 
    true
    
   ( Self .IsTarget ) 
    true
    
   ( Self .IsTestResults ) 
    true
    
   ( Self .IsTagTable ) 
    true
    
   ( Self .IsInterfaces )
    true
   
   ( Self .IsUtilityPack )
    true
   
   ( Self .IsMixIn )
    true
   
   ( Self .IsElementProxy )
    true
    
   ( Self .IsVCMFormSetFactory )
    true
    
   ( Self .IsVCMCustomForm )
    true
   
   ( Self .IsTestLibrary )
    RULES
     ( Self .FinalFileName .IsNil )
      false
     DEFAULT
      true
    ; // RULES
    
   ( Self .IsTestUnit )
    true  
   
   ( Self .IsUnit )
    false  
   
   ( Self .IsImpl )
    false  
   
   ( Self .IsLibrary )
    false
   
   ( Self .IsSimpleClass )
   begin
    RULES
     ( Self .Visibility ProtectedAccess == )
      false
     ( Self .Visibility PrivateAccess == )
      RULES
       ( Self .IsScriptKeyword )
        RULES
         ( Self .Parent .IsVCMModule )
          true
         DEFAULT
          false
        ; // RULES
       DEFAULT
        false
      ; // RULES  
     DEFAULT
      ( 
       ModelElement VAR l_Parent
       Self .Parent &gt;&gt;&gt; l_Parent
       RULES
        ( l_Parent .IsVCMOperation )
         false
        ( 
         l_Parent .IsScriptKeywordsPack 
         AND ( Self .IsScriptKeyword )
        ) 
         true
        ( l_Parent .IsClassOrMixIn ) 
         false
        ( l_Parent .IsUtilityPack )
         false
        ( l_Parent .IsInterfaces )
         false
        DEFAULT 
         true
       ; // RULES  
      )
    ; // RULES
   end // ( Self .IsSimpleClass )
   
   DEFAULT
    false
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // NeedOwnFilePrim

elem_proc CurrentGenerator
 Self g_CurrentGenerator DO
; // CurrentGenerator

USES
 CallInherited.ms.dict
;

USES
 classRelations.ms.dict
;

BOOLEAN elem_func NeedOwnFile
 Self .? .NeedOwnFilePrim &gt;&gt;&gt; Result
; // NeedOwnFile

elem: WithDelim
  STRING IN aDelim
  TtfwWord IN aVar
  TtfwWord IN aLambda
 [ 
  if ( aVar DO ! ) then
  begin
   true aVar pop:Word:SetValue
  end
  else
  begin
   aDelim
  end
  Self 
 ] aLambda DO
; // WithDelim

elem: WithComma:
  ^ IN aVar
  ^ IN aLambda
 Self ', ' aVar aLambda .WithDelim
; // WithComma:

STRING FUNCTION .CutT
  STRING IN aName
 aName 'T' .CutPrefix &gt;&gt;&gt; Result
; // .CutT

CONST cProxy '_Proxy'

STRING elem_func UnitNamePrim
 GenCached:
 (
  STRING VAR l_Path
  Self .FinalFileName &gt;&gt;&gt; l_Path
  RULES
   ( l_Path .IsNotNil )
    ( l_Path sysutils:ExtractFileName cEmptyStr sysutils:ChangeFileExt )
   ( Self .IsNil )
     cEmptyStr
   ( Self .IsElementProxy )
    ( Self .Name cProxy Cat )
   ( Self .IsTagTable )
    ( Self .Name '_Schema' Cat )
   ( Self .IsScriptKeyword )
    ( Self .Name .CutT )
   ( Self .IsSimpleClass )
    ( Self .Name .CutT )
   DEFAULT
    ( Self .Name )
  ; // RULES
  &gt;&gt;&gt; Result
  
  if ( Self .UseNewGenExcluded ) then
  begin
   Result
   .CutFinished
   &gt;&gt;&gt; Result
   cNotCompleted Result Cat
   &gt;&gt;&gt; Result
  end // ( Self .UseNewGenExcluded )
  
  Result
 )
 &gt;&gt;&gt; Result
; // UnitNamePrim

STRING elem_func UnitName
 GenCached:
 (
  Self .UnitNamePrim .CutFinished
 )
 &gt;&gt;&gt; Result
; // UnitName

ModelElement elem_func UnitProducer
 GenCached:
 (
  RULES
   ( Self .IsNil )
    nil
   ( Self IsString )
    Self
   ( Self .NeedOwnFile )
    Self
   DEFAULT 
    ( Self .Parent call.me )
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // UnitProducer

STRING elem_func EffectiveUnitName
 GenCached:
 (
  Self .UnitProducer .UnitName
 )
 &gt;&gt;&gt; Result
; // EffectiveUnitName

ARRAY FUNCTION .filterNil&gt;
  ARRAY IN anArray
 anArray
 .filter&gt; .IsNotNil
 &gt;&gt;&gt; Result
; // .filterNil&gt;

ARRAY FUNCTION .filterMixIns&gt;
  ARRAY IN anArray
 anArray
 .filter&gt; ( .IsMixIn ! ) 
 &gt;&gt;&gt; Result
; // .filterMixIns&gt;

BOOLEAN elem_func IsMessageOperation
 Self .IsStereotype st_message::Operation 
 &gt;&gt;&gt; Result
; // IsMessageOperation

BOOLEAN elem_func IsMessage
 Self .IsStereotype st_Message 
 &gt;&gt;&gt; Result
; // IsMessage

BOOLEAN elem_func IsLocalMethod
 Self .IsStereotype st_localmethod 
 &gt;&gt;&gt; Result
; // IsLocalMethod

ModelElement elem_func KeywordOperation
 Self .SpelledFor
 &gt;&gt;&gt; Result
; // KeywordOperation

ModelElement elem_func KeywordImplementationMethod
 Self .Stub
 &gt;&gt;&gt; Result
; // KeywordImplementationMethod

ModelElement elem_func KeywordObjectToOperate
 Self .Speller
 &gt;&gt;&gt; Result
; // KeywordObjectToOperate

BOOLEAN elem_func IsKeyWord
 Self .IsStereotype st_keyword::Operation 
 &gt;&gt;&gt; Result
; // IsKeyWord

BOOLEAN elem_func IsGlobalKeyWord
 Self .IsStereotype st_globalkeyword::Operation 
 &gt;&gt;&gt; Result
; // IsGlobalKeyWord

BOOLEAN elem_func IsSomeKeyWord
 RULES
  ( Self .IsKeyWord )
   true
  ( Self .IsGlobalKeyWord )
   true
  DEFAULT
   false 
 ; // RULES
 &gt;&gt;&gt; Result
; // IsSomeKeyWord

USES
 axiom:CompiledProcedure
 axiom:KeyValues
;

USES
 KeyValuesCreateAndDo.ms.dict
;

elem: DecorateMethodAndDo:
  ^ IN aLambda
 KeyValuesCreateAndDo: ( 
   IN aMethod
  aMethod -&gt; Original := ( Self .WeakRef )
  aMethod aLambda DO
 ) // KeyValuesCreateAndDo:
; // DecorateMethodAndDo:

INTERFACE elem_func DecorateMethod:
  ^ IN aLambda
 Self .DecorateMethodAndDo: (
   IN aMethod
  aMethod pop:Word:Box &gt;&gt;&gt; Result
  aMethod aLambda DO
 ) // Self .DecorateMethodAndDo:
; // DecorateMethod:

INTERFACE FUNCTION MakeParam:
  STRING IN aName
  ModelElement IN aType
  ^ IN aLambda
 
 KeyValuesCreateAndDo: ( 
   IN l_Param
  
  l_Param pop:Word:Box &gt;&gt;&gt; Result
  
  l_Param -&gt; Name := aName
  if ( aType .IsNotNil ) then
  begin
   l_Param -&gt; Target := aType
  end // ( aType .IsNotNil )
  
  l_Param aLambda DO
 ) // KeyValuesCreateAndDo:
 
; // MakeParam:

INTERFACE FUNCTION MakeParam
  STRING IN aName
  ModelElement IN aType
 
 aName aType MakeParam: DROP
 &gt;&gt;&gt; Result
; // MakeParam

WordAlias MakeFunction MakeParam
WordAlias MakeFunction: MakeParam:

WordAlias MakeField MakeParam
WordAlias MakeField: MakeParam:

WordAlias MakeProperty MakeParam
WordAlias MakeProperty: MakeParam:

: MakeProcedure
 nil MakeFunction
; // MakeProcedure

MACRO MakeProcedure:
 'nil' Ctx:Parser:PushSymbol
 'MakeFunction:' Ctx:Parser:PushSymbol
; // MakeProcedure:

STRING elem_func SelfName
 Self .GetUP 'extprop:rc:SelfName' &gt;&gt;&gt; Result
 if ( Result .IsNil ) then
 begin
  Self .TypeName &gt;&gt;&gt; Result
 end
 else
 begin
  Result ToPrintable &gt;&gt;&gt; Result
 end // ( Result .IsNil )
; // SelfName

INTERFACE elem_func ValueParam
 Cached:
 (
  'aValue' Self MakeParam
 ) &gt;&gt;&gt; Result
; // ValueParam

BOOLEAN FUNCTION .HasSomeOf:
  ARRAY IN anArray
  ^ IN aCompareFunc
 anArray 
 .filter&gt; ( aCompareFunc DO )
 .NotEmpty
 &gt;&gt;&gt; Result
; // .HasSomeOf:

BOOLEAN elem_func HasName
  STRING IN aName
 Self .Name aName == 
 &gt;&gt;&gt; Result
; // HasName

BOOLEAN FUNCTION .HasModelElementWithName
  ARRAY IN anArray
  STRING IN aName
 anArray .HasSomeOf: ( aName .HasName )
 &gt;&gt;&gt; Result
; // .HasModelElementWithName

ModelElement elem_func OpSelfParam
 Cached:
 (
  'a' Self .SelfName Cat Self MakeParam
 )
 &gt;&gt;&gt; Result
; // OpSelfParam

ModelElement elem_func CtxParam
 Cached:
 (
  'aCtx' Self MakeParam
 )
 &gt;&gt;&gt; Result
; // CtxParam

BOOLEAN elem_func IsCreator
 Self .IsStereotype st_creator::Operation 
 &gt;&gt;&gt; Result
; // IsCreator

BOOLEAN elem_func IsVarWorker
 RULES
  ( Self .IsStereotype st_varworker::Operation )
   true
  ( Self .IsStereotype st_globalvarworker::Operation )
   true
  DEFAULT
   false 
 ; // RULES
 &gt;&gt;&gt; Result
; // IsVarWorker

BOOLEAN elem_func IsWordWorker
 RULES
  ( Self .IsStereotype st_wordworker::Operation )
   true
  ( Self .IsStereotype st_globalwordworker::Operation )
   true
  DEFAULT
   false 
 ; // RULES
 &gt;&gt;&gt; Result
; // IsWordWorker

STRING elem_func NameForScript
 Self .GetUP "NameForScript" ToPrintable
 &gt;&gt;&gt; Result
; // NameForScript

USES
 string.ms.dict
;

STRING FUNCTION RemoveDuplicatedIfDef
  STRING IN aValue
 cEmptyStr &gt;&gt;&gt; Result 
 ARRAY VAR l_Outed
 [] &gt;&gt;&gt; l_Outed
 aValue ',' string:Split:for&gt; (
   IN aSubstr
  aSubstr string:Trim &gt;&gt;&gt; aSubstr
  if ( aSubstr .IsNotNil ) 
   if ( aSubstr .TextNotInArray: l_Outed ) then
   begin
    aSubstr .AddToArray: l_Outed
    if ( Result .IsNil ) then
     ( aSubstr &gt;&gt;&gt; Result )
    else
     ( Result ',' aSubstr Cat Cat &gt;&gt;&gt; Result )
   end // ( aSubstr .TextNotInArray: l_Outed )
 ) // aValue ',' string:Split:for&gt;
; // RemoveDuplicatedIfDef

ModelElement CompileTime-VAR g_Implementor nil

FORWARD .MainAncestorThatNotMixIn

STRING elem_func IfDefStr
 Cached:
 (
  Self .GetUP "ifdef" &gt;&gt;&gt; Result
  
  VAR l_Parent
  Self .Parent &gt;&gt;&gt; l_Parent
  if ( l_Parent .IsNotNil ) then
  begin
   VAR l_ParentIfDefStr
   l_Parent call.me &gt;&gt;&gt; l_ParentIfDefStr
   if ( l_ParentIfDefStr .IsNotNil ) then
   begin
    if ( Result .IsNil ) then
    begin
     l_ParentIfDefStr &gt;&gt;&gt; Result
    end // ( Result .IsNil )
    else
    begin
     l_ParentIfDefStr ',' Result Cat Cat &gt;&gt;&gt; Result
    end // ( Result .IsNil )
   end // ( l_ParentIfDefStr .IsNotNil )
  end // ( l_Parent .IsNotNil )
  Result RemoveDuplicatedIfDef
 )
 &gt;&gt;&gt; Result 
; // IfDefStr

STRING elem_func IfNDefStr
 Cached:
 (
  Self .GetUP "ifndef" &gt;&gt;&gt; Result
  
  VAR l_Parent
  Self .Parent &gt;&gt;&gt; l_Parent
  if ( l_Parent .IsNotNil ) then
  begin
   VAR l_ParentIfDefStr
   l_Parent call.me &gt;&gt;&gt; l_ParentIfDefStr
   if ( l_ParentIfDefStr .IsNotNil ) then
   begin
    if ( Result .IsNil ) then
    begin
     l_ParentIfDefStr &gt;&gt;&gt; Result
    end // ( Result .IsNil )
    else
    begin
     l_ParentIfDefStr ',' Result Cat Cat &gt;&gt;&gt; Result
    end // ( Result .IsNil )
   end // ( l_ParentIfDefStr .IsNotNil )
  end // ( l_Parent .IsNotNil )
  Result RemoveDuplicatedIfDef
 )
 &gt;&gt;&gt; Result 
; // IfNDefStr

ARRAY FUNCTION .mapToTarget&gt;
  ARRAY IN anArray
 anArray .map&gt; .Target 
 &gt;&gt;&gt; Result
; // .mapToTarget&gt;

elem_iterator ImplementsInDependencies
 Cached:
 (
  Self .Dependencies 
  .filter&gt; .IsImplements
  .mapToTarget&gt;
  array:Copy
 ) 
 &gt;&gt;&gt; Result
; // ImplementsInDependencies

FORWARD .ChildrenEx

INTERFACE elem_func DecorateType
 Cached:
 (
  Self .DecorateMethod:
  (
    IN aMethod
   aMethod -&gt; OpKind := opkind_DecoratedType
  ) // Self .DecorateMethod:
 )
 &gt;&gt;&gt; Result
; // DecorateType

BOOLEAN FUNCTION .HasModelElement
  ARRAY IN anArray
  ModelElement IN anElement
 anArray .HasSomeOf: ( anElement .IsSameModelElement )
 &gt;&gt;&gt; Result
; // .HasModelElement

STRING elem_func ServiceFacetName
 'I' Self .Name 'T' .CutPrefix Cat
 &gt;&gt;&gt; Result
; // ServiceFacetName

STRING elem_func ServiceMixInName
 'M' Self .Name 'T' .CutPrefix Cat
 &gt;&gt;&gt; Result
; // ServiceMixInName

INTERFACE FUNCTION MakeClass:
  STRING IN aName
  ModelElement IN anAncestor
  ^ IN aLambda
 
 KeyValuesCreateAndDo: ( 
   IN aMade
  aMade pop:Word:Box &gt;&gt;&gt; Result
  
  aMade -&gt; Name := aName
  if ( anAncestor .IsNotNil ) then
  begin
   aMade -&gt; Inherits := [ anAncestor ]
  end // ( anAncestor .IsNotNil )
  
  aMade aLambda DO
 ) // KeyValuesCreateAndDo:
; // MakeClass:

INTERFACE FUNCTION MakeFacet:
  STRING IN aName
  ModelElement IN anAncestor
  ^ IN aLambda
  
 aName 
 anAncestor
 MakeClass: (
   IN aMade
  aMade -&gt; Stereotype := st_Facet
  aMade aLambda DO 
 ) // MakeClass:
 &gt;&gt;&gt; Result
; // MakeFacet:  
 
INTERFACE FUNCTION MakeClass
  STRING IN aName
  ModelElement IN anAncestor
  
 aName anAncestor MakeClass: DROP 
 &gt;&gt;&gt; Result
; // MakeClass

elem_iterator ChildrenExPrim
 Cached:
 (
  VAR l_Children
  Self .Children &gt;&gt;&gt; l_Children
  
  if ( Self .IsService ) then
  begin
   if ( l_Children
        .filter&gt; .IsInterface
        .filter&gt; ( .Name Self .ServiceFacetName == )
        .FirstElement .IsNil ) then
   begin
    VAR l_MixIn
    l_Children
    .filter&gt; .IsPureMixIn
    .filter&gt; ( .Name Self .ServiceMixInName == )
    .FirstElement &gt;&gt;&gt; l_MixIn
    
    l_Children .join&gt; ToArray: (
     Self .ServiceFacetName
     nil
     MakeFacet: (
       IN aMade
      aMade -&gt; UID := ( [ Self .LUID '_Facet' ] strings:Cat )  
      aMade -&gt; %SUM := ( [ 'Интерфейс сервиса ' Self .Name ] strings:Cat ) 
      aMade -&gt; Parent := ( Self .WeakRef )
      aMade -&gt; Visibility := PublicAccess
      aMade -&gt; Implements := [ l_MixIn ]
     ) // MakeFacet:
    ) // l_Children .join&gt; ToArray:
    &gt;&gt;&gt; l_Children
   end     
  end // ( Self .IsService )
  
  l_Children
 )
 &gt;&gt;&gt; Result
; // ChildrenExPrim
  
ModelElement elem_func FacetEx
 Cached:
 (
  RULES
   ( Self .Facet .IsNil )
    begin
     Self .ChildrenExPrim
     .filter&gt; .IsInterface
     .filter&gt; ( .Name Self .ServiceFacetName == )
     .FirstElement
    end // ( Self .Facet .IsNil )
   DEFAULT
    ( Self .Facet )
  ; // RULES 
 )
 &gt;&gt;&gt; Result
; // FacetEx

ModelElement elem_func MixInEx
 Cached:
 (
  RULES
   ( Self .MixIn .IsNil )
    begin
     Self .ChildrenExPrim
     .filter&gt; .IsPureMixIn
     .filter&gt; ( .Name Self .ServiceMixInName == )
     .FirstElement
    end // ( Self .MixIn .IsNil )
   DEFAULT
    ( Self .MixIn )
  ; // RULES 
 )
 &gt;&gt;&gt; Result
; // MixInEx

elem_iterator ImplementsEx
 Cached:
 (
  VAR l_Implements
  Self .Implements &gt;&gt;&gt; l_Implements
  
  if ( Self .IsServiceImplementation ) then
  begin
   Self .ImplementsInDependencies
   .for&gt; (
     IN aService
    VAR l_Facet 
    aService .FacetEx &gt;&gt;&gt; l_Facet
    if ( l_Facet .NotIsNil ) then
    begin
     if ( l_Implements l_Facet .HasModelElement ! ) then
     begin
      l_Implements .join&gt; ( 
       l_Facet .DecorateType .ToArray
      ) // l_Implements .join&gt;
      &gt;&gt;&gt; l_Implements
     end // ( l_Implements l_Facet .HasModelElement ! )
    end // ( l_Facet .NotIsNil )
   ) // .for&gt;
  end // ( Self .IsServiceImplementation )
  
  if ( Self .IsService ) then
  begin
   VAR l_MixIn 
   Self .MixInEx &gt;&gt;&gt; l_MixIn
   if ( l_MixIn .NotIsNil ) then
   begin
    if ( l_Implements l_MixIn .HasModelElement ! ) then
    begin
     l_Implements .join&gt; ( 
      l_MixIn .DecorateType .ToArray
     ) // l_Implements .join&gt;
     &gt;&gt;&gt; l_Implements
    end // ( l_Implements l_MixIn .HasModelElement ! )
   end // ( l_MixIn .NotIsNil )
  end // ( Self .IsService )
  
  if ( Self .IsInterface ) then
  begin
   if ( Self .Parent .IsService ) then
   begin
    if ( Self .Name Self .Parent .ServiceFacetName == ) then
    begin
     VAR l_MixIn 
     Self .Parent .MixInEx &gt;&gt;&gt; l_MixIn
     if ( l_MixIn .NotIsNil ) then
     begin
      if ( l_Implements l_MixIn .HasModelElement ! ) then
      begin
       l_Implements .join&gt; ( 
        l_MixIn .DecorateType .ToArray
       ) // l_Implements .join&gt;
       &gt;&gt;&gt; l_Implements
      end // ( l_Implements l_MixIn .HasModelElement ! )
     end // ( l_MixIn .NotIsNil )
    end // ( Self .Name Self .Parent .ServiceFacetName == )
   end // ( Self .Parent .IsService )
  end // ( Self .IsInterface )
  
  l_Implements
 )
 &gt;&gt;&gt; Result
; // ImplementsEx

elem_iterator OwnControls
 Cached:
 (
  VAR l_Controls
  [] &gt;&gt;&gt; l_Controls
  
  elem_proc CollectOwnControlsPrim
   Self .Attributes
   .filter&gt; .IsControlPrim
   .filter&gt; .AddToArray?: l_Controls
   .for&gt; ( 
     IN aControl
    aControl call.me
   ) // .for&gt;
  ; // CollectOwnControlsPrim
  
  Self .CollectOwnControlsPrim
  
  l_Controls
 )
 &gt;&gt;&gt; Result
; // OwnControls

FORWARD .MethodType

ModelElement elem_func AttrType
 RULES
  //( Self .IsOverride )
  // ( Self .MainAncestor call.me )
  //( Self .IsStereotype st_VCMController )
  DEFAULT
   ( Self .MethodType )
 ; // RULES  
 &gt;&gt;&gt; Result
; // AttrType

elem_iterator AllControls
 Cached:
 (
  VAR l_Controls
  [] &gt;&gt;&gt; l_Controls
  
  elem_proc CollectControlsPrim
   Self .Attributes
   .filter&gt; .IsControlPrim
   .filter&gt; .AddToArray?: l_Controls
   .for&gt; ( 
     IN aControl
    aControl call.me
   ) // .for&gt;
  ; // CollectControlsPrim
  
  elem_proc DoCollectControls
   Self .CollectControlsPrim
   Self .InheritsEx .for&gt; call.me
   Self .ImplementsEx .for&gt; call.me
  ; // DoCollectControls
  
  Self .DoCollectControls
  
  l_Controls
 )
 &gt;&gt;&gt; Result
; // AllControls

elem_iterator ScriptKeywordsPackProperties
 Cached:
 (
  VAR l_Properties
  Self .Attributes
  .filter&gt; ( .IsStereotype st_property::Attribute )
  &gt;&gt;&gt; l_Properties
  
  l_Properties
  
  Self .InheritsEx
  .filter&gt; .IsVCMCustomForm
  .filter&gt; ( .Abstraction at_final == )
  .for&gt; (
    IN aForm
   aForm .AllControls
   .filter&gt; ( .IsControlOverride ! )
   .filter&gt; ( .Visibility PublicAccess == )
   .filter&gt; ( .AttrType .NotIsNil )
   .for&gt; (
     IN aControl
    VAR l_Name
    aControl .Name &gt;&gt;&gt; l_Name
    if ( l_Properties l_Name .HasModelElementWithName ! ) then
    begin
     .join&gt; ToArray: (
      l_Name 
      aControl .AttrType
      MakeProperty: (
        IN aMade
       aMade -&gt; UID := ( [ aForm .LUID '_' aControl .LUID '_Control' ] strings:Cat ) 
       aMade -&gt; Parent := ( Self .WeakRef )
       aMade -&gt; %SUM := (  [ 'Контрол ' l_Name ' формы ' aForm .TypeName ] strings:Cat )
       aMade -&gt; "NameForScript" := ( [ '.' aForm .TypeName '.' l_Name ] strings:Cat )
       aMade -&gt; Stereotype := st_readonly::Attribute
       aMade -&gt; "mapped" := true
       aMade -&gt; "ifdef" := ( aControl .GetUP "ifdef" )
       aMade -&gt; "ifndef" := ( aControl .GetUP "ifndef" )
      ) // MakeProperty:
     ) // .join&gt; ToArray: 
    end // ( l_Properties l_Name .HasModelElementWithName ! )
   ) // .for&gt;
  ) // .for&gt;
  
 )
 &gt;&gt;&gt; Result
; // ScriptKeywordsPackProperties

BOOLEAN elem_func IsUses
 RULES
  ( Self .IsStereotype st_uses::Dependency )
   true
  ( Self .IsStereotype st_ContextMenuWeight::Dependency )
   true
  DEFAULT
   false
 ; // RULES   
 &gt;&gt;&gt; Result
; // IsUses

elem_iterator UsesInDependencies
 Cached:
 (
  Self .Dependencies 
  .filter&gt; .IsUses 
  .mapToTarget&gt;
  array:Copy
 ) 
 &gt;&gt;&gt; Result
; // UsesInDependencies

elem: IterateVCMFormsPacksFromApplication
  IN aLambda
 RULES
  ( Self .IsVCMFormsPack )
   begin
    Self aLambda DO
    Self .InheritsEx .for&gt; ( aLambda call.me )
   end // ( Self .IsVCMFormsPack )
  ( Self .IsVCMApplication )
   begin
    Self .Children .for&gt; ( aLambda call.me )
    Self .UsesInDependencies .for&gt; ( aLambda call.me )
   end // ( Self .IsVCMApplication )
 ; // RULES
; // IterateVCMFormsPacksFromApplication

elem: OutRecall
  IN aLambda
 RULES
  ( Self .IsVCMFormsPack )
   begin
    Self .Operations .for&gt; ( aLambda call.me )
    Self .InheritsEx .for&gt; ( aLambda call.me )
    Self .ImplementsEx .for&gt; ( aLambda call.me )
   end // ( Self .IsVCMFormsPack )
  (
   ( Self .IsFormSetFactory )
   AND ( Self .Visibility PublicAccess == )
  ) 
   begin
    Self aLambda DO
   end // ( Self .IsModuleOperationPrim )
  ( Self .IsVCMApplication )
   begin
    Self .Children .for&gt; ( aLambda call.me )
    Self .UsesInDependencies .for&gt; ( aLambda call.me )
   end // ( Self .IsVCMApplication )
 ; // RULES
; // OutRecall

CONST cNeedsToBeImplemented ' !!! Needs to be implemented !!!'
CONST cImplementationUserCodeSuffix '_impl'
CONST cVarUserCodeSuffix '_var'
CONST cEmptyUserCode #1

CONST cUserCodePrefix 'uc:'

STRING FUNCTION cImplementationUserCodeName
 cUserCodePrefix cImplementationUserCodeSuffix Cat &gt;&gt;&gt; Result
; // cImplementationUserCodeName

STRING FUNCTION cVarUserCodeName
 cUserCodePrefix cVarUserCodeSuffix Cat &gt;&gt;&gt; Result
; // cVarUserCodeName

STRING FUNCTION cSetterImplementationUserCodeName
 [ cUserCodePrefix 'set' cImplementationUserCodeSuffix ] strings:Cat &gt;&gt;&gt; Result
; // cSetterImplementationUserCodeName

STRING FUNCTION cSetterVarUserCodeName
 [ cUserCodePrefix 'set' cVarUserCodeSuffix ] strings:Cat &gt;&gt;&gt; Result
; // cSetterVarUserCodeName

STRING FUNCTION cGetterImplementationUserCodeName
 [ cUserCodePrefix 'get' cImplementationUserCodeSuffix ] strings:Cat &gt;&gt;&gt; Result
; // cGetterImplementationUserCodeName

STRING FUNCTION cGetterVarUserCodeName
 [ cUserCodePrefix 'get' cVarUserCodeSuffix ] strings:Cat &gt;&gt;&gt; Result
; // cGetterVarUserCodeName

FORWARD .Properties
FORWARD .MethodParameters

ARRAY FUNCTION .With()&gt;
  OUTABLE IN aValue
  ^ IN aLambda
 RULES 
  ( aValue .IsNil )
   [empty]
  ( aValue IsArray )
   (
    [
     VAR l_WasBracket
     false &gt;&gt;&gt; l_WasBracket
     aValue 
     .filterNil&gt; 
     .for&gt; (
       IN anItem
      if ( l_WasBracket ! ) then
      begin
       '('
       true &gt;&gt;&gt; l_WasBracket
      end
      anItem aLambda DO
     ) // aValue .for&gt;
     if l_WasBracket then
     begin
      ')'
     end 
    ]
   ) // ( aValue IsArray )
  DEFAULT 
   [ '(' aValue aLambda DO ')' ]
 ; // RULES
 &gt;&gt;&gt; Result
; // .With()

ARRAY FUNCTION .With()
  OUTABLE IN aValue
 aValue .With()&gt; .KeepInStack &gt;&gt;&gt; Result 
; // .With()

ARRAY FUNCTION .CommaList
  ARRAY IN aList
 [
  VAR l_WasComma
  false &gt;&gt;&gt; l_WasComma
  aList .for&gt; ( 
   .WithComma: l_WasComma .KeepInStack
  )
 ]
 &gt;&gt;&gt; Result
; // .CommaList
  
ARRAY FUNCTION .CommaListWith()
  ARRAY IN aList
 aList .CommaList .With() 
 &gt;&gt;&gt; Result
; // .CommaListWith()
  
ARRAY elem_func ParametersList
 Cached:
 (
  Self .MethodParameters .map&gt; .Name .CommaListWith()
 )
 &gt;&gt;&gt; Result
; // ParametersList

elem_iterator OperationsEx
 Cached:
 (
  VAR l_Operations
  Self .Operations &gt;&gt;&gt; l_Operations
  l_Operations
  
  RULES
   ( Self .IsScriptKeyword )
    begin
     VAR l_Op
     Self .KeywordOperation &gt;&gt;&gt; l_Op
     if (
         ( l_Op .IsNotNil ) 
         AND ( l_Op .IsSomeKeyWord )
        ) then
     begin
      if ( 
          ( l_Op .GetUP 'extprop:prop_stereo' .IsValueValid )
          OR ( l_Op .UPisTrue "lvalue" )
         ) then
      begin
       if (
           ( l_Op .UPisTrue "mapped" ! )
           AND ( l_Op .GetUP 'extprop:prop_stereo' 'readonly' ?!= )
          ) then
       begin
        if ( l_Operations 'DoSetValue' .HasModelElementWithName ! ) then
        begin
         .join&gt; ToArray: (
          'DoSetValue' MakeProcedure: (
            IN aMade
           VAR l_Self
           Self .KeywordObjectToOperate &gt;&gt;&gt; l_Self
           aMade -&gt; UID := ( Self .LUID '_DoSetValue' Cat ) 
           aMade -&gt; %SUM := ( 'Метод установки значения свойства ' l_Op .Name Cat )
           aMade -&gt; Stereotype := st_static::Operation
           aMade -&gt; Visibility := ProtectedAccess
           aMade -&gt; Abstraction := at_final
           aMade -&gt; Parameters := ( 
            ToArray: ( l_Self .OpSelfParam )
            .join&gt; ( l_Op .Parameters )
            .join&gt; ToArray: ( l_Op .Target .ValueParam )
           ) // aMade -&gt; Parameters
          ) // MakeProcedure:
         ) // .join&gt; ToArray:
        end // ( l_Operations 'DoSetValue' .HasModelElementWithName ! )
       end // ( l_Op .UPisTrue "mapped" ! )
      end // ( l_Op .GetUP 'extprop:prop_stereo' .IsValueValid )
      
      VAR l_Self
      Self .KeywordObjectToOperate &gt;&gt;&gt; l_Self
      if (
          ( l_Op .UPisTrue "mapped" )
          OR ( l_Self .NotIsNil )
          OR ( l_Op .Parameters .NotEmpty )
          OR ( l_Op .Target .NotIsNil )
          OR ( l_Op .IsVarWorker )
         ) then
      begin
       VAR l_Name
       l_Op .Name &gt;&gt;&gt; l_Name
       if ( l_Operations l_Name .HasModelElementWithName ! ) then
       begin
        .join&gt; ToArray: (
         l_Name 
         if ( l_Op .IsCreator ) then
         begin
          l_Self
         end // ( l_Op .IsCreator )
         else
         begin
          l_Op .Target
         end // ( l_Op .IsCreator )
         MakeFunction: (
           IN aMade
          aMade -&gt; UID := ( l_Op .LUID ) 
          // - пусть лучше мапируется на порождащую операцию, чтобы при переносе класса - не переделывать
          aMade -&gt; %SUM := ( 'Реализация слова скрипта ' Self .NameForScript Cat )
          aMade -&gt; Visibility := PrivateAccess
          aMade -&gt; Abstraction := at_final
          aMade -&gt; IsSummoned := true
          // - это можно убрать, если перенести сюда вот что:
/*{
   (
    ( Self .OpKind opkind_Normal == ) // - метод новый, а не перекрытый
    AND ( l_Op .IsNotNil )
    AND ( l_Self .IsNotNil )
    AND ( l_Implementor .IsSummoned )
    AND ( l_Op .UPisTrue "mapped" )
   )
     Code:
       ( 
        [ 
         ' '
         if ( Self .Target .IsNotNil ) then
         begin
          'Result := ' 
         end
         'a' l_Self .SelfName cDot l_Op .Name l_Op .ParametersList ';' 
        ] .Out 
       )
    
}*/          
          aMade -&gt; SpelledFor := ( l_Op .WeakRef )
          aMade -&gt; Parameters := (
           ToArray: ( GarantModel::TtfwContext .CtxParam )
           if ( l_Op .IsVarWorker ) then
           begin
            .join&gt; [ 
             if ( l_Op .IsWordWorker ) then
              'aWord'
             else
              'aVar' 
             GarantModel::TtfwWord MakeParam 
            ] // .join&gt;
           end // ( l_Op .IsVarWorker )
           if ( l_Op .IsCreator ! ) then
           begin
            if ( l_Self .NotIsNil ) then
            begin
             .join&gt; ToArray: ( l_Self .OpSelfParam )
            end // ( l_Self .NotIsNil )
           end // ( l_Op .IsCreator ! )
           .join&gt; ( l_Op .Parameters )
          ) // aMade -&gt; Parameters
          VAR l_Ref
          Self .WeakRef &gt;&gt;&gt; l_Ref
          l_Ref -&gt; Stub := ( aMade .WeakRef )
          // - обратная ссылка для l_Call
          // %{Class_Inst}%f_set_var(Stub,{Op_Instance})\
         ) // MakeFunction:
        ) // .join&gt; ToArray:
       end // ( l_Operations l_Name .HasModelElementWithName ! )
      end // ( l_Op .UPisTrue "mapped" )
      
     end // ( l_Op .IsNotNil )
    end // ( Self .IsScriptKeyword )
   ( Self .IsScriptKeywordsPack ) 
    begin
     Self .ScriptKeywordsPackProperties
     .for&gt; (
       IN aProp
      VAR l_Name
      aProp .Name &gt;&gt;&gt; l_Name
      if ( l_Operations l_Name .HasModelElementWithName ! ) then
      begin
       .join&gt; ToArray: (
        l_Name 
        aProp .Target
        MakeFunction: (
          IN aMade
         aMade -&gt; UID := ( aProp .LUID ) 
         aMade -&gt; Parent := ( aProp .Parent .WeakRef ) 
         aMade -&gt; Stereotype := st_keyword::Operation
         aMade -&gt; %SUM := ( aProp .Documentation )
         aMade -&gt; "NameForScript" := ( aProp .GetUP "NameForScript" )
         if ( aProp .IsStereotype st_readonly::Attribute ) then
         begin
          aMade -&gt; 'extprop:prop_stereo' := 'readonly'
         end // ( aProp .IsStereotype st_readonly::Attribute )
         else
         begin
          aMade -&gt; 'extprop:prop_stereo' := 'property'
         end // ( aProp .IsStereotype st_readonly::Attribute )
         aMade -&gt; 'extprop:prop_name' := l_Name
         aMade -&gt; "mapped" := ( aProp .GetUP "mapped" )
         aMade -&gt; "is immediate" := ( aProp .GetUP "is immediate" )
         aMade -&gt; "ifdef" := ( aProp .GetUP "ifdef" )
         aMade -&gt; "ifndef" := ( aProp .GetUP "ifndef" )
        ) // MakeFunction:
       ) // .join&gt; ToArray:
      end // ( l_Operations l_Name .HasModelElementWithName ! )
     ) // .for&gt;
    end // ( Self .IsScriptKeywordsPack )
  ; // RULES
  
  Self .Properties
  .filter&gt; ( .UPisTrue "needs stored directive" )
  .for&gt; (
    IN aProp
   VAR l_Name 
   aProp .Name 'Stored' Cat &gt;&gt;&gt; l_Name
   if ( l_Operations l_Name .HasModelElementWithName ! ) then
   begin
    .join&gt; ToArray: (
     l_Name 
     GarantModel::Boolean
     MakeFunction: (
       IN aMade
      aMade -&gt; UID := ( aProp .LUID 'Stored' Cat ) 
      aMade -&gt; %SUM := ( [ 'Функция определяющая, что свойство ' aProp .Name ' сохраняется' ] strings:Cat )
      //aMade -&gt; Stereotype := st_static::Operation
      aMade -&gt; Visibility := ProtectedAccess
      aMade -&gt; Abstraction := at_final
     ) // MakeProcedure:
    ) // .join&gt; ToArray:
   end // ( l_Operations l_Name .HasModelElementWithName ! )
  ) // .for&gt;
  
  if ( Self .IsUseCaseControllerImp ) then
  begin
   Self .ImplementsEx
   .filter&gt; .IsUseCaseController
   .for&gt; (
     IN aController
    aController .Parent .ChildrenEx
    .filter&gt; ( .UPisTrue 'extprop:isSynchroEnum' )
    .filter&gt; ( .GetUP 'extprop:SDS_CASTER' aController .LUID ?== )
    .for&gt; (
      IN aEnum
     if ( l_Operations 'ChangeSynchroForm' .HasModelElementWithName ! ) then
     begin
      .join&gt; ToArray: (
       'ChangeSynchroForm' MakeProcedure: (
         IN aMade
        aMade -&gt; UID := ( [ Self .LUID '_' aEnum .LUID '_' 'ChangeSynchroForm' ] strings:Cat ) 
        aMade -&gt; %SUM := 'Переключает форму синхронного просмотра'
        //aMade -&gt; Stereotype := st_static::Operation
        aMade -&gt; Visibility := ProtectedAccess
        aMade -&gt; Abstraction := at_final
        aMade -&gt; Parameters := [
         'aSynchroForm' aEnum MakeParam
         'aDoSaveToHistory' GarantModel::Boolean MakeParam: (
           IN aMade
          aMade -&gt; 'extprop:pas:Value' := true 
         ) // 'aDoSaveToHistory' GarantModel::Boolean MakeParam:
         'aNeedRefresh' GarantModel::Boolean MakeParam: (
           IN aMade
          aMade -&gt; 'extprop:pas:Value' := true 
         ) // 'aNeedRefresh' GarantModel::Boolean MakeParam:
        ] // aMade -&gt; Parameters
       ) // 'ChangeSynchroForm' MakeProcedure:
      ) // .join&gt; ToArray:
     end // ( l_Operations 'ChangeSynchroForm' .HasModelElementWithName ! )
    ) // .for&gt;
   ) // .for&gt;
  end // ( Self .IsUseCaseControllerImp )

  if ( Self .IsVCMApplication ) then
  begin
   &gt;&gt;&gt; l_Operations
   Self .Children
   .join&gt; ( Self .UsesInDependencies )
   .filter&gt; .IsVCMFormsPack
   .filter&gt; ( .Abstraction at_final == )
   .for&gt; (
     IN aModule
    VAR l_ModuleName
    aModule .Name &gt;&gt;&gt; l_ModuleName

    elem_proc DoModule
     Self .Operations
     .filter&gt; .IsModuleOperationPrim
     .for&gt; (
       IN anOp
      VAR l_Name
      VAR l_Type
      [ 'mod_opcode_' l_ModuleName '_' anOp .Name ] strings:Cat &gt;&gt;&gt; l_Name
      GarantModel::TvcmMOPID &gt;&gt;&gt; l_Type
      if ( l_Operations l_Name .HasModelElementWithName ! ) then
      begin
       l_Operations
       .join&gt; ToArray: (
        l_Name
        l_Type
        MakeFunction: (
          IN aMade
         aMade -&gt; Visibility := PublicAccess
         aMade -&gt; Stereotype := st_static::Operation
         aMade -&gt;^ cVarUserCodeName ^:= cEmptyUserCode
         aMade .AddMethodWithParams: cImplementationUserCodeName ( anOp l_ModuleName ) (
           IN anOp
           IN aModuleName
          VAR l_Name
          [ 'g_module_opcode_' aModuleName '_' anOp .Name ] strings:Cat &gt;&gt;&gt; l_Name
          [
           ' Result := ' l_Name ';' \n
           ' Assert((Result.rMoID &gt; 0) AND (Result.rOpID &gt; 0));'
          ]
         ) // aMade .AddMethodWithParams: cImplementationUserCodeName anOp

        ) // MakeFunction:
       ) //.join&gt; ToArray:
       array:Copy
       &gt;&gt;&gt; l_Operations
      end // ( l_Operations l_Name .HasModelElementWithName ! )
     ) // .for&gt;
     Self .InheritsEx .for&gt; call.me
    ; // DoModule

    aModule .DoModule
   ) // .for&gt;

   Self @ (
     IN anOp
    VAR l_Name
    anOp .Name &gt;&gt;&gt; l_Name
    //if ( l_Operations l_Name .HasModelElementWithName ! ) then
    begin
     l_Operations
     .join&gt; ToArray: (
      anOp
      .DecorateMethod: (
        IN aMade
       aMade -&gt; Visibility := PublicAccess
       aMade -&gt; Attributes := [empty]
       aMade -&gt; Operations := ( anOp .Operations .filter&gt; ( .IsLocalMethod ! ) )
       aMade -&gt; Dependencies := [empty]
       aMade -&gt; "NO_FACTORY_BRACKECTS" := true
       aMade -&gt;^ cVarUserCodeName ^:= cEmptyUserCode
       aMade .AddMethodWithParams: cImplementationUserCodeName anOp (
         IN anOp
        [
         ' '
         if ( anOp .MethodType .NotIsNil ) then
         begin
          'Result := '
         end // ( anOp .MethodType .NotIsNil )
         anOp .Parent .TypeName '.' anOp .Name anOp .ParametersList ';'
        ] 
       ) // aMade .AddMethodWithParams: cImplementationUserCodeName anOp

      ) // .DecorateMethod:
     ) //.join&gt; ToArray:
     array:Copy
     &gt;&gt;&gt; l_Operations
    end // ( l_Operations l_Name .HasModelElementWithName ! )
   ) .OutRecall
   l_Operations
  end // ( Self .IsVCMApplication )

  if ( Self .IsPureMixIn ) then
  begin
   &gt;&gt;&gt; l_Operations
   l_Operations
  end // ( Self .IsPureMixIn )
 )
 &gt;&gt;&gt; Result
; // OperationsEx

ModelElement elem_func FirstOperation
 Cached:
 (
  Self .OperationsEx
  .filter&gt; ( .IsLocalMethod ! )
  .FirstElement
 )
 &gt;&gt;&gt; Result
; // FirstOperation

BOOLEAN elem_func IsFacetIterator
 Self .IsStereotype st_facetiterator 
 &gt;&gt;&gt; Result
; // IsFacetIterator

BOOLEAN elem_func IsMixInMirror
 Self .IsStereotype st_MixInMirror
 &gt;&gt;&gt; Result
; // IsMixInMirror

BOOLEAN elem_func IsClassImplementable
 Cached:
 (
  RULES
   ( Self .IsPureMixIn )
    false
   ( Self .IsMixIn )
    false
   ( Self .IsSimpleClass )
    false
   ( Self .IsEvdSchemaElement )
    false 
   ( Self .IsMixInMirror )
    false 
   ( Self .IsStereotype st_UseCase )
    false 
   ( Self .IsVCMOperations )
    false 
   ( Self .IsInterface )
    true
   ( Self .IsTypedef )
    RULES
     ( Self .IsPointer )
      false
     DEFAULT
      ( Self .MainAncestor call.me )
    ; // RULES  
   DEFAULT
    true
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // IsClassImplementable

ARRAY FUNCTION array:CopyWithoutDuplicates
  IN anArray
 RULES
  ( anArray .IsNil )
   [nil]
  DEFAULT 
   (
    VAR l_Copy
    [] &gt;&gt;&gt; l_Copy
    VAR l_Empty
    true &gt;&gt;&gt; l_Empty
    anArray 
    .filter&gt; .AddToArray?: l_Copy
    .for&gt; ( 
      IN anElement
     false &gt;&gt;&gt; l_Empty
    ) // anArray .for&gt;
    RULES
     l_Empty
      [nil]
     DEFAULT
      l_Copy 
    ; // RULES
   ) 
 ; // RULES 
 &gt;&gt;&gt; Result
; // array:CopyWithoutDuplicates

elem_iterator ForClassImplements
 Cached:
 (
  Self .ImplementsEx
  .filter&gt; .IsClassImplementable
 ) 
 &gt;&gt;&gt; Result
; // ForClassImplements

elem_iterator ClassImplementsPrim
 Self .ForClassImplements 
 &gt;&gt;&gt; Result
; // ClassImplementsPrim

BOOLEAN elem_func InTie
 Cached:
 (
  RULES
   ( Self .IsNil )
    false
   ( Self .GetUP "gui" 'tie' ?== )
    true
   ( Self .Parent call.me )
    true 
   DEFAULT
    false
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // InTie

elem_iterator InterfaceForClassImplements
 Cached:
 (
  Self .ForClassImplements 
  .filter&gt; ( .InTie ! )
 ) 
 &gt;&gt;&gt; Result
; // InterfaceForClassImplements

ARRAY FUNCTION .joinWithLambded&gt;
  ARRAY IN anArrayToJoin
  ^ IN anArrayToIterate
  ^ IN aLambda
  
 anArrayToJoin 
 anArrayToIterate DO .for&gt; ( 
  IN aChild 
  VAR l_Other
  ( aChild aLambda DO ) &gt;&gt;&gt; l_Other
  if ( l_Other .IsNotNil ) then
  begin
   .join&gt; l_Other
  end // ( l_Other .IsNotNil )
 )
 &gt;&gt;&gt; Result
; // .joinWithLambded&gt;

BOOLEAN elem_func IsMixInOrMixInMirror
 RULES
  ( Self .IsMixIn )
   true
  ( Self .IsMixInMirror )
   true
  DEFAULT
   false
 ; // RULES   
 &gt;&gt;&gt; Result
; // IsMixInOrMixInMirror

BOOLEAN elem_func SomeAncestorImplements
  ModelElement IN anIntf
  
 BOOLEAN elem_func ImplementsLoc
  Self .ImplementsEx
  .filter&gt; ( anIntf .IsSameType ) 
  .NotEmpty &gt;&gt;&gt; Result
 ; // ImplementsLoc
 
 anIntf :Cached:
 (
  RULES
   ( Self .IsTypedef )
     RULES
      ( Self .IsPointer )
       false
      DEFAULT
       ( Self .MainAncestorPrim anIntf call.me )
     ; // RULES
   ( Self .InheritsEx .filter&gt; ( anIntf .IsSameType ) .NotEmpty )
    true 
   ( Self .InheritsEx .filter&gt; .ImplementsLoc .NotEmpty )
    true 
   ( Self .InheritsEx .filter&gt; ( anIntf call.me ) .NotEmpty )
    true 
   ( Self .ImplementsEx .filter&gt; .IsMixInOrMixInMirror .filter&gt; .ImplementsLoc .NotEmpty )
    true 
   ( Self .ImplementsEx .filter&gt; .IsMixInOrMixInMirror .filter&gt; ( anIntf call.me ) .NotEmpty )
    true 
   DEFAULT
    false  
  ; // RULES 
 )
 &gt;&gt;&gt; Result 
; // SomeAncestorImplements

elem_iterator ClassImplements
 Cached:
 (
  (
   Self .ClassImplementsPrim
   .joinWithLambded&gt; ( Self .ClassImplementsPrim ) .InterfaceForClassImplements
  ) 
  .filter&gt; ( Self SWAP .SomeAncestorImplements ! )
  array:CopyWithoutDuplicates
 ) 
 &gt;&gt;&gt; Result
; // ClassImplements

INTERFACE elem_func OverrideMethod:
  ^ IN aLambda
 Self .DecorateMethod:
 (
   IN aMethod
  aMethod -&gt; OpKind := opkind_Overridden
  aMethod aLambda DO
 ) // Self .DecorateMethod:
 &gt;&gt;&gt; Result
; // OverrideMethod:

INTERFACE elem_func OverrideMethod
 Cached:
 (
  Self .OverrideMethod: DROP
 )
 &gt;&gt;&gt; Result
; // OverrideMethod

INTERFACE elem_func ImplementMethod:
  ^ IN aLambda
 Self .DecorateMethod:
 (
   IN aMethod
  aMethod -&gt; OpKind := opkind_Implemented
  aMethod aLambda DO
 ) // Self .DecorateMethod:
 &gt;&gt;&gt; Result
; // ImplementMethod:

INTERFACE elem_func ImplementMethod
 Cached:
 (
  Self .ImplementMethod: DROP
 )
 &gt;&gt;&gt; Result
; // ImplementMethod

INTERFACE FUNCTION MakeInOutParam
  STRING IN aName
  ModelElement IN aType
 aName aType MakeParam: ( 
   IN aMade
  aMade -&gt; Stereotype := st_inout
 ) 
 &gt;&gt;&gt; Result
; // MakeInOutParam

INTERFACE elem_func CastMethod
 Cached:
 (
  VAR l_TypeName
  Self .TypeName &gt;&gt;&gt; l_TypeName
  'As_' l_TypeName Cat Self MakeFunction: ( 
    IN aMade
   aMade -&gt; %SUM := ( 'Метод приведения нашего интерфейса к ' l_TypeName Cat )
   aMade -&gt; Visibility := ProtectedAccess
   aMade -&gt;^ cVarUserCodeName ^:= cEmptyUserCode
   aMade -&gt;^ cImplementationUserCodeName ^:= ' Result := Self;'
  ) 
 )
 &gt;&gt;&gt; Result
; // CastMethod

BOOLEAN elem_func IsStaticOp
 Self .IsStereotype st_static::Operation
 &gt;&gt;&gt; Result
; // IsStaticOp

BOOLEAN elem_func IsStaticMethod
 RULES
  ( Self .IsModuleOperationPrim )
   false
  (
   ( Self .IsMethod )
   AND ( Self .GetUP "is static" false ?!= )
   AND ( Self .Parent .IsVCMFormsPack )
  )
   true
  ( Self .IsFormSetFactory )
   true
  ( Self .IsStaticOp )
   true
  ( Self .UPisTrue "is static" ) 
   true
  DEFAULT
   false 
 ; // RULES 
 &gt;&gt;&gt; Result
; // IsStaticMethod

elem_iterator InterfaceOwnOperations
 Self .OperationsEx
 .filter&gt; ( .IsStaticMethod ! )
 .joinWithLambded&gt; ( Self .InterfaceForClassImplements ) .ToArray: .CastMethod
 &gt;&gt;&gt; Result
; // InterfaceOwnOperations

elem_iterator InterfaceOperationsTotal
 Cached:
 (
  Self .InterfaceOwnOperations
  .joinWithLambded&gt; ( Self .ImplementsEx .filter&gt; .IsPureMixIn ) (
    IN anItem
   anItem call.me
   .joinWithLambded&gt; ( anItem .InheritsEx .filter&gt; .IsPureMixIn ) .InterfaceOwnOperations
  ) 
 ) 
 &gt;&gt;&gt; Result
; // InterfaceOperationsTotal

ModelElement elem_func MainImplements
 Cached:
 (
  Self .ImplementsEx
  .FirstElement
 )
 &gt;&gt;&gt; Result
; // MainImplements

BOOLEAN elem_func ImplementsIterator
 Cached:
 (
  RULES
   ( Self .MainImplements .IsNil )
    false
   ( Self .MainImplements .IsIterator )
    true 
   DEFAULT
    false
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // ImplementsIterator

BOOLEAN elem_func IsMethodAndImplementsIterator
 RULES
  ( Self .IsMethod ! )
   false
  ( Self .ImplementsIterator )
   true 
  DEFAULT
   false
 ; // RULES
 &gt;&gt;&gt; Result
; // IsMethodAndImplementsIterator

BOOLEAN elem_func SomeMethodImplementsThisIterator
  ModelElement IN anIterator
 RULES
  (
   Self .OperationsEx
   .filter&gt; .IsMethodAndImplementsIterator
   .map&gt; .MainImplements
   .filter&gt; ( anIterator .IsSameModelElement )
   .NotEmpty
  )
   true
  DEFAULT
   false
 ; // RULES
 &gt;&gt;&gt; Result 
; // SomeMethodImplementsThisIterator

elem_iterator InterfaceOperationsTotalDeep
 Self .InterfaceOperationsTotal
 
 .joinWithLambded&gt; ( 
  Self .InheritsEx 
  .filter&gt; (
    IN anAncestor
   RULES
    ( anAncestor .IsPureMixIn )
     true
    DEFAULT
     ( anAncestor .IsClassImplementable )
   ; // RULES 
  ) // .filter&gt;
 ) call.me
 
 &gt;&gt;&gt; Result
; // InterfaceOperationsTotalDeep

elem_iterator ImplementedEx
 Cached:
 (
  Self .Implemented
  
  if ( Self .IsClassOrMixIn ) then
  begin
   VAR l_OutedIterators
   [] &gt;&gt;&gt; l_OutedIterators
   
   .joinWithLambded&gt; ( Self .ClassImplements ) ( 
    .InterfaceOperationsTotalDeep 
    .filter&gt; ( .IsFacetIterator ! )
    .filter&gt; .IsIterator
    .filter&gt; ( Self SWAP .SomeMethodImplementsThisIterator ! )
    .filter&gt; .AddToArray?: l_OutedIterators
    .filter&gt; ( 
      IN anItem 
     Self .MainAncestor call.me .filter&gt; ( anItem .IsSameModelElement ) .IsEmpty
    ) // .filter&gt;
    .map&gt; .ImplementMethod 
    array:Copy
   )
  end // ( Self .IsClassOrMixIn )
  
  if ( Self .IsUseCaseControllerImp ) then
  begin
   .joinWithLambded&gt;
   ( 
    //Self .ImplementsEx
    Self .ClassImplements
    .filter&gt; .IsUseCaseController 
   )
   (
    .Properties 
    .filter&gt; ( .Name 'Ref' SWAP EndsStr )
    .filter&gt; ( .MethodType GarantModel::IvcmViewAreaControllerRef .IsSameModelElement )
   )
  end // ( Self .IsUseCaseControllerImp )
  
  Self .ImplementsEx
  .filter&gt; ( .OpKind opkind_DecoratedType == )
  .for&gt; (
    IN aFacet
   VAR l_Implemented
   &gt;&gt;&gt; l_Implemented
   aFacet .InterfaceOperationsTotalDeep
   .filter&gt; ( l_Implemented SWAP .HasModelElement ! )
   .for&gt; ( 
     IN anOp
    l_Implemented .join&gt; (
     anOp .ImplementMethod .ToArray
    ) // l_Implemented .join&gt;
    &gt;&gt;&gt; l_Implemented
   ) // .for&gt;
   l_Implemented
  ) // .for&gt;
 )
 &gt;&gt;&gt; Result
; // ImplementedEx

BOOLEAN elem_func IsFactoryAcceptable
 RULES
  ( Self .IsInterface )
   true
  ( Self .IsMixInParamType )
   true
  ( Self .IsArray )
   true 
  DEFAULT
   false 
 ; // RULES  
 &gt;&gt;&gt; Result
; // IsFactoryAcceptable

ModelElement elem_func MainImplementsInterface
 Cached:
 (
  Self .ImplementsEx
  .filter&gt; .IsFactoryAcceptable
  .FirstElement
 )
 &gt;&gt;&gt; Result
; // MainImplementsInterface

STRING elem_func UIDforUserCode
 RULES
  ( Self .IsIterator )
   RULES
    (
     ( Self .MainAncestor .IsNotNil )
     AND ( Self .MainAncestor .IsIterator )
    ) 
     ( Self .MainAncestor .LUID )
    DEFAULT
     ( Self .LUID )
   ; // RULES
  ( Self .IsMethodAndImplementsIterator )
   ( Self .MainImplements .LUID )
  DEFAULT
   ( Self .LUID )
 ; // RULES
 &gt;&gt;&gt; Result
; // UIDforUserCode

BOOLEAN elem_func IsResultType
 Self .IsStereotype st_result_type::Attribute
 &gt;&gt;&gt; Result
; // IsResultType

BOOLEAN elem_func IsElementType
 Self .IsStereotype st_element_type::Attribute
 &gt;&gt;&gt; Result
; // IsElementType

BOOLEAN elem_func IsIndexType
 Self .IsStereotype st_index_type::Attribute
 &gt;&gt;&gt; Result
; // IsIndexType

BOOLEAN elem_func IsServiceIterator
 Self .IsStereotype st_serviceiterator 
 &gt;&gt;&gt; Result
; // IsServiceIterator

INTERFACE elem_func ItemParam
 Cached:
 (
  'anItem' Self MakeParam
 ) &gt;&gt;&gt; Result
; // ItemParam

INTERFACE elem_func IndexParam
 Cached:
 (
  'anIndex' Self MakeParam
 ) &gt;&gt;&gt; Result
; // IndexParam

BOOLEAN elem_func IsOverride
 RULES
  ( Self .IsControlOverride )
   true
  ( Self .IsIterator )
   RULES
    ( Self .MainAncestor .IsNil )
     false
    DEFAULT
     true 
   ; // RULES 
  DEFAULT
   false 
 ; // RULES
 &gt;&gt;&gt; Result
; // IsOverride

ModelElement elem_func IteratorAction
 Cached:
 (
  VAR l_Action
  Self .Action &gt;&gt;&gt; l_Action
  RULES
   ( l_Action .IsNotNil )
    l_Action
   ( Self .IsOverride )
    ( Self .MainAncestor call.me )
   DEFAULT
    begin
     [ Self .Parent .Name cUnderline Self .Name '_Action' ] strings:Cat 
     nil
     MakeFunction: (
       IN aMade
      aMade -&gt; UID := ( Self .LUID '_Action' Cat )  
      aMade -&gt; Parent := ( Self .Parent .WeakRef ) 
      aMade -&gt; Stereotype := st_Function
      aMade -&gt; %SUM := ( [ 
       'Тип подитеративной функции для ' Self .Parent .Name '.' Self .Name
       ] strings:Cat 
      )
      //aMade -&gt; Parameters := [ GarantModel::Pointer .ActionParamPrim ]
      aMade -&gt; Visibility := PublicAccess
      aMade -&gt; Operations := [
       'DoIt' GarantModel::Boolean MakeFunction: (
         IN aMadeOp
        aMadeOp -&gt; Parameters := [ 
         Self .Attributes
         .filter&gt; .IsElementType
         .mapToTarget&gt;
         .FirstElement
         .ItemParam
         
         if ( Self .UPisTrue "needs index" ) then
         begin
          VAR l_IndexType
          Self .Attributes
          .filter&gt; .IsIndexType
          .mapToTarget&gt;
          .FirstElement &gt;&gt;&gt; l_IndexType
          
          if ( l_IndexType .IsNil ) then
          begin
           GarantModel::Integer &gt;&gt;&gt; l_IndexType
          end // ( l_IndexType .IsNil )
          
          l_IndexType .IndexParam
         end // ( Self .UPisTrue "needs index" )
        ] // aMadeOp -&gt; Parameters
       ) // 'DoIt' GarantModel::Boolean MakeFunction: 
      ] // aMade -&gt; Operations
     ) // MakeFunction: 
    end // DEFAULT
  ; // RULES  
 ) &gt;&gt;&gt; Result
; // IteratorAction

INTERFACE elem_func ActionParamPrim
 Cached:
 (
  'anAction' Self MakeParam
 ) &gt;&gt;&gt; Result
; // ActionParamPrim

INTERFACE elem_func ActionParam
 Cached:
 (
  Self .IteratorAction .ActionParamPrim
 ) &gt;&gt;&gt; Result
; // ActionParam

ModelElement elem_func IteratorStub
 Cached:
 (
  VAR l_Stub
  Self .Stub &gt;&gt;&gt; l_Stub
  RULES
   ( l_Stub .IsNotNil )
    l_Stub
   ( Self .IsServiceIterator )
    begin
     VAR l_MixIn
     Self .Parent .MixInEx &gt;&gt;&gt; l_MixIn
     l_MixIn .OperationsEx
     .filter&gt; .IsIterator
     .filter&gt; ( .IsServiceIterator ! )
     .filter&gt; ( .Name Self .Name 'F' Cat ?== )
     .FirstElement 
     call.me
    end // ( Self .IsServiceIterator )
   ( Self .IsOverride )
    ( Self .MainAncestor call.me )
   DEFAULT
    begin
     [ 'L2_' Self .Parent .Name cUnderline Self .Name '_Action' ] strings:Cat Self .IteratorAction MakeFunction: (
       IN aMade
      aMade -&gt; UID := ( Self .LUID '_Stub' Cat )  
      aMade -&gt; Parent := ( Self .Parent .WeakRef ) 
      aMade -&gt; Stereotype := st_static::Operation
      aMade -&gt; %SUM := ( [ 
       'Функция формирования заглушки для ЛОКАЛЬНОЙ подитеративной функции для ' Self .Parent .Name '.' Self .Name
       ] strings:Cat 
      )
      aMade -&gt; Parameters := [ GarantModel::Pointer .ActionParamPrim ]
      aMade -&gt; Visibility := PublicAccess
      aMade -&gt; 'extprop:isGlobal' := true
      aMade -&gt; 'extprop:isAsm' := true
     ) // MakeFunction: 
    end // DEFAULT
  ; // RULES  
 ) &gt;&gt;&gt; Result
; // IteratorStub

BOOLEAN elem_func IsInParam
 Self .IsStereotype st_in::Attribute &gt;&gt;&gt; Result
; // IsInParam

BOOLEAN elem_func IsContract
 Self .IsStereotype st_Contract &gt;&gt;&gt; Result
; // IsContract

ModelElement elem_func FriendClass
 Cached:
 (
  VAR l_TypeName
  Self .TypeName &gt;&gt;&gt; l_TypeName
  l_TypeName 'Friend' Cat Self MakeClass: (
    IN aMade
   aMade -&gt; Stereotype := st_SimpleClass
   aMade -&gt; %SUM := ( 'Друг к классу ' l_TypeName Cat )
   aMade -&gt; Visibility := PrivateAccess
   aMade -&gt; Abstraction := at_abstract
   aMade -&gt; "ifdef" := ( Self .IfDefStr )
   aMade -&gt; "ifndef" := ( Self .IfNDefStr )
   aMade -&gt; "register in scripts" := false
  )
 )
 &gt;&gt;&gt; Result
; // FriendClass

ModelElement elem_func EffectiveType
 Cached:
 (
  RULES
   ( Self .UPisTrue "is friend" )
    ( Self .MainAncestor .FriendClass ) 
   DEFAULT
    ( Self .MainAncestor ) 
  ; // RULES  
 )
 &gt;&gt;&gt; Result
; // EffectiveType

ModelElement elem_func SelfParam
 Cached:
 (
  'Self' Self MakeParam
 )
 &gt;&gt;&gt; Result
; // SelfParam

CONST opModifyNone 1
CONST opModifySetter 2
CONST opModifyIteratorF 3
CONST opModifyTest 4
CONST opModifyExecute 5
CONST opModifyGetState 6
CONST opModifyArea 7

INTEGER elem_func OpModify
 Self 'OpModify' opModifyNone .ElemMember &gt;&gt;&gt; Result
; // OpModify

BOOLEAN elem_func IsIteratorF
 Self .OpModify opModifyIteratorF ==
 &gt;&gt;&gt; Result
; // IsIteratorF

BOOLEAN elem_func IsWriteonlyProperty
 Self .IsStereotype st_writeonly::Attribute 
 &gt;&gt;&gt; Result
; // IsWriteonlyProperty

BOOLEAN elem_func IsSetter
 RULES
  ( Self .IsWriteonlyProperty ) 
   true
  ( Self .OpModify opModifySetter == )
   true 
  DEFAULT
   false
 ; // RULES
 &gt;&gt;&gt; Result
; // IsSetter

BOOLEAN elem_func IsTester
 Self .OpModify opModifyTest == &gt;&gt;&gt; Result
; // IsTester

BOOLEAN elem_func IsExecutor
 Self .OpModify opModifyExecute == &gt;&gt;&gt; Result
; // IsExecutor

BOOLEAN elem_func IsGetState
 Self .OpModify opModifyGetState == &gt;&gt;&gt; Result
; // IsGetState

BOOLEAN elem_func IsAreaGetter
 Self .OpModify opModifyArea == &gt;&gt;&gt; Result
; // IsAreaGetter

BOOLEAN elem_func IsInternalOperation
 Self .IsStereotype st_InternalOperation::Operation 
 &gt;&gt;&gt; Result
; // IsInternalOperation

INTERFACE elem_func ParamsParam
 Cached:
 (
  'aParams' Self MakeParam
 ) 
 &gt;&gt;&gt; Result
; // ParamsParam

INTERFACE elem_func StateParam
 Cached:
 (
  'State' Self MakeInOutParam
 ) 
 &gt;&gt;&gt; Result
; // StateParam

BOOLEAN elem_func IsFactoryMethod
 Self .IsStereotype st_Factory
 &gt;&gt;&gt; Result
; // IsFactoryMethod

BOOLEAN elem_func IsFactory
  RULES
   ( Self .IsStereotype st_factory::Operation )
    true
   ( Self .IsFactoryMethod )
    true
   DEFAULT
    false
  ; //RULES   
 &gt;&gt;&gt; Result
; // IsFactory

BOOLEAN elem_func NeedAggregate
 Self .UPisTrue "need Aggregate" 
 &gt;&gt;&gt; Result
; // NeedAggregate

BOOLEAN elem_func IsMakeSingleChild
 ( Self .Name 'MakeSingleChild' == )
 &gt;&gt;&gt; Result
; // IsMakeSingleChild

BOOLEAN elem_func FirstParamIsViewAreaController
 VAR l_Params
 RULES
  ( Self .IsFactoryMethod )
   ( Self .FirstOperation .Parameters )
  DEFAULT
   ( Self .Parameters )
 ; // RULES
 &gt;&gt;&gt; l_Params  
 RULES
  ( l_Params .IsEmpty )
   false
  ( l_Params .mapToTarget&gt; .filter&gt; .IsViewAreaController .NotEmpty )
   true
  DEFAULT
   false 
 ; // RULES
 &gt;&gt;&gt; Result
; // FirstParamIsViewAreaController

elem_iterator PropertyKeys
 RULES
  ( Self .Parent .IsTestClass )
   (
    [ Self .Parent .EffectiveType .SelfParam ]
    .join&gt;
    ( Self .Attributes )
   )
  DEFAULT 
   ( Self .Attributes )
 ; // RULES  
 .filter&gt; ( .IsControlPrim ! )
 .filter&gt; ( .IsStereotype st_after::Attribute ! )
 &gt;&gt;&gt; Result
; // PropertyKeys

BOOLEAN elem_func IsReadonlyProperty
 Self .IsStereotype st_readonly::Attribute &gt;&gt;&gt; Result
; // IsReadonlyProperty

BOOLEAN elem_func IsProperty
 Cached:
 (
  RULES
   ( Self .IsStereotype st_property::Attribute )
    true
   ( Self .IsReadonlyProperty )
    true
   ( Self .IsWriteonlyProperty )
    true
   DEFAULT
    false 
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // IsProperty

ARRAY elem_func MethodParameters
 Cached:
 (
  RULES
   (
    ( Self .IsVCMOperationPrim )
    OR ( Self .IsModuleOperationPrim )
   ) 
    RULES
     ( Self .IsTester )
      ( GarantModel::IvcmTestParamsPrim .ParamsParam .ToArray )
     ( Self .IsExecutor )
      RULES
       ( Self .IsInternalOperation )
        ( Self .Parameters )
       DEFAULT
        ( GarantModel::IvcmExecuteParamsPrim .ParamsParam .ToArray )
      ; // RULES  
     ( Self .IsGetState )
      ( GarantModel::TvcmOperationStateIndex .StateParam .ToArray )
     ( Self .IsInternalOperation ) 
      ( GarantModel::IvcmExecuteParams .ParamsParam .ToArray )
     DEFAULT
      ( Self .Parameters )
    ; // RULES 
   ( Self .Parent .IsTestClass )
    (
     [ Self .Parent .EffectiveType .SelfParam ]
     .join&gt;
     ( Self .Parameters )
    )
   ( Self .IsIterator )
    (
     RULES
      ( Self .MainAncestor .IsNotNil )
       ( Self .MainAncestor call.me )
      DEFAULT
       (
        [ Self .ActionParam ]
        .join&gt; (
         Self .Attributes
         .filter&gt; .IsInParam
        ) // .join&gt;
       ) // DEFAULT
     ; // RULES
    ) 
   (
    ( Self .IsFactory )
    AND ( Self .Parent .IsVCMForm )
   ) 
    begin
     RULES
      ( Self .IsFactoryMethod )
       ( Self .FirstOperation .Parameters )
      DEFAULT
       ( Self .Parameters )
     ; // RULES
     if ( Self .IsMakeSingleChild ) then
     begin
      .join&gt; [
       'aCont' GarantModel::IvcmContainer MakeParam
       if ( Self .NeedAggregate ) then
       begin
        'anAgg' GarantModel::IvcmAggregate MakeParam
       end // ( Self .NeedAggregate )
      ] // .join&gt;
     end // ( Self .IsMakeSingleChild )
     else
     begin
      .join&gt; [ 
       'aParams' GarantModel::IvcmMakeParams MakeParam: (
         IN aMade
        aMade -&gt; 'extprop:pas:Value' := 'nil' 
       ) // 'aParams' GarantModel::IvcmMakeParams MakeParam:
      ] // .join&gt;
     end // ( Self .IsMakeSingleChild )
     .join&gt; ( 
      ( GarantModel::TvcmEntityForm.Make call.me )
      .filter&gt; (
        IN aParam
       RULES
        ( aParam .Name 'aZoneType' == )
         true
        ( aParam .Name 'aUserType' == )
         true
        ( aParam .Name 'aDataSource' == )
         RULES
          ( Self .FirstParamIsViewAreaController )
           false
          DEFAULT
           true
         ; // RULES 
        DEFAULT
         false
       ; // RULES
      ) // .filter&gt;
     ) // .join&gt;
     array:Copy
    end // ( Self .IsFactory )
   ( Self .IsFactoryMethod )
    RULES
     ( Self .MainAncestor .IsNotNil )
      ( Self .MainAncestor call.me )
     DEFAULT
      ( Self .FirstOperation .Parameters )
    ; // RULES  
   ( Self .IsMethod )
    RULES
     ( Self .ImplementsIterator )
      ( Self .MainImplements call.me )
     ( Self .MainAncestor .IsNotNil )
      RULES 
       ( Self .FirstOperation .IsNotNil )
        RULES
         (
          ( Self .FirstOperation .IsSummoned )
          AND ( Self .Abstraction at_regular == )
         ) 
          ( Self .MainAncestor call.me ) 
         DEFAULT
          ( Self .FirstOperation .Parameters )
        ; // RULES 
       DEFAULT
        ( Self .MainAncestor call.me )
      ; // RULES 
     DEFAULT
      ( Self .FirstOperation .Parameters )
    ; // ( Self .IsMethod )
   ( Self .IsFunction )
    ( Self .FirstOperation .Parameters )
   ( Self .IsProperty )
    ( Self .PropertyKeys )
   DEFAULT 
    ( Self .Parameters )
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // MethodParameters

CONST cUCStart '//#UC START# *'
CONST cUCEnd '//#UC END# *'

PROCEDURE ReadUCFromFile
  STRING IN aFileName
  STRING IN aCurrentGeneratedElementPrefix
 if ( aFileName sysutils:FileExists ) then
 begin
  FILE VAR l_In
  aFileName TryOpen: File:OpenRead &gt;&gt;&gt; l_In
  TRY
   VAR l_UCOpened
   ARRAY VAR l_Accumulated
   STRING VAR l_Key
   
   false &gt;&gt;&gt; l_UCOpened
   l_In File:ReadLines (
     IN aStr
     
    VAR l_Pos
    
    : Has
     string:Pos &gt;&gt;&gt; l_Pos
     l_Pos -1 !=
    ; // Has
     
    RULES 
     ( aStr cUCStart Has )
      ( 
       l_UCOpened ! ?ASSURE [ 'Секция кода уже открыта. Файл: ' aFileName ' строка:' aStr ]
       true &gt;&gt;&gt; l_UCOpened
       aStr string:Trim &gt;&gt;&gt; aStr
       [] &gt;&gt;&gt; l_Accumulated
       
       aStr &gt;&gt;&gt; l_Key
       '*' string:SplitTo! l_Key DROP
       
      )
     ( aStr cUCEnd Has )
      ( 
       l_UCOpened ?ASSURE [ 'Секция кода не открыта. Файл: ' aFileName ' строка:' aStr  ]
       false &gt;&gt;&gt; l_UCOpened
       
       VAR l_Head
       if ( l_Pos &gt; 0 ) then
       begin
        l_Pos 0 aStr string:Substring &gt;&gt;&gt; l_Head
        if ( l_Head string:TrimLeft .IsNotNil ) then
        begin
         l_Head .AddToArray: l_Accumulated
         
         aStr string:Len l_Pos - 
         l_Pos 
         aStr 
         string:Substring &gt;&gt;&gt; aStr
        end // ( l_Head .IsNotNil )
       end // ( l_Pos &gt; 0 )
       
       aStr string:Trim &gt;&gt;&gt; aStr
       
       g_CurrentGenerator -&gt;^ l_Key ^:= l_Accumulated
       g_CurrentGenerator -&gt;^ ( aCurrentGeneratedElementPrefix l_Key Cat ) ^:= l_Accumulated
       
       nil &gt;&gt;&gt; l_Accumulated
      )
     DEFAULT
      (
       l_UCOpened ? ( 
        aStr .AddToArray: l_Accumulated
       ) // l_UCOpened ?
      ) 
    ; // RULES  
   ) // l_In File:ReadLines
  FINALLY
   nil &gt;&gt;&gt; l_In
  END // TRY..FINALLY
 end // ( aFileName sysutils:FileExists )
; // ReadUCFromFile

CONST cPalka '|'

elem_proc OutUserCode:
  STRING IN aKey
  ^ IN aOutExisting
  ^ IN aOutNew
  
 BOOLEAN VAR l_Found
 false &gt;&gt;&gt; l_Found
 
 if ( g_UCRead ! ) then
 begin
  true &gt;&gt;&gt; g_UCRead
  STRING VAR l_TempFileName
  g_TempFileName '.uc.txt' Cat &gt;&gt;&gt; l_TempFileName 
  STRING VAR l_RealFileName
  g_RealFileName '.uc.txt' Cat &gt;&gt;&gt; l_RealFileName
  
  STRING VAR l_CurrentGeneratedElementPrefix
  [ cUserCodePrefix g_CurrentGeneratedElement .LUID cPalka ] strings:Cat &gt;&gt;&gt; l_CurrentGeneratedElementPrefix
  
  l_RealFileName l_CurrentGeneratedElementPrefix ReadUCFromFile
  g_FinalFileNameForUC l_CurrentGeneratedElementPrefix ReadUCFromFile

  FILE VAR l_Out
  l_TempFileName MakePathAndOpenWrite &gt;&gt;&gt; l_Out
  TRY
   g_CurrentGenerator MembersIterator 
   .filter&gt; ( .WordName l_CurrentGeneratedElementPrefix SWAP StartsStr )
   .for&gt; (
     IN anItem
    STRING VAR l_Key 
    anItem .WordName cPalka string:Split &gt;&gt;&gt; l_Key DROP
    
    cUCStart l_Out File:WriteStr
    l_Key l_Out File:WriteWStrLn
    
    anItem DO .for&gt; ( l_Out File:WriteWStrLn )
     
    cUCEnd l_Out File:WriteStr
    l_Key l_Out File:WriteWStrLn
     
   ) // g_CurrentGenerator MembersIterator
  FINALLY
   nil &gt;&gt;&gt; l_Out
  END // TRY..FINALLY
  l_RealFileName l_TempFileName false CopyChangedFile
  
  if ( l_RealFileName FileSize 0 == ) then
  begin
   l_RealFileName false DoDeleteFile
  end // ( l_RealFileName FileSize 0 == )
  
 end //( g_UCRead ! ) 
 
 l_Found ! ? (
  VAR l_Field
  g_CurrentGenerator %% aKey &gt;&gt;&gt; l_Field
  if ( l_Field .IsNil ) then
  begin
   aKey aOutNew DO
  end // ( l_Field .IsNil )
  else
  begin
   aKey l_Field DO aOutExisting DO
  end // ( l_Field .IsNil )
 ) // l_Found ! ?
; // OutUserCode:

elem_proc DefaultUserCodePrim:
  STRING IN aSuffix
  STRING IN aKey
  ^ IN aOutNew
  
 VAR l_KeyStart 
 Self .UIDforUserCode &gt;&gt;&gt; l_KeyStart
 
 l_KeyStart aKey Cat &gt;&gt;&gt; aKey
 aKey '*' Cat &gt;&gt;&gt; aKey
 
 Self aKey .OutUserCode: (
   IN aKey
   IN aValue
  [ cUCStart aKey ] .Out
  aValue .for&gt; ( ToOut \n ToOut )
  [ cUCEnd aKey ] .Out
 ) (
   IN aKey
  VAR l_Field
  nil &gt;&gt;&gt; l_Field 
  
  if ( aSuffix .NotIsNil ) then
  begin
   // - вообще говоря тут затычка для переноса слов скрипта в новый генератор
   if ( [ l_KeyStart cUnderline l_KeyStart ] strings:Cat aKey StartsStr ) then
   // - проверяем, что это слово скрипта у которого родитель поменял UID
   // - тут ещё надо KeywordObjectToOperate проверять
   begin
    g_CurrentGenerator MembersIterator 
    .filter&gt; ( .WordName l_KeyStart SWAP StartsStr )
    .filter&gt; ( .WordName aSuffix '*' Cat SWAP EndsStr )
    .FirstElement &gt;&gt;&gt; l_Field
   end
  end // ( aSuffix .NotIsNil )
  
  if ( l_Field .IsNil ) then
  begin
   aKey aOutNew DO
  end // ( l_Field .IsNil )
  else
  begin
   [ cUCStart aKey ] .Out
   l_Field DO .for&gt; ( ToOut \n ToOut )
   [ cUCEnd aKey ] .Out
   //l_Field .WordName Msg
  end // ( l_Field .IsNil )
 ) // Self aKey .OutUserCode:
; // DefaultUserCodePrim:

elem_proc DefaultUserCode
  STRING IN aSuffix
  STRING IN aKey
  TtfwWord IN aCode
 Self aSuffix aKey .DefaultUserCodePrim: (
   IN aKey
  [ cUCStart aKey ] .Out
  [ aCode DO ] .Out
  [ cUCEnd aKey ] .Out
 ) // Self aKey .OutUserCode:
; // DefaultUserCode

elem_proc PredefinedUserCode:
  STRING IN aSuffix
  STRING IN aKey
  ^ IN aOutLambda
  ^ IN aCode
 Self aSuffix aKey .DefaultUserCodePrim: (
   IN aKey
  [ aCode DO ] aOutLambda DO
 ) // Self aKey .OutUserCode:
; // PredefinedUserCode:

elem_proc PredefinedMethodUserCode:
  STRING IN aSuffix
  STRING IN aKey
  TtfwWord IN aCode
  ^ IN aVarCode
  ^ IN aImplCode
 RULES
  ( aSuffix cVarUserCodeSuffix == )
   ( Self aSuffix aKey .PredefinedUserCode: .Out ( aVarCode DO ) )
  ( aSuffix cImplementationUserCodeSuffix == )
   ( Self aSuffix aKey .PredefinedUserCode: ( IN aValue Indented: ( aValue .Out ) ) ( aImplCode DO ) )
  DEFAULT 
   ( Self aSuffix aKey aCode .DefaultUserCode )
 ; // RULES
; // PredefinedMethodUserCode:

elem_proc PredefinedMethodUserCodeWithoutVar:
  STRING IN aSuffix
  STRING IN aKey
  TtfwWord IN aCode
  ^ IN aImplCode
 Self aSuffix aKey aCode .PredefinedMethodUserCode: () ( aImplCode DO ) 
; // PredefinedMethodUserCodeWithoutVar:
  
ModelElement elem_func ImplementorOrParent
 //Cached:
 (
  g_Implementor &gt;&gt;&gt; Result
  
  if ( Result .IsNil ) then
  begin
   Self .Parent &gt;&gt;&gt; Result
  end // ( Result .IsNil )
  Result
 )
 &gt;&gt;&gt; Result
; // ImplementorOrParent

INTERFACE elem_func InterfaceLinkField
 Cached:
 (
  VAR l_TypeName
  Self .TypeName &gt;&gt;&gt; l_TypeName
  'f_' l_TypeName Cat Self MakeField: ( 
    IN aMade
   aMade -&gt; %SUM := ( 'Ссылка на интерфейс ' l_TypeName Cat )
   aMade -&gt; Visibility := PrivateAccess
  ) 
 )
 &gt;&gt;&gt; Result
; // InterfaceLinkField

BOOLEAN elem_func IsAutoHelper
 Self .UPisTrue "IsAutoHelper" 
 &gt;&gt;&gt; Result
; // IsAutoHelper

BOOLEAN elem_func IsVCMController
 RULES
  ( Self .IsStereotype st_UseCase::Attribute )
   true
  ( Self .IsStereotype st_VCMController )
   true
  DEFAULT
   false
 ; // RULES
 &gt;&gt;&gt; Result
; // IsVCMController

STRING elem_func AttrName
 RULES
  (
   ( Self .IsStereotype st_UseCase::Attribute )
   AND ( Self .Parent .IsViewAreaControllerImp )
  ) 
   begin
    if ( Self .Name .NotIsNil ) then
    begin
     if ( Self .Name 'SDS' == ) then
     begin
      Self .Name
     end // ( Self .Name 'SDS' == )
     else
     begin
      if ( Self .Target .IsUseCaseController ) then
      begin
       'ucc_' Self .Name Cat
      end // ( Self .Target .IsUseCaseController )
      else
      begin
       Self .Name
      end // ( Self .Target .IsUseCaseController )
     end // ( Self .Name 'SDS' == )
    end // ( Self .Name .NotIsNil )
    else
    begin
     if ( Self .Target .IsUseCaseController ) then
     begin
      'ucc_' Self .Target .TypeName Cat
     end // ( Self .Target .IsUseCaseController )
     else
     begin
      'ucp_' Self .Target .TypeName Cat
     end // ( Self .Target .IsUseCaseController )
    end // ( Self .Name .NotIsNil )
   end // ( Self .IsStereotype st_UseCase::Attribute )
  ( Self .IsOverride )
   begin
     VAR l_Name
     Self .MainAncestor call.me &gt;&gt;&gt; l_Name
     RULES
      ( l_Name .IsNil )
       ( Self .Name )
      DEFAULT
       l_Name
     ; // RULES
   end // ( Self .IsOverride )
  ( Self .IsVCMController )
   RULES
    ( Self .Name .IsNil )
     ( Self .Stereotype .Name '::' string:Split DROP )
    DEFAULT
     ( Self .Name )
   ; // RULES
  DEFAULT
   ( Self .Name )
 ; // RULES  
 &gt;&gt;&gt; Result
; // AttrName

STRING elem_func FieldName
 RULES
  ( Self .IsProperty )
   ( 'f_' Self .Name Cat )
  ( Self .IsVCMController ) 
   ( Self .AttrName )
  DEFAULT
   ( Self .Name )
 ; // RULES
 &gt;&gt;&gt; Result
; // FieldName

BOOLEAN elem_func HasFieldName
  STRING IN aName
 Self .FieldName aName == 
 &gt;&gt;&gt; Result
; // HasFieldName

BOOLEAN elem_func IsWrapper
 Self .IsStereotype st_Wrapper
 &gt;&gt;&gt; Result
; // IsWrapper

ARRAY elem_func LoadList
  STRING IN anExt
  STRING IN aFuncSuffix
 [empty] &gt;&gt;&gt; Result 
 VAR l_FileName
 Self .LUID anExt Cat &gt;&gt;&gt; l_FileName
 l_FileName Ctx:ResolveIncludedFilePath &gt;&gt;&gt; l_FileName
 if ( l_FileName sysutils:FileExists ) then
 begin
  STRING VAR l_Code 
  [ 
   'INCLUDE ' 
   cQuote l_FileName cQuote
   ' '
   'ME_' Self .LUID aFuncSuffix
  ] strings:Cat &gt;&gt;&gt; l_Code 
  l_Code script:CompileStringAndProcess ( 
   DO
   &gt;&gt;&gt; Result
  ) // l_Code script:CompileStringAndProcess
 end // ( l_FileName sysutils:FileExists )
; // LoadList

elem_iterator ImplementorsEx
 Cached:
 (
  Self .Implementors
  .join&gt; ( Self '.pas.ms.script.impl' '_Implementors' .LoadList )
  array:Copy
 )
 &gt;&gt;&gt; Result
; // ImplementorsEx

ModelElement elem_func TagAttrType
 //Cached:
 (
  VAR l_Target
  Self .Target &gt;&gt;&gt; l_Target
  RULES
   ( l_Target .Name 'String' == )
    GarantModel::String
   ( l_Target .Name 'Long' == )
    GarantModel::Integer
   ( l_Target .Name 'ULong' == )
    GarantModel::Cardinal
   ( l_Target .Name 'Int64' == )
    GarantModel::Int64
   ( l_Target .Name 'DateTime' == )
    GarantModel::TDateTime
   ( l_Target .Name 'DateTimeNotNull' == )
    GarantModel::TDateTime
   ( l_Target .Name 'Bool' == )
    GarantModel::Boolean
   ( l_Target .Name 'RawData' == )
    GarantModel::Tk2RawData
   ( Self .IsStereotype st_array::Attribute ) 
    begin
     VAR l_Implementor
     l_Target .ImplementorsEx
     .filter&gt; .IsInterface
     .filter&gt; ( .Name Self .Name 'Helper' Cat == )
     .FirstElement &gt;&gt;&gt; l_Implementor
     RULES
      ( l_Implementor .NotIsNil )
       l_Implementor
      DEFAULT
       GarantModel::Tl3Tag
     ; // RULES
    end // ( Self .IsStereotype st_array::Attribute )
   ( l_Target .IsTag )
    GarantModel::Tl3Tag
   ( l_Target .IsAtom )
    GarantModel::Tl3Tag
   DEFAULT
    l_Target
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // TagAttrType

STRING elem_func TagAttrAccessor
 Cached:
 (
  RULES
   ( Self .Name 'String' == )
    'Str'
   ( Self .Name 'Long' == )
    'Int'
   ( Self .Name 'ULong' == )
    'Int'
   ( Self .Name 'Int64' == )
    'Int64'
   ( Self .Name 'DateTime' == )
    'DateTime'
   ( Self .Name 'DateTimeNotNull' == )
    'DateTime'
   ( Self .Name 'Bool' == )
    'Bool'
   ( Self .Name 'RawData' == )
    'cAtom'
   ( Self .IsTag )
    'Attr'
   ( Self .IsAtom )
    'Attr'
   DEFAULT
    'Int'
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // TagAttrAccessor

STRING elem_func TagAttrGetType
 //Cached:
 (
  VAR l_Target
  Self .Target &gt;&gt;&gt; l_Target
  RULES
   ( l_Target .Name 'String' == )
    ''
   ( l_Target .Name 'Long' == )
    ''
   ( l_Target .Name 'ULong' == )
    'Cardinal'
   ( l_Target .Name 'Int64' == )
    ''
   ( l_Target .Name 'DateTime' == )
    ''
   ( l_Target .Name 'DateTimeNotNull' == )
    ''
   ( l_Target .Name 'Bool' == )
    ''
   ( l_Target .Name 'RawData' == )
    ( GarantModel::Tk2RawData .TypeName )
   ( l_Target .IsTag )
    ''
   ( l_Target .IsAtom )
    ''
   ( l_Target .IsSetOf )
    ( [ 'k2_typ' Self .GetUP 'extprop:evd:NewTypeName' '_ToSet' ] strings:Cat )
   DEFAULT
    ( l_Target .TypeName )
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // TagAttrGetType

STRING elem_func TagAttrSetType
 //Cached:
 (
  VAR l_Target
  Self .Target &gt;&gt;&gt; l_Target
  RULES
   ( l_Target .Name 'String' == )
    ''
   ( l_Target .Name 'Long' == )
    ''
   ( l_Target .Name 'ULong' == )
    'Integer'
   ( l_Target .Name 'Int64' == )
    ''
   ( l_Target .Name 'DateTime' == )
    ''
   ( l_Target .Name 'DateTimeNotNull' == )
    ''
   ( l_Target .Name 'Bool' == )
    ''
//   ( l_Target .Name 'RawData' == )
//    ( GarantModel::Tk2RawData .TypeName )
   ( l_Target .IsTag )
    ''
   ( l_Target .IsAtom )
    ''
   ( l_Target .IsSetOf )
    ( [ 'k2_typ' Self .GetUP 'extprop:evd:NewTypeName' '_FromSet' ] strings:Cat )
   DEFAULT
    ( 'Ord' )
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // TagAttrSetType

BOOLEAN elem_func IsArea
 Self .IsStereotype st_Area
 &gt;&gt;&gt; Result
; // IsArea

BOOLEAN elem_func IsAreaAttr
 Self .IsStereotype st_area::Attribute
 &gt;&gt;&gt; Result
; // IsAreaAttr

BOOLEAN elem_func IsVCMArea
 RULES
  ( Self .IsArea )
   true
  ( Self .IsAreaAttr ) 
   true
  DEFAULT
   false
 ; // RULES
 &gt;&gt;&gt; Result
; // IsVCMArea

BOOLEAN elem_func IsVCMAreaRef
 RULES
  ( Self .IsArea )
   ( Self .UPisTrue "is reference" )
  ( Self .IsAreaAttr ) 
   ( Self .LinkType lt_ref == )
  DEFAULT
   false
 ; // RULES
 &gt;&gt;&gt; Result
; // IsVCMAreaRef

BOOLEAN elem_func IsVCMAreaLink
 RULES
  ( Self .IsArea )
   ( Self .UPisTrue "is reference" ! )
  ( Self .IsAreaAttr ) 
   ( Self .LinkType lt_ref != )
  DEFAULT
   false
 ; // RULES
 &gt;&gt;&gt; Result
; // IsVCMAreaLink

elem_iterator Properties
 Cached:
 (
  VAR l_Properties
  Self .Attributes 
  .filter&gt; .IsProperty
  .filter&gt; ( .IsControlOverride ! )  
  &gt;&gt;&gt; l_Properties
  
  l_Properties
  
  if ( Self .IsClassOrMixIn ) then
  begin
   RULES
    ( Self .IsInterfaceFactory )
     ()
    ( Self .IsWrapper )
     ()
    DEFAULT
     begin
      Self .ImplementsEx 
      .filter&gt; .IsTag
      .for&gt; (
        IN aTag
        aTag .Attributes
        .filter&gt; ( .IsStereotype st_override::Attribute ! )
        .filter&gt; ( .IsStereotype st_default_child::Attribute ! )
        .filter&gt; ( .IsStereotype st_disabled_child::Attribute ! )
        .filter&gt; ( .IsStereotype st_children_override::Attribute ! )
        .filter&gt; ( .Stereotype st_children::Attribute ?!= )
        .filter&gt; ( .TagAttrType .NotIsNil )
        .for&gt; (
          IN anAttr
         .join&gt; ToArray: (
          anAttr .Name anAttr .TagAttrType MakeProperty: ( 
            IN aMade
           aMade -&gt; %SUM := ( anAttr .Documentation )
           aMade -&gt; Visibility := PublicAccess
           aMade -&gt; Stereotype := (
            RULES
             ( anAttr .UPisTrue "ReadOnly" )
              st_readonly::Attribute
             ( anAttr .IsStereotype st_array::Attribute )
              st_readonly::Attribute
             DEFAULT
              st_property::Attribute
            ; // RULES
           ) // aMade -&gt; Stereotype
           aMade -&gt; Abstraction := at_final
           aMade -&gt; LinkType := lt_ref
           aMade -&gt; "pm" := true
           aMade -&gt; "needs field" := false
           aMade -&gt; "ifdef" := ( anAttr .GetUP "ifdef" )
           aMade -&gt; "ifndef" := ( anAttr .GetUP "ifndef" )
           
           aMade -&gt;^ cGetterVarUserCodeName ^:= cEmptyUserCode
           aMade .AddMethodWithParams: cGetterImplementationUserCodeName ( anAttr aMade ) ( 
             IN anAttr
             IN aMade
            [ 
             ' Assert(Self &lt;&gt; nil);' \n
             ' Assert(TaggedData &lt;&gt; nil);' \n
             if ( anAttr .Target .Name 'DateTimeNotNull' == ) then
             begin
              ' if not TaggedData.HasSubAtom(k2_attr' aMade .Name ') then' \n
              '  if not Tk2Type(TaggedData.TagType).Prop[k2_attr' aMade .Name '].ReadOnly then' \n
              '  begin' \n
              '   pm_Set' aMade .Name '(Now);' \n
              '  end;' '//not Tk2Type(TaggedData.TagType).Prop[k2_attr' aMade .Name '].ReadOnly then' \n
             end // ( anAttr .Target .Name 'DateTimeNotNull' == )
             ' Result := '
             if ( anAttr .IsStereotype st_array::Attribute ) then
             begin
              if ( aMade .Target GarantModel::Tl3Tag .IsSameModelElement ) then
              begin
               'TaggedData.cAtom(k2_attr' anAttr .Name ')'
              end // ( aMade .Target GarantModel::Tl3Tag .IsSameModelElement )
              else
              begin
               'T' aMade .Target .TypeName '.Make(TaggedData.cAtom(k2_attr' anAttr .Name '))'
              end // ( aMade .Target GarantModel::Tl3Tag .IsSameModelElement )
             end // ( anAttr .IsStereotype st_array::Attribute )
             else
             begin
              anAttr .TagAttrGetType
              '(' 
              'TaggedData.' anAttr .Target .TagAttrAccessor
              if ( anAttr .Target .TagAttrAccessor 'cAtom' == ) then
              begin
               '(k2_attr' anAttr .Name ')'
              end // ( anAttr .Target .TagAttrAccessor 'cAtom' == )
              else
              begin
               if ( anAttr .Target .TagAttrAccessor 'Attr' != ) then
                'A'
               '[k2_attr' anAttr .Name ']'
              end // ( anAttr .Target .TagAttrAccessor 'cAtom' == )
              ')'
             end // ( anAttr .IsStereotype st_array::Attribute )
             ';'
            ]
           ) // aMade .AddMethodWithParams: cGetterImplementationUserCodeName ( anAttr aMade )
           
           aMade -&gt;^ cSetterVarUserCodeName ^:= cEmptyUserCode
           aMade .AddMethodWithParams: cSetterImplementationUserCodeName ( anAttr aMade ) ( 
             IN anAttr
             IN aMade
            [
             ' TaggedData.'
             if ( anAttr .Target .TagAttrAccessor 'cAtom' == ) then
             begin
              'Attr'
             end // ( anAttr .Target .TagAttrAccessor 'cAtom' == )
             else
             begin
              anAttr .Target .TagAttrAccessor
             end // ( anAttr .Target .TagAttrAccessor 'cAtom' == )
             'W' '[k2_attr' anAttr .Name ', nil]'
             ' := '
             anAttr .TagAttrSetType
             '('
             'aValue'
             ')'
             ';'
            ] 
           ) // aMade .AddMethodWithParams: cSetterImplementationUserCodeName ( anAttr aMade ) 
          ) // anAttr .Name anAttr .TagAttrType MakeProperty:
         ) // .join&gt; ToArray:
        ) // .for&gt;
      ) // .for&gt;
     end // DEFAULT
   ; // RULES 
    
  end // ( Self .IsClassOrMixIn )
  
  if ( Self .IsService ) then
  begin
   VAR l_Facet
   Self .FacetEx &gt;&gt;&gt; l_Facet
   if ( l_Facet .IsNotNil ) then
   begin
    if ( l_Properties 'Alien' .HasModelElementWithName ! ) then
    begin
     VAR l_TypeName
     l_Facet .TypeName &gt;&gt;&gt; l_TypeName
     .join&gt;
     [
      'Alien' l_Facet MakeProperty: ( 
        IN aMade
       aMade -&gt; %SUM := ( 'Внешняя реализация сервиса ' l_TypeName Cat )
       aMade -&gt; Visibility := PublicAccess
       aMade -&gt; Stereotype := st_writeonly::Attribute
       aMade -&gt; Abstraction := at_final
       aMade -&gt; LinkType := lt_ref
       aMade -&gt; "pm" := true
       aMade -&gt; "needs field" := true
       aMade -&gt;^ cSetterVarUserCodeName ^:= cEmptyUserCode
       aMade .AddMethodWithParams: cSetterImplementationUserCodeName () ( 
        [
         ' Assert((f_Alien = nil) OR (aValue = nil));' \n
         ' f_Alien := aValue;'
        ]
       ) // aMade .AddMethodWithParams: cSetterImplementationUserCodeName
      ) // 'Alien' l_Facet MakeProperty:
     ] // .join&gt;
    end // ( l_Properties 'Alien' .HasModelElementWithName ! )
   end // ( l_Facet .IsNotNil )
  end // ( Self .IsService )
  
  if ( Self .IsVCMCustomForm ) then
  begin
   //if ( Self .Abstraction at_final == ) then
   begin
    .join&gt;
    ( 
     Self .OwnControls
     .filter&gt; ( .IsControlOverride ! )
     .filter&gt; ( .NotInArray: l_Properties )
     array:Copy
    )
   end // ( Self .Abstraction at_final == )
  end // ( Self .IsVCMCustomForm )
  
  if ( Self .IsUseCaseController ) then
  begin
   l_Properties
   .filter&gt; .IsVCMAreaRef
   .for&gt; (
     IN aRef
    .join&gt; ToArray: (
     aRef .Name 'Ref' Cat GarantModel::IvcmViewAreaControllerRef MakeProperty: ( 
       IN aMade
      aMade -&gt; UID := ( aRef .LUID 'Ref' Cat ) 
      aMade -&gt; Parent := ( Self .WeakRef )
      aMade -&gt; %SUM := ( [ 'Ссылка на ' '"' aRef .Documentation '"' ] strings:Cat )
      aMade -&gt; Visibility := PublicAccess
      aMade -&gt; Stereotype := st_readonly::Attribute
      aMade -&gt; Abstraction := at_final
      aMade -&gt; LinkType := lt_lnk
      aMade -&gt; "pm" := true
      //aMade -&gt; "needs field" := false
      aMade -&gt; "ifdef" := ( aRef .GetUP "ifdef" )
      aMade -&gt; "ifndef" := ( aRef .GetUP "ifndef" )
      aMade -&gt;^ cGetterVarUserCodeName ^:= cEmptyUserCode
      aMade .AddMethodWithParams: cGetterImplementationUserCodeName aMade ( 
        IN aMade
       [ ' Result := SetData.' aMade .Name ';' ]
      ) // aMade .AddMethodWithParams: cGetterImplementationUserCodeName
     ) // ... MakeProperty:  
    ) // .join&gt; ToArray: 
   ) // .for&gt;
  end // ( Self .IsUseCaseController )
 )
 &gt;&gt;&gt; Result
; // Properties

BOOLEAN elem_func NeedPutToDFM
 Cached:
 (
  Self .UPisTrue "put to dfm" &gt;&gt;&gt; Result
  if Result then
  begin
   if ( Self .Parent .IsControlPrim ) then
   begin
    Self .Parent call.me &gt;&gt;&gt; Result
   end // ( Self .Parent .IsControlPrim )
  end // Result
  Result
 )
 &gt;&gt;&gt; Result
; // NeedPutToDFM

BOOLEAN elem_func ReadsField
 RULES
  ( Self .IsControlPrim )
   ( Self .NeedPutToDFM ! )
  ( Self .IsWriteonlyProperty ) 
   true
  ( Self .UPisTrue "reads field" )
   true
  DEFAULT
   false 
 ; // RULES
 &gt;&gt;&gt; Result
; // elem_func ReadsField

BOOLEAN elem_func WritesField
 RULES
  ( Self .IsReadonlyProperty )
   true
  ( Self .UPisTrue "writes field" )
   true
  DEFAULT
   false 
 ; // RULES 
 &gt;&gt;&gt; Result
; // elem_func WritesField

BOOLEAN elem_func NeedsField
 RULES
  ( Self .IsOverride )
   false
  ( Self .IsControlPrim )
   RULES
    ( Self .NeedPutToDFM )
     true
    DEFAULT
     true 
   ; // RULES 
  ( Self .UPisTrue "reads field" )
   true
  ( Self .UPisTrue "writes field" )
   true
  ( Self .Parent .IsInterface ) 
   RULES
    ( Self .UPisTrue "needs field" )
     true
    DEFAULT
     false 
   ; // RULES
  ( Self .Abstraction at_abstract == ) 
   false
  ( Self .UPisTrue "needs field" )
   true
  DEFAULT
   false
 ; // RULES
 &gt;&gt;&gt; Result
; // NeedsField

BOOLEAN elem_func CanMapPropertiesToFields
 RULES
  ( Self .IsClassOrMixIn )
   true
  ( Self .IsException )
   true
  DEFAULT
   false
 ; // RULES
 &gt;&gt;&gt; Result
; // CanMapPropertiesToFields

elem_iterator Fields
 Cached:
 (
  VAR l_Fields
  Self .Attributes
  .filter&gt; ( .IsProperty ! )
  .filter&gt; ( .IsStereotype st_impurity_value::Attribute ! )
  .filter&gt; ( .IsStereotype st_switch::Attribute ! )
  .filter&gt; ( .IsStereotype st_impurity_param::Attribute ! )
  .filter&gt; ( .IsStereotype st_static::Attribute ! )
  .filter&gt; ( .IsStereotype st_link::Attribute ! )
  &gt;&gt;&gt; l_Fields
  
  if ( Self .CanMapPropertiesToFields ) then
  begin
   l_Fields array:Copy &gt;&gt;&gt; l_Fields
   l_Fields
   .joinWithLambded&gt; (
    Self .Properties 

    .join&gt; ( 
     Self .Implemented 
     .filter&gt; .IsProperty
     .filter&gt; ( .Parent .IsInterface ) 
    ) // .join&gt;
    .filter&gt; .NeedsField
    .filter&gt; ( 
      IN anItem 
     l_Fields .HasSomeOf: ( anItem .FieldName .HasName ) !
//     l_Fields .HasSomeOf: ( anItem .FieldName .HasFieldName ) !
    ) // .filter&gt;
   ) .ToArray
  end // ( Self .CanMapPropertiesToFields )
  else
   l_Fields
  
  if ( Self .IsStaticObject ) then
  begin
   if ( Self .IsAutoHelper ) then
   begin
    .joinWithLambded&gt; ( Self .ImplementsEx ) .ToArray: .InterfaceLinkField
   end // ( Self .IsAutoHelper )
  end // ( Self .IsStaticObject )
  
  if ( Self .IsUseCaseControllerImp ) then
  begin
   Self .ImplementedEx 
   .filter&gt; .IsVCMAreaLink
   .for&gt; (
     IN aProp
    VAR l_Name 
    [ 'f_' aProp .Name ] strings:Cat &gt;&gt;&gt; l_Name
    if ( l_Fields l_Name .HasModelElementWithName ! ) then
    begin 
     .join&gt; ToArray: (
      l_Name
      GarantModel::IvcmViewAreaControllerRef
      MakeField: ( 
        IN aMade
       aMade -&gt; LinkType := lt_ref 
       aMade -&gt; Visibility := PrivateAccess
       aMade -&gt; %SUM := ( [ 'Поле для области вывода ' aProp .Name ] strings:Cat ) 
       aMade -&gt; "ifdef" := ( aProp .GetUP "ifdef" )
       aMade -&gt; "ifndef" := ( aProp .GetUP "ifndef" )
      ) // MakeField:
     ) // .join&gt; ToArray: 
    end // ( l_Fields l_Name .HasModelElementWithName ! )
   ) // .for&gt;
  end // ( Self .IsUseCaseControllerImp )
 )
 &gt;&gt;&gt; Result
; // Fields

BOOLEAN elem_func IsSingleton
 RULES
  ( Self .IsVCMFormSetFactory )
   ( Self .Abstraction at_final == )
  ( Self .IsService ) 
   true
  ( Self .IsServiceImplementation ) 
   true
  DEFAULT 
   ( Self .UPisTrue "singleton" )
 ; // RULES  
 &gt;&gt;&gt; Result
; // IsSingleton

BOOLEAN elem_func HasFactory
 Cached:
 (
  Self .OperationsEx
  .filter&gt; .IsFactory 
  .NotEmpty
 ) 
 &gt;&gt;&gt; Result
; // HasFactory

INTERFACE elem_func InstanceField
 Cached:
 (
  VAR l_TypeName
  Self .TypeName &gt;&gt;&gt; l_TypeName
  
  'g_' l_TypeName Cat 
   if ( Self .HasFactory ) then
    GarantModel::Pointer
   else
    Self 
  MakeField: ( 
    IN aMade
   aMade -&gt; %SUM := ( 'Экземпляр синглетона ' l_TypeName Cat )
   aMade -&gt; Visibility := PrivateAccess
   aMade -&gt; 'extprop:pas:Value' := 'nil'
   aMade -&gt; "ifdef" := ( Self .IfDefStr )
   aMade -&gt; "ifndef" := ( Self .IfNDefStr )
  )
 )
 &gt;&gt;&gt; Result
; // InstanceField

BOOLEAN elem_func IsLocalVar
 Self .IsStereotype st_var::Attribute 
 &gt;&gt;&gt; Result
; // IsLocalVar

BOOLEAN elem_func IsGlobalVar
 Self .IsStereotype st_globalvar::Attribute
 &gt;&gt;&gt; Result
; // IsGlobalVar

elem_iterator InnerGlobalVars
 Self .Attributes
 .filter&gt; .IsGlobalVar
 .joinWithLambded&gt; ( Self .OperationsEx ) call.me
 &gt;&gt;&gt; Result
; // InnerGlobalVars

elem_iterator GlobalVars
 Cached:
 (
  RULES
   ( Self .IsClassOrMixIn )
    (
     Self .Attributes
     .filter&gt; ( .IsStereotype st_static::Attribute )
     if ( Self .IsSingleton ) then
     begin
      .join&gt; ToArray: ( Self .InstanceField )
     end // ( Self .IsSingleton )
     .join&gt; ( Self .InnerGlobalVars )

     if ( Self .IsVCMFormsPack ) then
     begin
      if ( Self .Abstraction at_final == ) then
      begin
       VAR l_Vars
       VAR l_ModuleName
       Self .Name &gt;&gt;&gt; l_ModuleName

       elem_proc AddModuleOperationToVars
        Self .OperationsEx
        .filter&gt; .IsModuleOperationPrim
        .for&gt; (
          IN anOp
         VAR l_Name
         VAR l_Type
         [ 'g_module_opcode_' l_ModuleName '_' anOp .Name ] strings:Cat &gt;&gt;&gt; l_Name
         GarantModel::TvcmMOPID &gt;&gt;&gt; l_Type
         if ( l_Vars l_Name .HasModelElementWithName ! ) then
         begin
          l_Vars
          .join&gt; ToArray: (
           l_Name
           l_Type
           MakeField: (
             IN aMade
            aMade -&gt; Visibility := PublicAccess
            aMade -&gt; 'extprop:pas:Value' := '(rMoID : -1; rOpID : -1)'
           ) // MakeField:
          ) //.join&gt; ToArray:
          &gt;&gt;&gt; l_Vars
         end // ( l_Vars l_Name .HasModelElementWithName ! )
        ) // .for&gt;
        Self .InheritsEx .for&gt; call.me
       ; // AddModuleOperationToVars

       &gt;&gt;&gt; l_Vars
       Self .AddModuleOperationToVars
       l_Vars
      end // ( Self .Abstraction at_final == )
     end // ( Self .IsVCMFormsPack )

    ) // ( Self .IsClassOrMixIn )
   ( Self .IsUtilityPack )
    (
     Self .Attributes
     .filter&gt; ( .IsProperty ! )
     .join&gt; ( Self .InnerGlobalVars )
    )
   ( Self .IsVCMControls )
    begin
     VAR l_Vars

     elem_proc AddOperationToVars
      VAR l_Name
      VAR l_Type
      [ 'opcode_' Self .Parent .Name '_' Self .Name ] strings:Cat &gt;&gt;&gt; l_Name
      GarantModel::TvcmOPID &gt;&gt;&gt; l_Type
      if ( l_Vars l_Name .HasModelElementWithName ! ) then
      begin
       l_Vars
       .join&gt; ToArray: (
        l_Name
        l_Type
        MakeField: (
          IN aMade
         aMade -&gt; Visibility := PublicAccess
         aMade -&gt; 'extprop:pas:Value' := '(rEnID : -1; rOpID : -1)'
        ) // MakeField:
       ) //.join&gt; ToArray:
       &gt;&gt;&gt; l_Vars
      end // ( l_Vars l_Name .HasModelElementWithName ! )
     ; // AddOperationToVars

     [empty]
     &gt;&gt;&gt; l_Vars
     Self .ChildrenEx
     .filter&gt; .IsVCMOperations
     .for&gt; (
       IN anEntity
      anEntity .OperationsEx
      .filter&gt; .IsVCMOperation
      .for&gt; (
        IN anOperation
       anOperation .AddOperationToVars 
       anOperation .ChildrenEx
       .filter&gt; .IsVCMOperationState
       .for&gt; (
         IN aState
        l_Vars 
        .join&gt; ToArray: (
         [ 'st_user_' anEntity .Name '_' anOperation .Name '_' aState .Name ] strings:Cat
         GarantModel::TvcmOperationStateIndex
         MakeField: (
           IN aMade
          aMade -&gt; Visibility := PublicAccess
          aMade -&gt; 'extprop:pas:Value' := '(rID : -1)'
          aMade -&gt; %SUM := ( [ anEntity .Documentation ' -&gt; ' anOperation .Documentation ' &lt;-&gt; ' aState .Documentation ] strings:Cat )
          aMade -&gt; "ifdef" := ( aState .GetUP "ifdef" )
          aMade -&gt; "ifndef" := ( aState .GetUP "ifndef" )
         ) // MakeField:
        ) // .join&gt; ToArray:
        &gt;&gt;&gt; l_Vars
       ) // .for&gt;
      ) // .for&gt;
     ) // .for&gt;
     l_Vars
    end // ( Self .IsVCMControls )
   DEFAULT
    [empty]
  ; // RULES
 ) 
 &gt;&gt;&gt; Result
; // GlobalVars

BOOLEAN elem_func IsWideString
 Cached:
 (
  RULES
   ( Self .Name 'a-string' == )
    false
   ( Self .Name 'a-wstring' == )
    true
   ( Self .IsTypedef )
    RULES
     ( Self .IsPointer )
      false
     DEFAULT
      ( Self .MainAncestor call.me )
    ; // RULES  
   DEFAULT
    false
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // IsWideString

BOOLEAN elem_func IsString
 Cached:
 (
  RULES
   ( Self .Name 'a-string' == )
    true
   ( Self .IsWideString )
    true
   ( Self .IsTypedef )
    RULES
     ( Self .IsPointer )
      false
     DEFAULT
      ( Self .MainAncestor call.me )
    ; // RULES  
   DEFAULT
    false
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // IsString

BOOLEAN elem_func IsUntyped
 Self .Name 'void' == &gt;&gt;&gt; Result
; // IsUntyped

BOOLEAN elem_func IsManaged
 Cached:
 (
  RULES
   ( Self .IsRecord )
    true
   ( Self .IsUnion )
    true
   ( Self .IsArray )
    true
   ( Self .IsInterface )
    true
   ( Self .IsTypedef )
    RULES
     ( Self .IsPointer )
      false
     DEFAULT
      ( Self .MainAncestor call.me )
    ; // RULES  
   ( Self .IsMixInParamType )
    true
   ( Self .IsString )
    true
   ( Self .IsUntyped )
    true
   DEFAULT
    false
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // IsManaged

BOOLEAN elem_func IsConstants
 Self .IsStereotype st_Constants 
 &gt;&gt;&gt; Result
; // IsConstants

BOOLEAN elem_func IsSetConst
 Self .IsStereotype st_SetConst 
 &gt;&gt;&gt; Result
; // IsSetConst

BOOLEAN elem_func IsConstantArray
 Self .IsStereotype st_ConstantArray 
 &gt;&gt;&gt; Result
; // IsConstantArray

BOOLEAN elem_func IsLocalConst
 Self .IsStereotype st_LocalConst 
 &gt;&gt;&gt; Result
; // IsLocalConst

BOOLEAN elem_func IsChoices
 Self .IsStereotype st_Choices
 &gt;&gt;&gt; Result
; // IsChoices

BOOLEAN elem_func IsChoice
 Self .IsStereotype st_Choice
 &gt;&gt;&gt; Result
; // IsChoice

BOOLEAN elem_func IsExcludeUserTypes
 Self .IsStereotype st_ExcludeUserTypes
 &gt;&gt;&gt; Result
; // IsExcludeUserTypes

BOOLEAN elem_func IsIncludeUserTypes
 Self .IsStereotype st_IncludeUserTypes
 &gt;&gt;&gt; Result
; // IsIncludeUserTypes

BOOLEAN elem_func IsConstantsButNotType
 RULES
  ( Self .IsRange )
   false
  ( Self .IsConstants )
   true
  ( Self .IsSetConst )
   true
  ( Self .IsConstantArray )
   true
  ( Self .IsLocalConst )
   true
  ( Self .IsMessage )
   true
  ( Self .IsChoices )
   true
  ( Self .IsChoice )
   true
  DEFAULT
   false 
 ; // RULES
 &gt;&gt;&gt; Result  
; // IsConstantsButNotType

BOOLEAN elem_func IsType
 Cached:
 (
  RULES
   ( Self .MDAClass class_Operation == )
    false
   ( Self .MDAClass class_Attribute == )
    false
   ( Self .MDAClass class_Parameter == )
    false
   ( Self .MDAClass class_Category == )
    false
   ( Self .MDAClass class_Dependency == )
    false
   DEFAULT
    RULES
     ( Self .IsExcludeUserTypes )
      false
     ( Self .IsConstantsButNotType )
      false
     ( Self .IsVCMOperations )
      false
     ( Self .IsControlPrim )
      false
     ( Self .IsProperty )
      false
     ( Self .IsMethod )
       false
     ( Self .IsElementProxy )
      false
     ( Self .IsTestClass )
      false
     ( Self .IsUserType ) 
      false
     ( Self .IsUtilityPack )
      false
     ( Self .IsInterfaces )
      false
     ( Self .IsTarget )
      false
     ( Self .IsEvdSchemaElement )
      false
     ( Self .IsPureMixIn )
      false
     ( Self .IsDefine )
      false
     ( Self .IsMixIn )
      false
     ( Self .IsMixInParamType )
      false 
     ( Self .IsVCMFormZone ) 
      false
     ( Self .IsVCMZone ) 
      false
     DEFAULT
      true
    ; // RULES
  ; // RULES  
 )
 &gt;&gt;&gt; Result
; // IsType

STRING CompileTime-VAR g_IfDefStr ''
STRING CompileTime-VAR g_IfNDefStr ''
ARRAY CompileTime-VAR g_IfDefArr []
ARRAY CompileTime-VAR g_IfNDefArr []

BOOLEAN CompileTime-VAR g_WasType false
ModelElement CompileTime-VAR g_WasTypeOpener nil
BOOLEAN CompileTime-VAR g_WasConst false
BOOLEAN CompileTime-VAR g_WasForwarded false

PROCEDURE DropWasType
 false &gt;&gt;&gt; g_WasType
 //false &gt;&gt;&gt; g_WasConst
 nil &gt;&gt;&gt; g_WasTypeOpener
; // DropWasType

elem: IfDefPrim:
  IN aElseLambda
  ^ IN aOutLambda
  ^ IN aLambda
 
 if ( Self IsString ! ) then
 begin
  TF g_IfDefStr (
   TF g_IfNDefStr (
    TF g_IfDefArr (
     TF g_IfNDefArr (
     
      VAR l_IfDefStr
      Self .IfDefStr &gt;&gt;&gt; l_IfDefStr
      
      VAR l_IfNDefStr
      Self .IfNDefStr &gt;&gt;&gt; l_IfNDefStr
      
      BOOLEAN VAR l_NeedOut
      false &gt;&gt;&gt; l_NeedOut
      
      ARRAY VAR l_Body
      nil &gt;&gt;&gt; l_Body
      
      : OutIfBody
        STRING IN anOpen
        STRING IN aClose
       VAR l_NeedAND
       false &gt;&gt;&gt; l_NeedAND
       
       : OutItem
         IN anItem
         STRING IN aPrefix
         ARRAY IN anOuted
        if ( anItem .IsNotNil ) then
        begin
         if ( anItem .TextNotInArray: anOuted ) then
         begin
          anItem .AddToArray: anOuted
          true &gt;&gt;&gt; l_NeedOut
          cSpace 
          if l_NeedAND then
          begin
           'AND' cSpace
          end
          else
          begin
           true &gt;&gt;&gt; l_NeedAND
          end // l_NeedAND
          aPrefix 'Defined(' anItem ')'
         end // ( anItem .TextNotInArray: anOuted )
        end // ( anItem .IsNotNil )
       ; // OutItem
       
       [ 
        l_IfDefStr ',' string:Split:for&gt; ( cEmptyStr g_IfDefArr OutItem )
        l_IfNDefStr ',' string:Split:for&gt; ( 'NOT ' g_IfNDefArr OutItem )
       ] &gt;&gt;&gt; l_Body
       
       if l_NeedOut then
       begin
        [
         anOpen
         l_Body
         aClose
         if ( g_EnableAutoEOL ! ) then
          \n
        ] aOutLambda DO
       end // l_NeedOut
      ; // OutIfBody
      
      if ( ( l_IfDefStr .IsNotNil ) OR ( l_IfNDefStr .IsNotNil ) ) then
      begin
       if ( ( l_IfDefStr g_IfDefStr != ) OR ( l_IfNDefStr g_IfNDefStr != ) ) then
       begin
        g_IfDefArr array:CopyNotNil &gt;&gt;&gt; g_IfDefArr
        g_IfNDefArr array:CopyNotNil &gt;&gt;&gt; g_IfNDefArr
        
        l_IfDefStr &gt;&gt;&gt; g_IfDefStr
        l_IfNDefStr &gt;&gt;&gt; g_IfNDefStr
        
        : IfOut
         cOpenComment '$If' Cat cCloseComment OutIfBody
        ; // IfOut
        
        if g_NeedOutLn then
        begin
         false &gt;&gt;&gt; g_NeedOutLn
         OutLnToFile
        end // g_NeedOutLn
        IfOut
       end // ( ( l_IfDefStr g_IfDefStr != ) OR ( l_IfNDefStr g_IfNDefStr != ) )
      end // ( ( l_IfDefStr .IsNotNil ) OR ( l_IfNDefStr .IsNotNil ) )
      
      aLambda DO 
      
      if l_NeedOut then
      begin
      
       : IfEndOut
        false &gt;&gt;&gt; l_NeedOut
        nil &gt;&gt;&gt; g_IfDefArr
        nil &gt;&gt;&gt; g_IfNDefArr
        
        if ( aElseLambda .IsNotNil ) then
        begin
         [ cOpenComment '$Else' l_Body cCloseComment \n ] aOutLambda DO
         aElseLambda DO
        end // ( aElseLambda .IsNotNil )
        
        [ 
         cOpenComment '$IfEnd' cCloseComment cSpace '//' 
         l_Body 
         if g_NeedOutLn then
         begin
          false &gt;&gt;&gt; g_NeedOutLn
          \n
         end // g_NeedOutLn
        ] aOutLambda DO
        nil &gt;&gt;&gt; l_Body
        
        if ( Self .IsType ) then
        begin
         if ( g_WasForwarded ! ) then
         begin
          if ( g_WasTypeOpener Self ?== ) then
          begin
           DropWasType
          end // ( g_WasTypeOpener Self ?== )
         end // ( g_WasForwarded ! )
        end // ( Self .IsType )
        false &gt;&gt;&gt; g_WasConst
        
       ; // IfEndOut
       
       IfEndOut
      end // l_NeedOut
     ) // TF g_IfNDefArr 
    ) // TF g_IfDefArr
   ) // // TF g_IfNDefStr  
  ) // TF g_IfDefStr 
 end // ( Self IsString ! )
 else
 begin
  aLambda DO
 end // ( Self IsString ! )
; // IfDefPrim:

elem_proc IfDef:
  ^ IN aLambda
 Self nil .IfDefPrim: .Out ( aLambda DO ) 
; // IfDef:
 
elem_proc IfDefElse:
  ^ IN aLambda
  ^ IN aElseLambda
 Self aElseLambda .IfDefPrim: .Out ( aLambda DO ) 
; // IfDefElse:

BOOLEAN elem_func IsConstructor
  RULES
   ( Self .IsStereotype st_ctor::Operation )
    true
   ( Self .IsStereotype st_Constructor )
    true
   DEFAULT
    false
  ; //RULES   
 &gt;&gt;&gt; Result
; // IsConstructor

BOOLEAN elem_func IsStaticConstructor
  RULES
   ( Self .IsConstructor )
    RULES
     ( Self .Parent .IsRecord )
      true
     DEFAULT
      false
    ; // RULES
   DEFAULT
    false
  ; //RULES   
 &gt;&gt;&gt; Result
; // IsStaticConstructor

BOOLEAN elem_func NeedsFinalize
 Cached:
 (
  RULES
   ( Self .IsNil )
    false
   DEFAULT
    RULES
     ( 
      Self .Attributes
      .mapToTarget&gt;
      .filter&gt; .IsManaged
      .NotEmpty
     )
      true
     ( Self .MainAncestor call.me )
      true
     DEFAULT
      false
    ; // RULES
  ; // RULES  
 )
 &gt;&gt;&gt; Result
; // NeedsFinalize

BOOLEAN elem_func ParentIsInterface
 Cached:
 (
  Self .Parent .IsInterface
 )
 &gt;&gt;&gt; Result
; // ParentIsInterface

INTEGER elem_func FieldLinkType
 RULES
  ( Self .IsProperty )
   RULES
    ( Self .ParentIsInterface )
     lt_ref
    ( Self .LinkType lt_lnk == ) 
     lt_lnk
    DEFAULT
     lt_ref
   ; // RULES
  DEFAULT
   ( Self .LinkType )
 ; // RULES
 &gt;&gt;&gt; Result
; // FieldLinkType

BOOLEAN elem_func IsFieldForCleanup
 ( Self .FieldLinkType lt_ref == ) 
 AND ( Self .Target .IsManaged )
 AND ( 
  ( Self .GetUP 'extprop:clearViaProperty' .IsNil )
  OR ( Self .Target .IsMixInParamType ! )
 )
 &gt;&gt;&gt; Result
; // IsFieldForCleanup

STRING elem_func MethodUserCodeModifier
 RULES
  ( Self .IsAreaGetter )
   'area'
  ( Self .IsSetter )
   'set'
  ( Self .IsProperty )
   'get'
  ( Self .IsTester )
   'test'
  ( Self .IsExecutor )
   'exec'
  ( Self .IsGetState )
   'getstate'
  DEFAULT
   '' 
 ; // RULES
 &gt;&gt;&gt; Result
; // MethodUserCodeModifier

elem_proc MethodUserCode
  STRING IN aKey
  TtfwWord IN aCode
  
 STRING VAR l_Key 
 aKey &gt;&gt;&gt; l_Key
 
 VAR l_Implementor
 Self .ImplementorOrParent &gt;&gt;&gt; l_Implementor
 
 RULES
  ( l_Key 'iter' == )
   ()
  ( l_Key 'afteriter' == )
   ()
  ( l_Key 'iterparam' == )
   ()
  ( l_Key 'NeedMake_impl' == )
   ()
  DEFAULT
   (
    Self .MethodUserCodeModifier l_Key Cat &gt;&gt;&gt; l_Key
    
    if ( l_Implementor .IsNotNil ) then
    begin
     [ 
      cUnderline 
      if ( Self .IsLocalMethod ! ) then
      begin
       l_Implementor .LUID
      end // ( Self .IsLocalMethod ! )
      l_Key 
     ] strings:Cat &gt;&gt;&gt; l_Key
    end // ( l_Implementor .IsNotNil )
   ) // DEFAULT
 ; // RULES
 
 BOOLEAN elem_func IsSingletonExists
  Self .Name 'Exists' ==
  AND ( Self .IsStaticOp )
  AND ( l_Implementor .IsSingleton )
  &gt;&gt;&gt; Result
 ; // IsSingletonExists
 
 : WithoutVar:
   ^ IN aImplCode
  Self aKey l_Key aCode .PredefinedMethodUserCodeWithoutVar: ( aImplCode DO ) 
 ; // WithoutVar:
 
 RULES
  ( Self .IsSingletonExists )
   (
    WithoutVar:
    ( 
     'Result := g_' l_Implementor .TypeName ' &lt;&gt; nil;'
    ) 
   ) // ( Self .IsSingletonExists )
  ( 
   Self .Name 'Alien' ==
   AND ( Self .IsSetter ) 
   AND ( l_Implementor .IsService )
  )
   (
    WithoutVar:
    (
     'Assert((f_Alien = nil) OR (aValue = nil));' \n
     'f_Alien := aValue;'
    ) 
   ) // Self .Name 'Alien' ==
   
  ( Self .LUID GarantModel::TAbstractTest.GetFolder .LUID == ) // GetFolder
   (
    WithoutVar:
    (
     'Result := ' cQuote l_Implementor .Parent .Name cQuote ';'
    )
   )
  ( Self .LUID GarantModel::TAbstractTest.GetModelElementGUID .LUID == ) // GetModelElementGUID
   (
    WithoutVar:
    (
     'Result := ' cQuote l_Implementor .LUID cQuote ';'
    )
   )
  ( 
   Self .LUID GarantModel::TtfwInteger.GetInteger .LUID == // GetInteger
   AND ( l_Implementor .Parent .IsUserType )
  ) 
   WithoutVar: ( 'Result := ' l_Implementor .Parent .Name ';' )
   
  ( Self .LUID GarantModel::TtfwAxiomaticsResNameGetter.ResName .LUID == ) // ResName
   WithoutVar: ( 'Result := ' cQuote l_Implementor .EffectiveUnitName cQuote ';' )
  ( Self .LUID GarantModel::TtfwRegisterableWord.GetWordNameForRegister .LUID == ) // GetWordNameForRegister
   ( 
    WithoutVar:
    ( 
     'Result := '
     
     cQuote
      
     VAR l_NameForScript
     l_Implementor .NameForScript &gt;&gt;&gt; l_NameForScript
     if ( l_NameForScript .IsValueValid ) then
     begin
     
      ANY FUNCTION Mangle
        IN aValue
       RULES
        ( aValue IsBool )
         RULES
          aValue
           'true'
          DEFAULT
           'false'
         ; // RULES 
        DEFAULT
         aValue
       ; // RULES
       &gt;&gt;&gt; Result
      ; // Mangle
      
      l_NameForScript Mangle
     end // ( l_NameForScript .IsValueValid )  
     else
     begin
      l_Implementor .Parent .GetUP 'extprop:pas:ElementPrefixBase'
      l_Implementor .Name cUnderline ':' string:Replace
     end // ( l_NameForScript .IsValueValid ) 
      
     cQuote 
      
     ';' 
    ) // ( Self .Name 'GetWordNameForRegister' == )
   )
  ( Self .LUID GarantModel::l3UnknownPrim.ClearFields .LUID == ) // ClearFields
   (
    WithoutVar:
    ( 
     l_Implementor .Fields 
     .filter&gt; .IsFieldForCleanup
     .for&gt; (
       IN aField
      aField nil .IfDefPrim: \n
      ( 
       VAR l_FieldName
       
       aField .GetUP 'extprop:clearViaProperty' &gt;&gt;&gt; l_FieldName 
       
       if (
           ( aField .Target .CannotFinalizeProperty )
           OR ( l_FieldName .IsNil ) 
          ) then
       begin
        RULES
         ( 
          ( aField .IsReadonlyProperty ) 
          OR ( aField .Target .CannotFinalizeProperty )
         )
          ( aField .FieldName &gt;&gt;&gt; l_FieldName )
         ( 
          ( aField .IsProperty ) 
          AND ( aField .LinkType lt_agr == )
          AND ( aField .Target .IsWideString )
         )
         // http://mdp.garant.ru/pages/viewpage.action?pageId=594895802&focusedCommentId=620849995#comment-620849995
          ( aField .FieldName &gt;&gt;&gt; l_FieldName )
         ( 
          ( aField .IsProperty ) 
          AND ( aField .ParentIsInterface )
         )
          ( aField .FieldName &gt;&gt;&gt; l_FieldName )
         DEFAULT 
          ( aField .Name &gt;&gt;&gt; l_FieldName )
        ; // RULES  
       end // ( l_FieldName .IsNil )
       
       RULES 
        ( aField .Target .IsInterface )
         ( l_FieldName ' := nil' )
        ( aField .Target .IsString )
         ( l_FieldName ' := ' cQuote cQuote )
        ( aField .Target .IsOpenArray )
         ( l_FieldName ' := nil' )
        DEFAULT
         ( 'Finalize(' l_FieldName ')' )
       ; // RULES 
       ';' \n
      ) // aField .IfDef:
     ) // l_Implementor .Fields
     'inherited;'
    ) 
   )
  DEFAULT
   (
    RULES
     ( Self .IsStaticConstructor )
      begin
       if ( aKey cImplementationUserCodeSuffix == ) then
       begin
        if ( l_Implementor .NeedsFinalize ) then
        begin
         ' Finalize(Result);' .Out
        end // ( l_Implementor .NeedsFinalize )
        ' System.FillChar(Result, SizeOf(Result), 0);' .Out
       end // ( aKey cImplementationUserCodeSuffix == )
      end // ( Self .IsStaticConstructor )
    ; // RULES
    
    Self aKey l_Key aCode .DefaultUserCode 
   )
 ; // RULES 
; // MethodUserCode

BOOLEAN elem_func IsIni
 Self .IsStereotype st_ini::Operation &gt;&gt;&gt; Result
; // IsIni

BOOLEAN elem_func IsFini
 Self .IsStereotype st_fini::Operation &gt;&gt;&gt; Result
; // IsFini

elem: IfDefBrace:
  ^ IN aLambda
 VAR l_WasIf 
 false &gt;&gt;&gt; l_WasIf
 Self nil .IfDefPrim: ( l_WasIf ! ? ( true &gt;&gt;&gt; l_WasIf \n ) )
 (
  aLambda DO
  l_WasIf ? \n
 ) // Self .IfDefPrim:
; // IfDefBrace:

elem: IfDefBraceLn:
  ^ IN aLambda
 VAR l_WasIf 
 false &gt;&gt;&gt; l_WasIf
 Self nil .IfDefPrim: ( 
  true &gt;&gt;&gt; l_WasIf 
  \n 
 )
 (
  aLambda DO
  l_WasIf ? \n
 ) // Self .IfDefPrim:
; // IfDefBraceLn:

elem: IfDefBraceLnBefore:
  ^ IN aLambda
 VAR l_WasIf 
 false &gt;&gt;&gt; l_WasIf
 Self nil .IfDefPrim: ( 
  \n 
  l_WasIf ! ? SWAP
  true &gt;&gt;&gt; l_WasIf
 )
 (
  aLambda DO
  l_WasIf ? \n
 ) // Self .IfDefPrim:
; // IfDefBraceLnBefore:

BOOLEAN elem_func IsClassRef
 Self .UPisTrue "isClassRef"
 &gt;&gt;&gt; Result
; // IsClassRef

ARRAY STRING TYPE ArrayOrString

STRING elem_func TypeInfo
 RULES
  ( Self .IsNil )
   '@tfw_tiVoid'
  ( Self .TypeName 'Tl3PCharLen' == )
   '@tfw_tiWString'
  ( Self .IsString )
   '@tfw_tiString'
  ( Self .TypeName 'Il3CString' == )
   '@tfw_tiString'
  ( Self .TypeName 'Tl3WString' == )
   '@tfw_tiString'
  ( Self .TypeName 'Tl3PCharLenPrim' == )
   '@tfw_tiString'
  ( Self .IsRecord )
   '@tfw_tiStruct'
  ( Self .IsClassRef ) 
   '@tfw_tiClassRef'
  DEFAULT
   ( [ 'TypeInfo(' Self .TypeName ')' ] strings:Cat )
 ; // RULES
 &gt;&gt;&gt; Result 
; // TypeInfo 

STRING elem_func PopSig
 RULES
  ( Self .TypeName 'TClass' == )
   'PopClass'
  ( Self .TypeName 'TtfwStackValue' == )
   'Pop'
  ( Self .TypeName 'TClass' == )
   'PopClass'
  ( Self .TypeName 'ItfwValueList' == )
   'PopList'
  ( Self .TypeName 'ItfwFile' == )
   'PopFile'
  ( Self .IsClassRef )
   ( [ 'PopClassAs(' Self .TypeName ')' ] strings:Cat )
  ( Self .TypeName 'Tl3WString' == )
   'PopWStr'
  ( Self .TypeName 'Tl3PCharLenPrim' == )
   'PopWStr'
  ( Self .TypeName 'Tl3PCharLen' == )
   'PopWStr'
  ( Self .TypeName 'Il3CString' == )
   'PopString'
  ( Self .IsSimpleClass )
   ( [ 'PopObjAs(' Self .TypeName ')' ] strings:Cat )
  ( Self .IsInterface )
   ( [ 'PopIntf(' Self .TypeName ')' ] strings:Cat )
  ( Self .TypeName 'String' == )
   'PopDelphiString'
  ( Self .TypeName 'Char' == )
   'PopChar'
  ( Self .TypeName 'AnsiChar' == )
   'PopChar'
  ( Self .TypeName 'TPoint' == )
   'PopPoint'
  ( Self .TypeName 'WideString' == )
   'PopWideString'
  ( Self .TypeName 'AnsiString' == )
   'PopDelphiString'
  ( Self .TypeName 'Integer' == )
   'PopInt'
  ( Self .TypeName 'TColor' == )
   'PopInt'
  ( Self .TypeName 'Cardinal' == )
   'PopInt'
  ( Self .IsEnum )
   'PopInt'
  ( Self .TypeName 'THandle' == )
   'PopInt'
  ( Self .TypeName 'Boolean' == )
   'PopBool'
  ( Self .IsTypedef )
   ( Self .MainAncestor call.me ) 
  DEFAULT 
   ( [ 'Не знаем как снять со стека : ' Self .TypeName ] strings:Cat )
 ; // RULES
 &gt;&gt;&gt; Result  
; // PopSig

STRING elem_func PushType
 RULES
  ( Self .TypeName 'ItfwValueList' == )
   ''
  ( Self .TypeName 'ItfwFile' == )
   ''
  ( Self .TypeName 'Il3CString' == )
   ''
  ( Self .IsInterface )
   ( [ ', ' 'TypeInfo(' Self .TypeName ')' ] strings:Cat )
  DEFAULT
  ''
 ; // RULES
 &gt;&gt;&gt; Result
; // PushType

STRING elem_func PushSig
 RULES
  ( Self .IsNil )
   ''
  ( Self .TypeName 'TClass' == )
   'PushClass'
  ( Self .TypeName 'TtfwStackValue' == )
   'Push'
  ( Self .TypeName 'TClass' == )
   'PushClass'
  ( Self .TypeName 'ItfwValueList' == )
   'PushList'
  ( Self .TypeName 'ItfwFile' == )
   'PushFile'
  ( Self .IsClassRef )
   'PushClass'
  ( Self .TypeName 'Tl3WString' == )
   'PushString'
  ( Self .TypeName 'Tl3PCharLenPrim' == )
   'PushString'
  ( Self .TypeName 'Tl3PCharLen' == )
   'PushWStr'
  ( Self .TypeName 'Il3CString' == )
   'PushString'
  ( Self .IsSimpleClass )
   'PushObj'
  ( Self .IsInterface )
   'PushIntf'
  ( Self .TypeName 'String' == )
   'PushString'
  ( Self .TypeName 'Char' == )
   'PushChar'
  ( Self .TypeName 'AnsiChar' == )
   'PushChar'
  ( Self .TypeName 'TPoint' == )
   'PushPoint'
  ( Self .TypeName 'WideString' == )
   'PushWideString'
  ( Self .TypeName 'AnsiString' == )
   'PushString'
  ( Self .TypeName 'Integer' == )
   'PushInt'
  ( Self .TypeName 'TColor' == )
   'PushInt'
  ( Self .TypeName 'Cardinal' == )
   'PushInt'
  ( Self .IsEnum )
   'PushInt'
  ( Self .TypeName 'THandle' == )
   'PushInt'
  ( Self .TypeName 'Boolean' == )
   'PushBool'
  ( Self .IsTypedef )
   ( Self .MainAncestor call.me ) 
  DEFAULT 
   ( [ 'Не знаем как положить на стек: ' Self .TypeName ] strings:Cat )
 ; // RULES
 &gt;&gt;&gt; Result  
; // PushSig

STRING elem_func CastSig
 RULES
  ( Self .TypeName 'ItfwValueList' == )
   ''
  ( Self .TypeName 'ItfwFile' == )
   ''
  ( Self .IsClassRef )
   ( Self .TypeName )
  ( Self .TypeName 'Tl3PCharLen' == )
   ( Self .TypeName )
  ( Self .IsSimpleClass ) 
   ( Self .TypeName )
  ( Self .IsInterface ) 
   ( Self .TypeName )
  ( Self .TypeName 'TColor' == )
   ( Self .TypeName )
  ( Self .TypeName 'Cardinal' == )
   ( Self .TypeName )
  ( Self .IsEnum )
   ( Self .TypeName )
  ( Self .TypeName 'THandle' == )
   ( Self .TypeName )
  ( Self .IsTypedef )
   ( Self .MainAncestor call.me ) 
  DEFAULT
   ''
 ; // RULES
 &gt;&gt;&gt; Result  
; // CastSig

STRING elem_func TypeValue
 RULES
  ( Self .TypeName 'TtfwStackValue' == )
   ''
  ( Self .IsSimpleClass ) 
   ( [ '.AsObject(' Self .TypeName ')' ] strings:Cat ) 
  ( Self .TypeName 'Integer' == )
   '.AsInt'
  ( Self .TypeName 'TColor' == )
   '.AsInt'
  ( Self .TypeName 'Cardinal' == )
   '.AsInt'
  ( Self .IsEnum )
   '.AsInt'
  ( Self .TypeName 'String' == )
   '.AsDelphiString'
  ( Self .TypeName 'AnsiString' == )
   '.AsDelphiString'
  ( Self .TypeName 'Char' == )
   '.AsChar'
  ( Self .TypeName 'AnsiChar' == )
   '.AsChar'
  ( Self .TypeName 'Boolean' == )
   '.AsBoolean'
  ( Self .IsTypedef )
   ( Self .MainAncestor call.me ) 
  DEFAULT
   ( [ 'Не знаем как приводить значение типа ' Self .TypeName ] strings:Cat )
 ; // RULES
 &gt;&gt;&gt; Result  
; // TypeValue

STRING elem_func UnCastSig
 RULES
  ( Self .TypeName 'TColor' == )
   'Integer'
  ( Self .TypeName 'Cardinal' == )
   'Integer'
  ( Self .IsEnum )
   'Ord'
  ( Self .TypeName 'THandle' == )
   'Integer'
  ( Self .IsTypedef )
   ( Self .MainAncestor call.me ) 
  DEFAULT
   ''
 ; // RULES
 &gt;&gt;&gt; Result  
; // UnCastSig

elem_iterator BindServiceImplementationUC
 [
  Self .ImplementsInDependencies
  .for&gt; (
    IN anItem
   anItem .IfDefBrace:
   (
    cSpace anItem .TypeName '.Instance.Alien := ' Self .TypeName '.Instance;'
   ) // anItem .IfDefBrace:
  ) // Self .ImplementsInDependencies
 ]
 &gt;&gt;&gt; Result
; // BindServiceImplementationUC

elem_iterator RegAxiomUC
 [ cSpace Self .TypeName '.Register;' ]
 &gt;&gt;&gt; Result
; // RegAxiomUC

BOOLEAN elem_func IsCustomChoice
 Self .IsStereotype st_CustomChoice::Attribute
 &gt;&gt;&gt; Result
; // IsCustomChoice

BOOLEAN elem_func IsDefaultChoice
 Self .IsStereotype st_DefaultChoice::Attribute
 &gt;&gt;&gt; Result
; // IsDefaultChoice

elem_iterator AdditionalInitCode
  STRING IN aName
  
 STRING elem_func ChoiceName 
  [
   aName
   //%C%f_pas_Prefix()%C#f_AdditionalPrefix()
   '_Choice_'
   Self .Name
  ] strings:Cat 
  &gt;&gt;&gt; Result
 ; // ChoiceName
 
 [
 Self .ChildrenExPrim
 .filter&gt; .IsChoices
 .for&gt; (
   IN aChoices
  aChoices .ChildrenExPrim
  .filter&gt; .IsChoice
  .for&gt; (
    IN aChoice
   \n ' ' aName '.AddChoice(' aChoice .ChoiceName ');'
  ) // .for&gt;
 ) // .for&gt;
 
 Self .Attributes
 .filter&gt; .IsCustomChoice
 .for&gt; (
   IN aChoice
  \n ' ' aName '.AddCustomChoice(' aChoice .Target .ChoiceName ');'
 ) // .for&gt; 
 
 Self .Attributes
 .filter&gt; .IsDefaultChoice
 .for&gt; (
   IN aChoice
  \n ' ' aName '.AddDefaultChoice(' aChoice .Target .ChoiceName ');'
 ) // .for&gt; 
 
 if ( Self .UPisTrue "NeedCheck" ) then
 begin
  \n ' ' aName '.SetNeedCheck(true);'
 end // ( Self .UPisTrue "NeedCheck" )
 
 VAR l_Value
 Self .GetUP "CheckCaption" &gt;&gt;&gt; l_Value
 if ( l_Value .IsNotNil ) then
 begin
  \n ' ' aName '.SetCheckCaption(str_' Self .Name '_CheckCaption);'
 end // ( l_Value .IsNotNil )
 
 Self .GetUP "SettingsCaption" &gt;&gt;&gt; l_Value
 if ( l_Value .IsNotNil ) then
 begin
  \n ' ' aName '.SetSettingsCaption(str_' Self .Name '_SettingsCaption);'
 end // ( l_Value .IsNotNil )
 
 Self .GetUP "LongHint" &gt;&gt;&gt; l_Value
 if ( l_Value .IsNotNil ) then
 begin
  \n ' ' aName '.SetLongHint(str_' Self .Name '_LongHint);'
 end // ( l_Value .IsNotNil )
 
 \n ' ' aName '.SetDlgType(' 'mt' Self .GetUP "DlgType" ');'
 ]
 &gt;&gt;&gt; Result
; // AdditionalInitCode

PRINTABLE elem_func InitStrUCPrim
  ModelElement IN aSpeller
 [
  VAR l_Name
  [ Self .Parent .GetUP 'extprop:pas:ElementPrefix' Self .Name ] strings:Cat &gt;&gt;&gt; l_Name
  
  ' ' l_Name '.Init;'
  
  if ( aSpeller .IsMessage ) then
  begin
   aSpeller l_Name .AdditionalInitCode
  end // ( aSpeller .IsMessage )
 ]
 &gt;&gt;&gt; Result
; // InitStrUCPrim
        
PRINTABLE elem_func InitStrUC
 Self .SpelledFor Self .Speller .InitStrUCPrim
 &gt;&gt;&gt; Result
; // InitStrUC

PRINTABLE elem_func GetUserCode
  STRING IN aKey
 RULES
  ( 
   Self .IsIni
   AND ( Self .IsSummoned )
  )
   (
    VAR l_Parent
    Self .Parent &gt;&gt;&gt; l_Parent
    RULES
     ( l_Parent .IsServiceImplementation )
      ( l_Parent .BindServiceImplementationUC )
     ( Self .Name 'Ini_Reg' == ) 
      [ cSpace l_Parent .TypeName '.RegisterInEngine;' ]
     ( Self .Name 'RegAxiom' == ) 
      ( l_Parent .RegAxiomUC )
     ( Self .Name 'Ini_Reg_Class' == ) 
      [ 
       if ( l_Parent GarantModel::TtfwWord .InheritsFrom ) then
       begin
        ' ' l_Parent .TypeName '.RegisterClass;'
       end
       else
       begin
        ' TtfwClassRef.Register(' l_Parent .TypeName ');' 
       end 
      ] 
     ( 
      ( 'Init_Str_' Self .Name StartsStr ) 
      AND ( Self .SpelledFor .IsNotNil )
     )
      ( Self .InitStrUC )
     ( 
      ( 'Ini_FormFactory_' Self .Name StartsStr ) 
      AND ( Self .SpelledFor .IsNotNil )
     )
      [
       VAR l_SpelledFor
       Self .SpelledFor &gt;&gt;&gt; l_SpelledFor
       ' ' 'fm_' l_SpelledFor .TypeName .CutT '.SetFactory(' l_SpelledFor .TypeName '.Make);'  
      ]
     ( 
      ( 'Reg_Type_' Self .Name StartsStr ) 
      AND ( Self .SpelledFor .IsNotNil )
     )
      [
       VAR l_SpelledFor
       Self .SpelledFor &gt;&gt;&gt; l_SpelledFor
       ' TtfwTypeRegistrator.RegisterType('
       
       l_SpelledFor .TypeInfo
       
       ');'
      ] 
     DEFAULT
      '!!! Lost ini !!!'
    ; // RULES  
   )
  ( 
   Self .IsFini
   AND ( Self .IsSummoned )
  )
   '!!! Lost fini !!!'
  DEFAULT
   ( Self aKey cEmptyStr .ElemMember )
 ; // RULES
 &gt;&gt;&gt; Result
; // GetUserCode

BOOLEAN elem_func IsConstructorsHolder
 ( Self .MainAncestor .IsNotNil )
 AND ( Self .Attributes .IsEmpty )
 AND ( Self .OperationsEx .filter&gt; ( .IsConstructor ! ) .IsEmpty )
 &gt;&gt;&gt; Result
; // IsConstructorsHolder

ModelElement elem_func MethodType
 Cached:
 (
  RULES
   ( Self .InTie )
    RULES
     ( Self .Target .TypeName 'Boolean' == )
      GarantModel::ByteBool
     DEFAULT
      ( Self .Target )
    ; // RULES
   ( Self .IsFormFactory )
    GarantModel::IvcmEntityForm
   (
    ( Self .IsFactory )
    AND ( Self .Parent .IsVCMForm )
   )  
    GarantModel::IvcmEntityForm
   ( Self .IsInternalOperation )
    RULES
     ( Self .OpModify opModifyExecute == )
      ( Self .Target )
     DEFAULT
      nil 
    ; // RULES 
   ( Self .IsVCMOperationPrim )
     nil
   ( Self .IsIterator )
    (
     RULES
      ( Self .MainAncestor .IsNotNil )
       ( Self .MainAncestor call.me )
      ( Self .UPisTrue "needs result" ) 
       (
        VAR l_Type
        Self .Attributes 
        .filter&gt; .IsResultType
        .mapToTarget&gt;
        .FirstElement &gt;&gt;&gt; l_Type
        RULES
         ( l_Type .IsNotNil )
          l_Type
         DEFAULT
          GarantModel::Integer
        ; // RULES  
       ) 
      DEFAULT
       nil
     ; // RULES 
    )
   ( Self .IsStaticConstructor )
    if ( Self .Parent .IsConstructorsHolder ) then
     ( Self .Parent .MainAncestor )
    else
     ( Self .Parent )
   ( Self .IsControlOverride )
    ( Self .MainAncestor call.me ) 
   ( Self .IsControlPrim )
    ( Self .MainAncestor ) 
   ( Self .IsArea )
    ( Self .MainAncestor )
   ( Self .IsConstructor ) 
    nil
   ( Self .IsMethod )
    RULES
     ( Self .ImplementsIterator )
      ( Self .MainImplements call.me )
     ( Self .MainAncestor .IsNotNil ) 
      ( Self .MainAncestor call.me )
     DEFAULT
      ( Self .FirstOperation .Target )
    ; // RULES  
   ( Self .IsFunction )
    ( Self .FirstOperation .Target )
   DEFAULT 
    ( Self .Target )
  ; // RULES
  VAR l_Type
  &gt;&gt;&gt; l_Type
  RULES 
   ( l_Type .IsNil )
   begin
    RULES
     ( Self .IsStereotype st_factory::Operation )
      ( Self .Parent .MainImplementsInterface )
     ( Self .IsFactoryMethod )
      ( Self .MainImplementsInterface )
     DEFAULT
      l_Type
    ; // RULES
   end // ( l_Type .IsNil )
   DEFAULT
    l_Type
  ; // RULES
  &gt;&gt;&gt; l_Type
  RULES 
   ( l_Type .IsNil )
   begin
    RULES
     ( Self .IsStereotype st_factory::Operation )
      nil
      //( 'BadFactoryType' )
     ( Self .IsFactoryMethod )
      ( Self .Parent .MainImplementsInterface )
     DEFAULT
      l_Type
    ; // RULES
   end // ( l_Type .IsNil )
   DEFAULT
    l_Type
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // MethodType

BOOLEAN elem_func InheritsOrImplementsAcceptableForScripts
 Cached:
 (
  RULES
   ( Self .InheritsEx .filter&gt; .IsAcceptableForScripts .NotEmpty )
    true
   ( Self .ImplementsEx .filter&gt; .IsAcceptableForScripts .NotEmpty )
    true
   DEFAULT
    false
  ; // RULES 
 )
 &gt;&gt;&gt; Result
; // InheritsOrImplementsAcceptableForScripts

BOOLEAN elem_func HasSelf
 RULES
  ( Self .Parent .InheritsOrImplementsAcceptableForScripts ! )
   false
  ( Self .IsCreator )
   false
  ( Self .IsKeyWord )
   true
  DEFAULT
   false
 ; // RULES
 &gt;&gt;&gt; Result
; // HasSelf

BOOLEAN elem_func IsOutParam
 Self .IsStereotype st_out &gt;&gt;&gt; Result
; // IsOutParam

ARRAY FUNCTION .filterOutParam&gt;
  ARRAY IN anArray
 anArray
 .filter&gt; ( .IsOutParam ! ) 
 &gt;&gt;&gt; Result
; // .filterOutParam&gt;

STRING FUNCTION .UpperFirstChar
  STRING IN aSubstr
 RULES
  ( aSubstr .IsNil )
   ''
  DEFAULT
   begin
   [ 
    1 0 aSubstr string:Substring string:Upper
    VAR l_Len
    aSubstr string:Len 1 - &gt;&gt;&gt; l_Len
    l_Len &lt; 0 ?FAIL 'l_Len &lt; 0'
    if ( l_Len &gt; 0 ) then
    begin
     VAR l_Tail
     l_Len
      1 aSubstr string:Substring &gt;&gt;&gt; l_Tail
     l_Tail .IsNil ?FAIL 'l_Tail .IsNil'
     l_Tail  
    end // ( l_Len &gt; 0 )
   ] strings:Cat 
  end // DEFAULT
 ; // RULES 
 &gt;&gt;&gt; Result 
; // .UpperFirstChar

STRING FUNCTION .FromTie
  STRING IN aValue
 '' &gt;&gt;&gt; Result
 if ( aValue .IsNotNil ) then
 begin
  aValue cUnderline string:Split:for&gt; ( 
    IN aSubstr
   aSubstr .IsNil ?FAIL 'aSubstr .IsNil' 
   [ 
    Result 
    aSubstr .UpperFirstChar
   ] strings:Cat &gt;&gt;&gt; Result 
  ) // aValue cUnderline string:Split:for&gt;
 end // ( aValue .IsNotNil )
; // .FromTie
 
STRING FUNCTION .ToBorland
  STRING IN aValue
 '' &gt;&gt;&gt; Result
 aValue cUnderline string:Split:for&gt; ( 
   IN aSubstr
/*{  if ( aSubstr .IsNil ) then 
  begin
   Result cUnderline Cat &gt;&gt;&gt; Result
  end 
  else}*/
  begin
   Result aSubstr Cat &gt;&gt;&gt; Result
  end 
 )
; // .ToBorland

STRING elem_func MethodName

 STRING elem_func FineName
  Self .Name '__' cUnderline string:Replace
  &gt;&gt;&gt; Result
 ; // FineName

 Cached:
 (
  RULES
   ( Self .IsNil )
    ''
   ( Self .InTie )
    ( Self .Name .FromTie )
   ( Self .IsModuleOperationPrim ) 
    RULES
     ( Self .IsTester )
      ( [ //if ( Self .UPisTrue "no prefix" ! ) then 
           'op' 
          Self .Name 'Test' ] strings:Cat )
     ( Self .IsExecutor )
      ( [ //if ( Self .UPisTrue "no prefix" ! ) then 
           'op' 
          Self .Name 'Execute' ] strings:Cat )
     DEFAULT
      ( Self .Name ) 
    ; // RULES  
   ( Self .IsVCMOperationPrim )
    RULES
     ( Self .IsTester )
      ( [ Self .Parent .Name cUnderline Self .Name '_Test' ] strings:Cat )
     ( Self .IsExecutor )
      ( [ Self .Parent .Name cUnderline Self .Name '_Execute' ] strings:Cat )
     ( Self .IsGetState )
      ( [ Self .Parent .Name cUnderline Self .Name '_GetState' ] strings:Cat )
     DEFAULT
      ( [ Self .Parent .Name cUnderline Self .Name ] strings:Cat )
    ; // RULES 
   ( Self .IsIterator )
    (
     RULES
      ( Self .IsIteratorF )
       ( Self .Name 'F' Cat )
      ( Self .MainAncestor .IsNotNil )
       ( Self .MainAncestor call.me )
      DEFAULT
       ( Self .Name )
     ; // RULES
    ) // ( Self .IsIterator )
   ( Self .IsStaticConstructor )
    if ( Self .Parent .IsConstructorsHolder ) then
     ( [ Self .Parent .MainAncestor .TypeName cUnderline Self .Name ] strings:Cat )
    else
     ( [ Self .Parent .TypeName cUnderline Self .Name ] strings:Cat )
   ( Self .UPisTrue 'extprop:isGlobal' )
    ( Self .Name .ToBorland )
    
   ( Self .Parent .IsUtilityPack ) 
    ( 
      VAR l_Prefix
      Self .Parent .GetUP 'extprop:pas:ElementPrefixBase' &gt;&gt;&gt; l_Prefix
      if ( l_Prefix .IsNil ) then
      begin
       Self .Parent .GetUP 'extprop:pas:ElementPrefix' &gt;&gt;&gt; l_Prefix
      end // ( l_Prefix .IsNil )
      l_Prefix Self .FineName Cat 
    )
   ( Self .IsMethodAndImplementsIterator )
    RULES
     ( Self .IsIteratorF )
      ( Self .MainImplements call.me 'F' Cat )
     DEFAULT
      ( Self .MainImplements call.me )
    ; // RULES  
   ( '__' Self .Name StartsStr ) 
    ( Self .FineName )
   ( 'Обработчик события' Self .Documentation StartsStr )
    ( Self .Name .FromTie )
   ( '_NeedMakeForm' Self .Name EndsStr )
    ( Self .Name .FromTie )
   ( 'GetFormCount' Self .Name EndsStr )
    ( Self .Name .FromTie )
   ( Self .Parent .IsUseCaseController )
    ( Self .Name .FromTie )
   ( Self .Parent .Parent .IsControllerInterfaces ) 
    ( Self .Name .FromTie )
   DEFAULT
    ( Self .FineName )
  ; // RULES 
 )
 &gt;&gt;&gt; Result
; // MethodName

BOOLEAN elem_func NeedAfterCreate
 RULES
  ( Self .GetUP "need AfterCreate" false ?== )
   false
  ( Self .IsFactoryMethod )
   ( Self .FirstOperation .Parameters .NotEmpty )
  DEFAULT
   ( Self .Parameters .NotEmpty )
 ; // RULES
 &gt;&gt;&gt; Result
; // NeedAfterCreate

elem_proc UserCode:
 ^ IN aSuffix
 ^ IN aCode
 
 STRING VAR l_Key
 
 aSuffix DO &gt;&gt;&gt; l_Key
 
 VAR l_Code
 Self 
  [ cUserCodePrefix Self .MethodUserCodeModifier l_Key ] strings:Cat 
  .GetUserCode &gt;&gt;&gt; l_Code
 
 if ( l_Code .IsValueValid ) then
 begin
  if ( l_Code cEmptyUserCode ?!= ) then
  begin
   l_Code .Out
  end // ( l_Code cEmptyUserCode ?!= )
 end // ( l_Code .IsValueValid )
 else
 begin
 
  : AsDefault
   Self l_Key l_Key aCode .DefaultUserCode
  ; // AsDefault
  
  : AsMethod
   Self l_Key aCode .MethodUserCode
  ; // AsMethod
  
  VAR l_Implementor
  Self .ImplementorOrParent &gt;&gt;&gt; l_Implementor
  
  BOOLEAN FUNCTION IsUID
    STRING IN anUID
   ( Self .LUID anUID == ) 
   AND ( l_Implementor .IsSummoned ) &gt;&gt;&gt; Result
  ; // IsUID
  
  : Pair:
    ^ IN aVar
    ^ IN aCode
   RULES
    ( l_Key cVarUserCodeSuffix == )
     ( aVar DO )
    ( l_Key cImplementationUserCodeSuffix == )
     ( aCode DO )
    DEFAULT
     AsDefault 
   ; // RULES
  ; // Pair:
  
  : Code:
    ^ IN aCode
   Pair: () ( aCode DO )
  ; // Code:
  
  VAR l_Call
  // - метод, который собственно надо звать из DoDoIt или DoRun.
  l_Implementor .KeywordImplementationMethod &gt;&gt;&gt; l_Call
  
  VAR l_Op
  l_Implementor .KeywordOperation &gt;&gt;&gt; l_Op
  
  VAR l_Self
  l_Implementor .KeywordObjectToOperate &gt;&gt;&gt; l_Self
  
  elem_iterator ParametersWithoutContext
   Self .Parameters
   .filter&gt; ( 'aCtx' .HasName ! )
   &gt;&gt;&gt; Result
  ; // ParametersWithoutContext
  
  : .AsVar
    STRING IN aName
    ModelElement IN aType
   'var' cSpace 'l_' aName ': ' aType .TypeName ';' 
  ; // .AsVar
  
  elem: ParamAsVar
   Self .Name Self .Target .AsVar
  ; // ParamAsVar
  
  : .Pop
    STRING IN aName
    ModelElement IN aType
   'try' \n
   
   ' ' 'l_' aName 
   ' := ' 
   
   VAR l_CastSig
   aType .CastSig &gt;&gt;&gt; l_CastSig
   
   if ( l_CastSig .IsNotNil ) then
   begin
    l_CastSig '('
   end
   
   'aCtx.rEngine.' aType .PopSig
   
   if ( l_CastSig .IsNotNil ) then
   begin
    ')'
   end
   
   ';' \n
   
   'except' \n 
   ' on E: Exception do' \n
   ' begin' \n
   '  RunnerError(''Ошибка при получении параметра ' aName ': ' aType .TypeName ' : '' + E.Message, aCtx);' \n
   '  Exit;' \n
   ' end;//on E: Exception' \n
   'end;//try..except' \n
  ; // .Pop
  
  elem: ParamPop
   Self .Name Self .Target .Pop
  ; // ParamPop
  
  RULES
   (
    ( Self .IsInternalOperation )
    AND ( Self .OpModify opModifyNone == )
   ) 
    Code: (
     Indented: ( 
      [ 
       if ( 
           ( Self .Target .IsNotNil )
           OR ( Self .Parameters .NotEmpty )
          ) then
       begin
        'with ' 'I' Self .Parent .Name cUnderline Self .Name '_Params' '(aParams.Data' ') do' \n ' '
       end // ( Self .Target .IsNotNil ) ..
       if ( Self .Target .IsNotNil ) then
       begin
        'ResultValue := '
       end // ( Self .Target .IsNotNil )
       'Self.' Self .MethodName '_Execute' Self .Parameters .map&gt; ( .Name 'a' .CutPrefix ) .CommaListWith() ';'
      ] .Out 
     ) 
    )
   (
    ( Self .LUID GarantModel::TtfwWord.IsImmediate .LUID == ) // IsImmediate
    AND ( l_Implementor .GetUP "is immediate" IsBool )
   ) 
    Code: ( [ ' Result := ' l_Implementor .GetUP "is immediate" ';' ] .Out )
    
   ( 
    ( l_Op .IsNotNil )
    AND ( GarantModel::TtfwCompilingWord.SuppressNextImmediate .LUID IsUID ) // SuppressNextImmediate
   ) 
    Code: ( [ ' Result := ' 'tfw_sni' l_Op .GetUP "SupressNextImmediate" ';' ] .Out )
    
   ( 
    ( l_Op .IsNotNil )  
    AND ( GarantModel::TtfwString.GetString .LUID IsUID ) // GetString
   )
    Code: 
      (
       if ( 'Слово словаря для идентификатора контрола' l_Implementor .Documentation StartsStr ) then
       begin
        [ ' Result := ' cQuote l_Op .Name cQuote ';' ] .Out 
       end
       else
       begin
        [ ' Result := ' cQuote l_Op .TypeName .CutT cQuote ';' ] .Out 
       end 
      )
    
   (
    ( l_Op .IsNotNil )
    AND ( l_Self .IsNotNil )
    AND ( GarantModel::TtfwWord.SetValuePrim .LUID IsUID ) // SetValuePrim
   ) 
     Pair:
       (
        if ( l_Op .GetUP 'extprop:prop_stereo' 'readonly' != ) then
        begin
         if ( l_Self .IsNotNil ) then
         begin
          [ l_Self .SelfName l_Self .AsVar ] .Out
         end // ( l_Self .IsNotNil )
         
         l_Op .Parameters 
         .filterOutParam&gt;
         .for&gt; (
           IN aParam
          [ aParam .ParamAsVar ] .Out 
         ) // .for&gt;
        end // ( l_Op .GetUP 'extprop:prop_stereo' 'readonly' != )
       )
       (
        if ( l_Op .GetUP 'extprop:prop_stereo' 'readonly' == ) then
        begin
         [
          ' RunnerError(''Нельзя присваивать значение readonly свойству '
          l_Op .GetUP 'extprop:prop_name'
          ''', aCtx);'
         ] .Out
        end // ( l_Op .GetUP 'extprop:prop_stereo' 'readonly' == )
        else
        begin
         Indented:
         (
          [
           if ( l_Self .IsNotNil ) then
           begin
            l_Self .SelfName l_Self .Pop
           end // ( l_Self .IsNotNil )
           
           l_Op .Parameters 
           .filterOutParam&gt;
           .for&gt; (
             IN aParam
            aParam .ParamPop
           ) // .for&gt;
           
           if ( l_Self .IsNotNil ) then
           begin
            if ( l_Op .UPisTrue "mapped" ) then
            begin
             'l_' l_Self .SelfName
             cDot
             l_Op .GetUP 'extprop:prop_name'
             ' := '
             
             VAR l_CastSig
             l_Op .Target .CastSig &gt;&gt;&gt; l_CastSig
             
             if ( l_CastSig .IsNotNil ) then
             begin
              l_CastSig '('
             end
             
             'aValue' l_Op .Target .TypeValue
             
             if ( l_CastSig .IsNotNil ) then
              ')'
            end // ( l_Op .UPisTrue "mapped" )
            else
            begin
             'DoSetValue' 
             '('
             'l_' l_Self .SelfName
             
             l_Op .Parameters 
             .filterOutParam&gt;
             .for&gt; (
               IN aParam
             ', '
             'l_'
              aParam .Name
             ) // .for&gt;
             
             ', '
             
             VAR l_CastSig
             l_Op .Target .CastSig &gt;&gt;&gt; l_CastSig
             
             if ( l_CastSig .IsNotNil ) then
             begin
              l_CastSig '('
             end
             
             'aValue' l_Op .Target .TypeValue
             
             if ( l_CastSig .IsNotNil ) then
              ')'
              
             ')'
            end
            ';'
           end // ( l_Self .IsNotNil )
          ] .Out
         ) // Indented:
        end // ( l_Op .GetUP 'extprop:prop_stereo' 'readonly' == )
       )
       
   (
    ( l_Call .IsNotNil )
    AND 
    (
     ( GarantModel::TtfwWordPrim.DoDoIt .LUID IsUID ) // DoDoIt
     OR ( GarantModel::TtfwAnonimousWord.DoRun .LUID IsUID ) // DoRun
    ) 
   )
     Pair:
       (
        l_Call .ParametersWithoutContext
        .for&gt; (
          IN aParam
         [ aParam .ParamAsVar ] .Out
        ) // .for&gt;
       )
       (
        Indented:
        (
         [
          l_Call .ParametersWithoutContext
          .filterOutParam&gt;
          .for&gt; (
            IN aParam
           aParam .ParamPop 
          ) // .for&gt;
          
          VAR l_PushSig
          l_Call .Target .PushSig &gt;&gt;&gt; l_PushSig
          
          VAR l_UnCastSig
          '' &gt;&gt;&gt; l_UnCastSig
          
          if ( l_PushSig .IsNotNil ) then
          begin
           'aCtx.rEngine.' l_PushSig '('
           l_Call .Target .UnCastSig &gt;&gt;&gt; l_UnCastSig
           
           if ( l_UnCastSig .IsNotNil ) then
           begin
            l_UnCastSig '('
           end // ( l_UnCastSig .IsNotNil )
          end
          
          l_Call .MethodName 
          '(' 
          'aCtx' 
          l_Call .ParametersWithoutContext
          .for&gt; (
            IN aParam
           ', ' 'l_' aParam .Name
          ) // .for&gt;  
          ')'
          
          if ( l_PushSig .IsNotNil ) then
          begin
           if ( l_UnCastSig .IsNotNil ) then
           begin
            ')'
           end // ( l_UnCastSig .IsNotNil )
           l_Call .Target .PushType
           ')'
          end
          
          ';'
          
          l_Call .ParametersWithoutContext
          .filter&gt; .IsOutParam
          .reverted&gt; 
          .for&gt; (
            IN aParam
           \n 
           'aCtx.rEngine.' 
           aParam .Target .PushSig 
           '(' 
           'l_' aParam .Name 
           aParam .Target .PushType
           ')'
           ';'
          ) // .for&gt;
            
         ] .Out
        ) // Indented:
       )
   
   ( 
    ( l_Op .IsNotNil )
    AND ( GarantModel::TtfwRegisterableWordPrim.RegisterInEngine .LUID IsUID ) // RegisterInEngine
   ) 
     Code:
       (
        [
         ' inherited;' \n
         ' TtfwClassRef.Register(' 
         if ( l_Op .IsControlPrim ) then
         begin
          l_Op .MethodType .TypeName
         end // ( l_Op .IsControlPrim )
         else
         begin
          l_Op .TypeName
         end // ( l_Op .IsControlPrim )
         ')' ';'
        ] .Out
       )
   
   ( 
    ( l_Op .IsNotNil )
    AND ( GarantModel::TtfwWordPrim.DoDoIt .LUID IsUID ) // DoDoIt
    AND ( l_Implementor GarantModel::TkwBynameControlPush .InheritsFrom )
   ) 
     Code:
       (
        [
         ' aCtx.rEngine.PushString(' cQuote l_Op .Name cQuote ')' ';' \n
         ' inherited;'
        ] .Out
       )
   
   ( GarantModel::TtfwWord.ParamsTypes .LUID IsUID ) // ParamsTypes
     Code:
       ( 
        VAR l_NeedComma
        false &gt;&gt;&gt; l_NeedComma
        [ 
         ' Result := '
         'OpenTypesToTypes'
         '('
         '['
         if ( l_Self .IsNil ) then
          [empty]
         else
          [ l_Self ]
         .join&gt;  
         (
          l_Op .Parameters 
          .filterOutParam&gt;
          .mapToTarget&gt;
         ) // .join&gt;
         .map&gt; .TypeInfo
         .for&gt; (
          .WithComma: l_NeedComma .KeepInStack
         )
         ']'
         ')'
         ';' 
        ] .Out 
       ) // ( l_Key cImplementationUserCodeSuffix == )
   ( GarantModel::TtfwWord.GetResultTypeInfo .LUID IsUID ) // GetResultTypeInfo
     Code:
       ( 
        [ 
         ' Result := '
         if ( l_Op .IsCreator ) then
         begin
          l_Self .TypeInfo
         end // ( l_Op .IsCreator )
         else
         begin
          l_Op .Target .TypeInfo
         end // ( l_Op .IsCreator )
         ';' 
        ] .Out 
       ) // ( l_Key cImplementationUserCodeSuffix == )
   ( GarantModel::TtfwWord.GetAllParamsCount .LUID IsUID ) // GetAllParamsCount
     Code:
       ( 
        [ 
         ' Result := '
         l_Op .Parameters 
         .filterOutParam&gt;
         .CountIt
         l_Op .HasSelf ? ( 1 + )
         l_Op .IsVarWorker ? ( 1 + )
         ';' 
        ] .Out 
       ) // ( l_Key cImplementationUserCodeSuffix == )
   ( GarantModel::TtfwWord.RightParamsCount .LUID IsUID ) // RightParamsCount
     Code:
       ( ' Result := 1;' .Out )
       
   ( GarantModel::TtfwClassLike.BindParams .LUID IsUID )
     Code:
       ( ' Result := true;' .Out )
   
   (
    ( Self .LUID '4B7AB0B6016E' == ) // TTestResultsPlace.CommandLineKey
    AND ( Self .OpKind opkind_Normal != )
   )
     Code:
       ( [ ' Result := ' cQuote '-' l_Implementor .Name 'Release' .CutPrefix cQuote ';' ] .Out )

   (
    ( Self .LUID GarantModel::TvcmFormSetFactoryPrim.GetInstance .LUID == )
    AND ( Self .OpKind opkind_Normal != )
   ) 
     Code:
       ( ' Result := Self.Instance;' .Out )

   (
    ( '_NeedMakeForm' Self .Name EndsStr )
    AND ( l_Implementor .IsVCMFormSetFactory )
   )

    STRING elem_func UseCaseType
     RULES
      ( Self .MainImplements .IsVCMArea )
       ( Self .MainImplements .Parent .TypeName )
      DEFAULT
       ( Self .MainImplements .TypeName )
     ; // RULES
     &gt;&gt;&gt; Result
    ; // UseCaseType

    begin
     Pair:
       (
        [
         'var' \n
         ' l_UseCase : ' Self .Speller .UseCaseType ';'
        ] .Out
       )
       (
        [
	 ' if Supports(aDataSource, ' Self .Speller .UseCaseType ', l_UseCase) then' \n
	 '  try' \n
         if ( Self .Speller .MainImplements .IsVCMArea ) then
         begin
	  '   aNew := l_UseCase' '.' Self .Speller .MainImplements .Name ';' \n
         end // ( Self .Speller .MainImplements .IsVCMArea )
         else
         begin
          HookOut: (
           Indented:
            Indented:
             ( Self .Speller 'NeedMake_impl' @ cNeedsToBeImplemented .MethodUserCode )
          ) // HookOut:
         end // ( Self .Speller .MainImplements .IsVCMArea )
	 '  finally' \n
	 '   l_UseCase := nil;' \n
	 '  end;//try..finally' \n
	 ' Result := (aNew &lt;&gt; nil);'
        ] .Out
       )
    end // ( '_NeedMakeForm' Self .Name EndsStr )

   (
    ( Self .LUID GarantModel::l3UnknownPrim.InitFields .LUID == )
    AND ( Self .OpKind opkind_Normal != )
    AND ( l_Implementor .IsVCMFormSetFactory )
   )
    Code:
      (
       [
        l_Implementor .GetUP 'extprop:pas:InitFields'
//        ' inherited;' \n
//        'XXX'
       ] .Out
      )

   ( Self .IsFactory )
    begin
     Pair:
      (
       RULES
        ( Self .Parent .IsVCMForm )
         begin
          if ( Self .NeedAfterCreate ) then
          begin
           OutLn
           Indented: (
            [ 'procedure AfterCreate(aForm : ' Self .Parent .TypeName ');' ] .Out
            'begin' .Out
            ' with aForm do' .Out
            ' begin' .Out
            Indented: (
             Self cImplementationUserCodeSuffix @ cNeedsToBeImplemented .MethodUserCode
            ) // Indented: (
            ' end;//with aForm' .Out
            'end;' .Out
           ) // Indented:
           OutLn
           
           'var' .Out
           ' l_AC : TvcmInitProc;' .Out
           ' l_ACHack : Pointer absolute l_AC;' .Out
          end // ( Self .NeedAfterCreate )
         end // ( Self .Parent .IsVCMForm )
        ( Self .Parent .IsSingleton ! )
         begin
          'var' .Out
          [ ' l_Inst : ' Self .Parent .TypeName ';' ] .Out
         end // ( Self .Parent .IsSingleton ! )
       ; // RULES  
      ) 
      
      ( 
       RULES
        ( Self .Parent .IsVCMForm )
         begin
          if ( Self .NeedAfterCreate ) then
          begin
	   ' l_AC := l3LocalStub(@AfterCreate);' .Out
           ' try' .Out
          end // ( Self .NeedAfterCreate )
          [ 
           if ( Self .NeedAfterCreate ) then
            ' '
           ' Result := inherited ' Self .MethodName 
           '(' 
           if ( Self .IsMakeSingleChild ) then
           begin
            'aCont, '
            if ( Self .NeedAggregate ) then
            begin
             'vcmSetAggregate(anAgg, vcmMakeParams), '
            end // ( Self .NeedAggregate )
            else
            begin
             'vcmMakeParams, '
            end // ( Self .NeedAggregate )
           end // ( Self .IsMakeSingleChild )
           else
           begin
            'aParams, '
           end // ( Self .IsMakeSingleChild )
           'aZoneType, aUserType, nil, '
           if ( Self .FirstParamIsViewAreaController ) then
           begin
            Self .MethodParameters .FirstElement .Name
           end // ( Self .FirstParamIsViewAreaController )
           else
           begin
            'aDataSource'
           end // ( Self .FirstParamIsViewAreaController )
           if ( Self .NeedAfterCreate ) then
           begin
            ', '
            'vcm_utAny, l_AC'
           end // ( Self .NeedAfterCreate )
           ')' ';'
          ] .Out
          if ( Self .NeedAfterCreate ) then
          begin
           ' finally' .Out
           '  l3FreeLocalStub(l_ACHack);' .Out
           ' end;//try..finally' .Out
          end // ( Self .NeedAfterCreate )
         end // ( Self .Parent .IsVCMForm )
        ( Self .Parent .IsSingleton )
         begin
          Indented: (
           [
            VAR l_TypeName
            Self .Parent .TypeName &gt;&gt;&gt; l_TypeName
            'if (' 'g_' l_TypeName ' = nil) then' \n
            'begin' \n
            ' l3System.AddExitProc(' l_TypeName 'Free' ');' \n
            VAR l_Type
            Self .MethodType .TypeName &gt;&gt;&gt; l_Type
            ' ' l_Type '(' 'g_' l_TypeName ')' ' := inherited ' Self .Name ';' \n
            'end;' \n
            'Result := ' l_Type '(' 'g_' l_TypeName ')' ';'
           ] .Out
          ) // Indented:
         end // ( Self .Parent .IsSingleton )
        DEFAULT
         begin
          Indented: (
           [ 
            'l_Inst := ' 
            
            VAR l_CallTo
            Self .MainAncestor &gt;&gt;&gt; l_CallTo
            if ( l_CallTo .IsNil ) then
             'Create' 
            else
            begin
             l_CallTo .Name
            end // ( l_CallTo .IsNil )
             
            Self .ParametersList ';' 
           ] .Out
           'try' .Out
           [
            ' Result := '
            
            if (
                ( Self .MethodType .IsMixInParamType )
                AND ( Self .Parent .IsMixIn )
               ) then
             '_Instance_R_(l_Inst)'
            else    
             'l_Inst' 
            
            if ( Self .UPisTrue "need As" ) then
            begin
             ' As ' Self .MethodType .TypeName
            end // ( Self .UPisTrue "need As" )
            
            ';' 
           ] .Out
           'finally' .Out
           ' l_Inst.Free;' .Out
           'end;//try..finally' .Out
          ) // Indented:
         end // ( Self .Parent .IsSingleton )
       ; // RULES
      ) 
    end // ( Self .IsFactory )
    
   (
    ( Self .OpKind opkind_Normal == ) // - метод новый, а не перекрытый
    AND ( l_Op .IsNotNil )
    AND ( l_Self .IsNotNil )
    AND ( l_Implementor .IsSummoned )
    AND ( l_Op .UPisTrue "mapped" )
   )
     Code:
       ( 
        [ 
         ' '
         if ( Self .Target .IsNotNil ) then
         begin
          'Result := ' 
         end
         'a' l_Self .SelfName cDot l_Op .Name l_Op .ParametersList ';' 
        ] .Out 
       )
   (
    ( Self .Name 'FillStrings' == )
    AND ( l_Implementor .IsSummoned )
    AND ( 'Helper' l_Implementor .Name EndsStr )
   )
     Pair:
     ( [ 'var' \n ' ' 'l_Index: ' l_Implementor .SpelledFor .MainImplements .TypeName ';' ] .Out )
     ( 
      [ 
	' aStrings.Clear;' \n
	' for l_Index := Low(l_Index) to High(l_Index) do' \n
        '  aStrings.Add(' l_Implementor .SpelledFor .Name '[l_Index].AsCStr);' 
      ] .Out
     )
   (
    ( Self .Name 'DisplayNameToValue' == )
    AND ( l_Implementor .IsSummoned )
    AND ( 'Helper' l_Implementor .Name EndsStr )
   )
     Pair:
     ( [ 'var' \n ' ' 'l_Index: ' l_Implementor .SpelledFor .MainImplements .TypeName ';' ] .Out )
     ( 
      [ 
	' for l_Index := Low(l_Index) to High(l_Index) do' \n
        '  if l3Same(aDisplayName, ' l_Implementor .SpelledFor .Name '[l_Index].AsCStr) then' \n
	'  begin' \n
	'   Result := l_Index;' \n
	'   Exit;' \n
	'  end;//l3Same..' \n
        ' raise Exception.CreateFmt(''Display name "%s" not found in map "' l_Implementor .SpelledFor .Name '"'', [l3Str(aDisplayName)]);'
      ] .Out
     )
   (
    ( Self .Name 'MapID' == )
    AND ( l_Implementor .IsSummoned )
    AND ( 'ImplPrim' l_Implementor .Name EndsStr )
   )
     Code:
     (
      [ 
       ' l3FillChar(Result, SizeOf(Result));' \n
       ' Assert(false);'
      ] .Out
     )  
   (
    ( Self .Name 'GetDisplayNames' == )
    AND ( l_Implementor .IsSummoned )
    AND ( 'ImplPrim' l_Implementor .Name EndsStr )
   )
     Code:
     (
      [ 
       ' ' l_Implementor .SpelledFor .Name 'Helper' '.FillStrings(aList);'
      ] .Out
     )  
   (
    ( Self .Name 'MapSize' == )
    AND ( l_Implementor .IsSummoned )
    AND ( 'ImplPrim' l_Implementor .Name EndsStr )
   )
     Code:
     (
      [ 
       ' Result := Ord(High(' l_Implementor .SpelledFor .MainImplements .TypeName ')) - Ord(Low(' l_Implementor .SpelledFor .MainImplements .TypeName '));'
      ] .Out
     )  
   (
    ( Self .Name 'DisplayNameToValue' == )
    AND ( l_Implementor .IsSummoned )
    AND ( 'ImplPrim' l_Implementor .Name EndsStr )
   )
     Code:
     (
      [ 
       ' Result := Ord(' l_Implementor .SpelledFor .Name 'Helper' '.DisplayNameToValue(aDisplayName));'
      ] .Out
     )  
   (
    ( Self .Name 'ValueToDisplayName' == )
    AND ( l_Implementor .IsSummoned )
    AND ( 'ImplPrim' l_Implementor .Name EndsStr )
   )
     Code:
     (
      [ 
        ' Assert(aValue &gt;= Ord(Low(' l_Implementor .SpelledFor .MainImplements .TypeName ')));' \n
        ' Assert(aValue &lt;= Ord(High(' l_Implementor .SpelledFor .MainImplements .TypeName ')));' \n
        ' Result := ' l_Implementor .SpelledFor .Name '[' l_Implementor .SpelledFor .MainImplements .TypeName '(aValue)].AsCStr;'
      ] .Out
     )  
   (  
    ( Self GarantModel::vcmFormSetDataSource.ClearAreas .IsSameModelElement )
    AND ( Self .OpKind opkind_Overridden == )
    AND ( l_Implementor .IsUseCaseControllerImp )
   ) 
    Code:
    ( [ 
       l_Implementor .ImplementedEx
       .filter&gt; .IsVCMArea
       .for&gt; (
         IN anArea
        [
         if ( anArea .IsVCMAreaRef ) then
         begin
          ' ' 'pm_Get' anArea .Name 'Ref'
         end // ( anArea .IsVCMAreaRef )
         else
         begin
          ' if (f_' anArea .Name ' &lt;&gt; nil) then'
          ' f_' anArea .Name
         end // ( anArea .IsVCMAreaRef )
         '.Referred := nil;' \n
        ] 
       ) // .for&gt;
       ' inherited;'
      ] .Out 
    ) // Code: 
   (
    ( Self .IsVCMArea ) 
    AND ( Self .OpKind opkind_Implemented == )
    AND ( l_Implementor .IsUseCaseControllerImp )
    AND ( Self .IsAreaGetter ! )
   ) 
    Pair:
    AsMethod
    ( [
       if ( Self .IsVCMAreaRef ) then
       begin
        ' with ' 'pm_Get' Self .Name 'Ref' ' do' \n
        ' begin' \n
        '  if IsEmpty' \n
        HookOut: (
         Indented: 
          Indented: 
           ( Self '_need' @ '// - условие создания ViewArea' .MethodUserCode )
        ) // HookOut:
        '   then' \n
        '    ' 'Referred := ' 'DoGet_' Self .Name Self .ParametersList ';' \n
        '  Result := ' Self .MethodType .TypeName '(' 'Referred' ');' \n
        ' end;// with ' 'pm_Get' Self .Name 'Ref'
       end // ( Self .IsVCMAreaRef )
       else
       begin
        ' if (f_' Self .Name ' = nil) then' \n
        ' begin' \n
        '  f_' Self .Name ' := TvcmViewAreaControllerRef.Make;' \n
        HookOut: ( 
         Indented: 
          Indented: 
           ( Self '_init' @ '// - код инициализации ссылки на ViewArea' .MethodUserCode )
        ) // HookOut:
        ' end;//' 'f_' Self .Name ' = nil' \n
        if ( Self .MethodParameters .NotEmpty ) then
        begin
         ' if (f_' Self .Name '.NeedMake = vcm_nmNo) and ' Self .MethodParameters .FirstElement .Name ' then' \n
         '  f_' Self .Name '.NeedMake := vcm_nmYes;' \n
        end // ( Self .MethodParameters .NotEmpty )
        ' if f_' Self .Name '.IsEmpty' \n
        HookOut: ( 
         Indented: 
          Indented: 
           ( Self '_need' @ '// - условие создания ViewArea' .MethodUserCode )
        ) // HookOut:
        '  then' \n
        '   f_' Self .Name '.Referred := ' 'DoGet_' Self .Name Self .ParametersList ';' \n
        ' Result := ' Self .MethodType .TypeName '(' 'f_' Self .Name '.Referred' ');'
       end // ( Self .IsVCMAreaRef )
      ] .Out 
    ) // Pair:
   ( 
    'ResNameGetter' Self .Name EndsStr 
    AND ( Self .IsSimpleClass ) 
   )
    RULES
     ( l_Key 'impl' == )
      ( [ cSpace cOpenComment '$R ' Self .EffectiveUnitName '.res' cCloseComment ] .Out )
     DEFAULT
      () 
    ; // RULES
   ( Self .IsElementProxy )
    AsDefault
   ( Self .IsClassOrMixIn )
    AsDefault
   ( Self .IsRecord )
    AsDefault
   ( Self .IsUtilityPack )
    AsDefault
   ( Self .IsTarget )
    AsDefault
   ( Self .IsIni )
    AsDefault
   ( Self .IsFini )
    AsDefault
   ( Self .IsInterfaces )
    AsDefault
   ( Self .IsVCMFormZone )
    AsDefault
   ( Self .IsVCMZone )
    AsDefault
   DEFAULT
    AsMethod
  ; // RULES 
 end // ( l_Code .IsValueValid ) 
; // UserCode:

ARRAY FUNCTION .mapToUnitProducer&gt;
  ARRAY IN anArray
 anArray 
 .map&gt; .UnitProducer
 .filterNil&gt;
 .filterMixIns&gt;
 &gt;&gt;&gt; Result
; // .mapToUnitProducer&gt;

elem_proc OutUses:
  STRING IN aUCPrefix
  ^ IN aUsed
  ^ IN aLambda
  ^ IN anItemTransform
  
 ARRAY VAR l_Used
 aUsed DO &gt;&gt;&gt; l_Used
  
 ARRAY FUNCTION .filterUsed&gt;
   ARRAY IN anArray
  anArray
  .filter&gt; ( .UnitName .AddToArray?: l_Used )
  &gt;&gt;&gt; Result  
 ; // .filterUsed&gt; 
  
 'uses' .Out
   VAR l_NeedComma
   false &gt;&gt;&gt; l_NeedComma
   Indented: ( 
    aLambda DO 
     .mapToUnitProducer&gt;
     .filter&gt; ( Self ?!= )
     .filter&gt; ( .UnitName Self .UnitName ?!= )
     .filter&gt; ( .UnitName 'System' ?!= )
     .filterUsed&gt; 
     .for&gt; ( 
       IN anItem
      anItem .IfDef: ( anItem anItemTransform DO .WithComma: l_NeedComma .Out )
     ) // .for&gt;
     
    if (
        ( Self .IsElementProxy )
        OR ( Self .UPisTrue "need UC" )
        OR ( 
            ( aUCPrefix 'impl_uses' == ) 
            AND (
             (
              ( Self .IsVCMForm )
              AND ( Self .Abstraction at_final != )
             )
             OR 
             (
              ( Self .IsVCMFormsPack )
              AND ( Self .Abstraction at_final != )
             ) 
             OR 
             (
              ( Self .IsVCMApplication )
              //AND ( Self .Abstraction at_final != )
             ) 
             OR ( Self .Name 'nsMainMenuNew' == )
             OR ( Self .Name 'nsPostingsLine' == ) 
            )
           )
       ) then
    begin
     Self .UserCode: aUCPrefix ()
    end // ( Self .IsElementProxy )
    
    if (
        ( aUCPrefix 'intf_uses' == )
        AND ( Self .UPisTrue "need UC in project" )
       ) then
    begin
     Self .UserCode: 'manualuses' ()
    end // ( Self .IsElementProxy )
    
   ) // Indented:
 ';' .Out
 OutLn
; // OutUses:

ARRAY FUNCTION .mapToTargetAndValueType&gt;
  ARRAY IN anArray
 anArray .mapToTarget&gt;
 .join&gt; ( anArray .map&gt; .ValueType )
 .join&gt; ( anArray .map&gt; .AttrType )
 &gt;&gt;&gt; Result
; // .mapToTargetAndValueType&gt;

elem_iterator AttributesAndOperations
 Cached:
 (
  Self .Attributes
  .join&gt; ( Self .OperationsEx )
  .filter&gt; ( .IsSomeKeyWord ! )
  .filter&gt; ( .IsStereotype st_link::Attribute ! )
 )
 &gt;&gt;&gt; Result
; // AttributesAndOperations

INTERFACE FUNCTION MakeIniProcedure:
  STRING IN aName
  ^ IN aLambda
 aName MakeProcedure: (
   IN aMade
  aMade -&gt; Stereotype := st_ini::Operation
  aMade -&gt; Visibility := PrivateAccess
  aMade aLambda DO
 ) // MakeProcedure:
 &gt;&gt;&gt; Result
; // MakeIniProcedure:

BOOLEAN elem_func IsFriend
 Self .IsStereotype st_friend::Dependency 
 &gt;&gt;&gt; Result
; // IsFriend

elem_iterator FriendInDependencies
 Cached:
 (
  Self .Dependencies 
  .filter&gt; .IsFriend
  .mapToTarget&gt;
  array:Copy
 ) 
 &gt;&gt;&gt; Result
; // FriendInDependencies

BOOLEAN elem_func NeedsScript
 RULES
  ( Self .UPisTrue "needs script" )
   true
  ( Self .UPisTrue "noRegistrator" )
   false
  DEFAULT
   RULES
    ( Self .IsScriptKeywordsPack )
     RULES
      ( Self .IsSummoned )
       false
      ( Self .Parent .IsVCMForm )
       false
      ( Self .Parent .IsVCMFormsPack )
       false
      ( Self .UPisTrue "no class name" )
       true
      ( Self .UPisTrue "no_pop" )
       true
      DEFAULT
       false
     ; // RULES
    DEFAULT
     false
   ; // RULES  
 ; // RULES    
 &gt;&gt;&gt; Result
; // NeedsScript

ModelElement elem_func ClassForKeywordImplementation
  ModelElement IN aKeywordSelf
  ModelElement IN aPack
  
 VAR l_ClassName
 [
  if ( aKeywordSelf .NotIsNil ) then
  begin
   if (
       ( aPack .UPisTrue "no_pop" ! )
       AND ( Self .IsCreator ! )
      ) then
   begin
    'pop_'
   end // ( Self .UPisTrue "no_pop" ! )
   if ( 
       ( aPack .UPisTrue "no class name" ! )
       AND ( aKeywordSelf .SelfName 'SV' != )
      ) then
   begin
    aKeywordSelf .SelfName '_'
   end // ( Self .UPisTrue "no class name" ! )
  end // ( aKeywordSelf .NotIsNil )
  Self .Name
 ] strings:Cat 
 &gt;&gt;&gt; l_ClassName  
 
 l_ClassName
 RULES
  ( Self .IsVarWorker )
   GarantModel::TtfwWordWorkerEx
  ( Self .IsGlobalKeyWord )
   GarantModel::TtfwGlobalKeyWord
  ( Self .GetUP 'extprop:prop_stereo' .IsValueValid ) 
   GarantModel::TtfwPropertyLike 
  DEFAULT
   GarantModel::TtfwClassLike
 ; // RULES 
 MakeClass: (
   IN aMade
  VAR l_WordName
  Self .NameForScript &gt;&gt;&gt; l_WordName
  if ( l_WordName .IsNil ) then
  begin
   l_ClassName cUnderline ':' string:Replace &gt;&gt;&gt; l_WordName
  end // ( l_WordName .IsNil )
  aMade -&gt; UID := ( 
   [ 
    Self .LUID 
    if ( aKeywordSelf .NotIsNil ) then
    begin
     cUnderline aKeywordSelf .LUID
    end // ( aKeywordSelf .NotIsNil )
    '_Word' 
   ] strings:Cat 
  )
  aMade -&gt; %SUM := ( 'Слово скрипта ' l_WordName Cat ) 
  aMade -&gt; Parent := ( Self .Parent .WeakRef )
  aMade -&gt; Stereotype := st_ScriptKeyword
  aMade -&gt; Visibility := PrivateAccess
  aMade -&gt; Abstraction := at_final
  aMade -&gt; SpelledFor := ( Self .WeakRef )
  aMade -&gt; Speller := ( aKeywordSelf .WeakRef )
  aMade -&gt; "is immediate" := ( Self .GetUP "is immediate" )
  aMade -&gt; "ifdef" := ( Self .IfDefStr )
  aMade -&gt; "ifndef" := ( Self .IfNDefStr )
  aMade -&gt; "NameForScript" := l_WordName
  aMade -&gt; 'extprop:pas:TypeName' := ( 
   [ 
    'T' 'kw'
    //l_ClassName 'kw' .CutPrefix cUnderline '' string:Replace .UpperFirstChar
    l_ClassName 'kw' .CutPrefix .FromTie
   ] strings:Cat 
  )
  aMade -&gt; IsSummoned := true
  // - это вообще говоря "времянка", чтобы Override методы выводили код
 ) // MakeClass:
 
 VAR l_Made
 &gt;&gt;&gt; l_Made
 
 if ( Self .Speller .IsNil ) then
 // - здесь вообще говоря надо массив Speller'ов, и учесть его ниже, где алиасы выводятся
 begin
  Self -&gt; Speller := l_Made
 end // ( Self .Speller .IsNil )
 
 l_Made
 
 &gt;&gt;&gt; Result
; // ClassForKeywordImplementation

elem_iterator ChildrenEx
 Cached:
 (
  VAR l_Children
  Self .ChildrenExPrim &gt;&gt;&gt; l_Children
  
  Self .FriendInDependencies
  .filter&gt; ( .IsEvdSchemaElement ! )
  .filter&gt; ( .IsInterface ! )
  .map&gt; .FriendClass
  .filter&gt; ( l_Children SWAP .Name .HasModelElementWithName ! )
  .for&gt; (
    IN aFriend
   l_Children 
   .join&gt; ToArray: aFriend
   array:Copy
   &gt;&gt;&gt; l_Children
  ) // .for&gt;
  
  if ( Self .IsScriptKeywordsPack ) then
  begin
   : .OperationsToClasses
     ARRAY IN anOps
     ModelElement IN aKeywordSelf
    anOps 
    //.filter&gt; ( .Name Msg true )
    .map&gt; ( aKeywordSelf Self .ClassForKeywordImplementation )
    .filter&gt; ( l_Children SWAP .Name .HasModelElementWithName ! )
    .for&gt; (
      IN aClass
     l_Children 
     .join&gt; ToArray: aClass
     array:Copy
     &gt;&gt;&gt; l_Children
    ) // .for&gt;
   ; // .OperationsToClasses
   
   Self .OperationsEx 
   .filter&gt; .IsGlobalKeyWord
   nil
   .OperationsToClasses
   
   Self .InheritsEx
   .join&gt; ( Self .ImplementsEx )
   .filter&gt; .IsAcceptableForScripts
   .for&gt; (
     IN aG
    Self .OperationsEx 
    .filter&gt; .IsKeyWord
    aG
    .OperationsToClasses
   ) // .for&gt;
   
   Self .InheritsEx
   .filter&gt; .IsVCMCustomForm
   .filter&gt; ( .Abstraction at_final == )
   .for&gt; (
     IN aForm
     
    begin
     VAR l_ClassName
     [ 'Tkw_Form_' aForm .Name ] strings:Cat &gt;&gt;&gt; l_ClassName
     if ( l_Children l_ClassName .HasModelElementWithName ! ) then
     begin
      l_Children
      .join&gt; ToArray: (
       l_ClassName
       GarantModel::TtfwControlString
       MakeClass: (
         IN aMade
        aMade -&gt; UID := ( [ aForm .LUID '_Word' ] strings:Cat ) 
        aMade -&gt; Parent := ( Self .WeakRef )
        aMade -&gt; "NameForScript" := ( 
         [ 'форма::' aForm .Name ' ' '_' string:Replace ] strings:Cat 
        ) // aMade -&gt; "NameForScript"
        aMade -&gt; %SUM := ( 
         [
          'Слово словаря для идентификатора формы ' aForm .Name \n
          '----' \n
          '*Пример использования*:' \n
          '{code}'
          aMade .NameForScript
          ' TryFocus ASSERT'
          '{code}'
         ] strings:Cat 
        ) // aMade -&gt; %SUM
        aMade -&gt; Visibility := PrivateAccess
        aMade -&gt; Abstraction := at_final
        aMade -&gt; SpelledFor := ( aForm .WeakRef )
        aMade -&gt; Stereotype := st_ScriptKeyword
        aMade -&gt; "ifdef" := ( aForm .GetUP "ifdef" )
        aMade -&gt; "ifndef" := ( aForm .GetUP "ifndef" )
        aMade -&gt; IsSummoned := true
        aMade -&gt; Overridden := [
         GarantModel::TtfwString.GetString .OverrideMethod
         GarantModel::TtfwRegisterableWordPrim.RegisterInEngine .OverrideMethod
        ] // aMade -&gt; Overridden
       ) // MakeClass:
      ) // .join&gt; ToArray: 
      array:Copy
      &gt;&gt;&gt; l_Children
     end // ( l_Children l_ClassName .HasModelElementWithName ! )
    end // ( aForm .IsComponent ! )
     
    aForm .AllControls
    .filter&gt; ( .IsControlOverride ! )
    .for&gt; (
      IN aControl
      
     //if ( aControl .IsComponent ! ) then 
     begin
      VAR l_ClassName
      [ 'Tkw_' aForm .Name 
        '_' 
        if ( aControl .IsComponent ) then
         'Component'
        else
         'Control' 
        '_' aControl .Name ] strings:Cat &gt;&gt;&gt; l_ClassName
      if ( l_Children l_ClassName .HasModelElementWithName ! ) then
      begin
       l_Children
       .join&gt; ToArray: (
        l_ClassName
        GarantModel::TtfwControlString
        MakeClass: (
          IN aMade
         aMade -&gt; UID := ( [ aControl .LUID '_Word' ] strings:Cat ) 
         aMade -&gt; Parent := ( Self .WeakRef )
         aMade -&gt; "NameForScript" := ( 
          [ 
           if ( aControl .IsComponent ) then
            'компонент'
           else
            'контрол'
           '::'
           aControl .Name ' ' '_' string:Replace
          ] strings:Cat 
         ) // aMade -&gt; "NameForScript"
         aMade -&gt; %SUM := ( 
          [
           'Слово словаря для идентификатора контрола ' aControl .Name \n
           '----' \n
           '*Пример использования*:' \n
           '{code}'
           aMade .NameForScript
           ' TryFocus ASSERT'
           '{code}'
          ] strings:Cat 
         ) // aMade -&gt; %SUM
         aMade -&gt; Visibility := PrivateAccess
         aMade -&gt; Abstraction := at_final
         aMade -&gt; SpelledFor := ( aControl .WeakRef )
         aMade -&gt; Stereotype := st_ScriptKeyword
         aMade -&gt; "ifdef" := ( aControl .GetUP "ifdef" )
         aMade -&gt; "ifndef" := ( aControl .GetUP "ifndef" )
         aMade -&gt; IsSummoned := true
         aMade -&gt; Overridden := [
          GarantModel::TtfwString.GetString .OverrideMethod
          GarantModel::TtfwRegisterableWordPrim.RegisterInEngine .OverrideMethod
         ] // aMade -&gt; Overridden
        ) // MakeClass:
       ) // .join&gt; ToArray: 
       array:Copy
       &gt;&gt;&gt; l_Children
      end // ( l_Children l_ClassName .HasModelElementWithName ! )
     end // ( aControl .IsComponent ! )
     
     if ( aControl .IsComponent ! ) then 
     begin
      VAR l_ClassName
      [ 'Tkw_' aForm .Name 
        '_' 
        if ( aControl .IsComponent ) then
         'Component'
        else
         'Control' 
        '_' aControl .Name '_Push' ] strings:Cat &gt;&gt;&gt; l_ClassName
      if ( l_Children l_ClassName .HasModelElementWithName ! ) then
      begin
       l_Children
       .join&gt; ToArray: (
        l_ClassName
        GarantModel::TkwBynameControlPush
        MakeClass: (
          IN aMade
         aMade -&gt; UID := ( [ aControl .LUID '_Word_Push' ] strings:Cat ) 
         aMade -&gt; Parent := ( Self .WeakRef )
         aMade -&gt; "NameForScript" := ( 
          [ 
           if ( aControl .IsComponent ) then
            'компонент'
           else
            'контрол'
           '::'
           aControl .Name ' ' '_' string:Replace
           ':push'  
          ] strings:Cat 
         ) // aMade -&gt; "NameForScript"
         aMade -&gt; %SUM := ( 
          [
           'Слово словаря для контрола ' aControl .Name \n
           '----' \n
           '*Пример использования*:' \n
           '{code}'
           aMade .NameForScript
           ' pop:control:SetFocus ASSERT'
           '{code}'
          ] strings:Cat 
         ) // aMade -&gt; %SUM
         aMade -&gt; Visibility := PrivateAccess
         aMade -&gt; Abstraction := at_final
         aMade -&gt; SpelledFor := ( aControl .WeakRef )
         aMade -&gt; Stereotype := st_ScriptKeyword
         aMade -&gt; "ifdef" := ( aControl .GetUP "ifdef" )
         aMade -&gt; "ifndef" := ( aControl .GetUP "ifndef" )
         aMade -&gt; IsSummoned := true
         aMade -&gt; Overridden := [
          GarantModel::TtfwWordPrim.DoDoIt .OverrideMethod
         ] // aMade -&gt; Overridden
        ) // MakeClass:
       ) // .join&gt; ToArray: 
       array:Copy
       &gt;&gt;&gt; l_Children
      end // ( l_Children l_ClassName .HasModelElementWithName ! )
     end // ( aControl .IsComponent ! )
    ) // .for&gt;
   ) // .for&gt;
   
  end // ( Self .IsScriptKeywordsPack )
  
  if ( Self .IsVCMCustomForm ) then
  begin
   if ( Self .Abstraction at_final == ) then
   begin
    VAR l_PackName
    [ Self .Name 'KeywordsPack' ] strings:Cat &gt;&gt;&gt; l_PackName
    if ( l_Children l_PackName .HasModelElementWithName ! ) then
    if ( Self .Parent call.me l_PackName .HasModelElementWithName ! ) then
    begin
     l_Children
     .join&gt; ToArray: (
      l_PackName
      Self
      MakeClass: (
        IN aMade
       aMade -&gt; UID := ( [ Self .LUID '_Pack' ] strings:Cat ) 
       aMade -&gt; Parent := ( Self .WeakRef )
       aMade -&gt; %SUM := ( 
        [ 
         'Набор слов словаря для доступа к экземплярам контролов формы '
         Self .Name
        ] strings:Cat 
       ) // aMade -&gt; %SUM
       aMade -&gt; Visibility := PublicAccess
       aMade -&gt; Abstraction := at_final
       aMade -&gt; SpelledFor := ( Self .WeakRef )
       aMade -&gt; Stereotype := st_ScriptKeywordsPack
       aMade -&gt; "ifdef" := ( Self .GetUP "ifdef" )
       aMade -&gt; "ifndef" := ( 
        [ 'NoScripts' 'NoVCL' Self .GetUP "ifndef" ] ',' strings:CatSep
       ) // aMade -&gt; "ifndef"
       aMade -&gt; IsSummoned := true
       aMade -&gt; "UseNewGen" := true
       aMade -&gt; "noRegistrator" := true
       aMade -&gt; "no_pop" := true
      ) // MakeClass:
     ) // .join&gt; ToArray: 
     array:Copy
     &gt;&gt;&gt; l_Children
    end // ( l_Children l_ClassName .HasModelElementWithName ! )
   end // ( Self .Abstraction at_final == )
  end // ( Self .IsVCMCustomForm )
  
  if ( Self .IsUserType ) then
  begin
   VAR l_ClassName
   [ 'Tkw_FormUserType_' Self .Name ] strings:Cat &gt;&gt;&gt; l_ClassName
   if ( l_Children l_ClassName .HasModelElementWithName ! ) then
   begin
    l_Children
    .join&gt; ToArray: (
     l_ClassName
     GarantModel::TtfwInteger
     MakeClass: (
       IN aMade
      aMade -&gt; UID := ( [ Self .LUID '_Word' ] strings:Cat ) 
      aMade -&gt; Parent := ( Self .WeakRef )
      aMade -&gt; "NameForScript" := ( 
       [ 
        'тип_формы::'
        Self .Name ' ' '_' string:Replace
       ] strings:Cat 
      ) // aMade -&gt; "NameForScript"
      aMade -&gt; %SUM := ( 
       [
        'Слово словаря для типа формы ' Self .Name
       ] strings:Cat 
      ) // aMade -&gt; %SUM
      aMade -&gt; Visibility := PrivateAccess
      aMade -&gt; Abstraction := at_final
      aMade -&gt; Stereotype := st_ScriptKeyword
      aMade -&gt; "ifndef" := 'NoScripts'
      aMade -&gt; IsSummoned := true
      aMade -&gt; Overridden := [
       GarantModel::TtfwInteger.GetInteger .OverrideMethod
      ] // aMade -&gt; Overridden
     ) // MakeClass:
    ) // .join&gt; ToArray: 
    array:Copy
    &gt;&gt;&gt; l_Children
   end // ( l_Children l_ClassName .HasModelElementWithName ! )
  end // ( Self .IsUserType )
    
  l_Children
  if ( Self .IsTestClass ) then
  begin
   if ( Self .UPisTrue "is friend" ) then
   begin
    .join&gt; ToArray: ( Self .MainAncestor .FriendClass )
   end // ( Self .UPisTrue "is friend" )
  end // ( Self .IsTestClass )
  
  if ( Self .NeedsScript ) then
  begin
   STRING VAR l_ClassName
   [ 'T' Self .UnitName 'ResNameGetter' ] strings:Cat &gt;&gt;&gt; l_ClassName
   if ( l_Children l_ClassName .HasModelElementWithName ! ) then
   begin
    .join&gt; 
    [
     l_ClassName GarantModel::TtfwAxiomaticsResNameGetter MakeClass: (
       IN aMade
      aMade -&gt; UID := ( Self .LUID '_ResNameGetter' Cat ) 
      aMade -&gt; Parent := ( Self .WeakRef ) 
      aMade -&gt; Stereotype := st_SimpleClass
      aMade -&gt; %SUM := 'Регистрация скриптованой аксиоматики'
      aMade -&gt; Visibility := PrivateAccess
      aMade -&gt; Abstraction := at_final
      aMade -&gt; "ifdef" := ( Self .IfDefStr )
      aMade -&gt; "ifndef" := ( Self .IfNDefStr )
      aMade -&gt; "register in scripts" := false
      aMade -&gt; "need UC" := true
      
      aMade .AddMethodWithParams: ( cUserCodePrefix 'impl' Cat ) aMade (
        IN aMade
       [ cOpenComment '$R ' aMade .EffectiveUnitName '.res' cCloseComment ]
      ) // aMade .AddMethodWithParams: ( cUserCodePrefix 'impl' Cat ) aMade
      
      aMade -&gt; Operations := [
       'RegAxiom' MakeIniProcedure: (
         IN aMadeIni
        aMadeIni -&gt; %SUM := 'Регистрация скриптованой аксиоматики'
        aMadeIni .AddMethodWithParams: cUserCodePrefix aMade .RegAxiomUC
       ) // MakeIniProcedure:
      ] // aMade -&gt; Operations
      
      aMade -&gt; Implemented := [
       GarantModel::TtfwAxiomaticsResNameGetter.ResName .ImplementMethod: (
         IN aMethod
        aMethod -&gt;^ cVarUserCodeName ^:= cEmptyUserCode
        aMethod .AddMethodWithParams: cImplementationUserCodeName aMade ( 
          IN aMade
         [ ' Result := ' cQuote aMade .EffectiveUnitName cQuote ';' ] 
        ) // aMethod .AddMethodWithParams: cImplementationUserCodeName aMade
       ) // GarantModel::TtfwAxiomaticsResNameGetter.ResName .ImplementMethod:
      ] // aMade -&gt; Implemented
     ) // l_ClassName GarantModel::TtfwAxiomaticsResNameGetter MakeClass:
    ] // .join&gt;
   end // ( l_Children l_ClassName .HasModelElementWithName ! )
  end // ( Self .NeedsScript )
  
  if ( Self .IsVCMControls ) then
  begin
   l_Children
   .filter&gt; .IsVCMOperations
   .for&gt; (
     IN anEntity
    anEntity .OperationsEx 
    .filter&gt; .IsVCMOperation
    .filter&gt; .IsInternalOperation
    .for&gt; (
      IN anOperation
     VAR l_ParamsFacet
     nil &gt;&gt;&gt; l_ParamsFacet
     VAR l_ParamsClass
     nil &gt;&gt;&gt; l_ParamsClass
     if (
         ( anOperation .Parameters .NotEmpty )
         OR ( anOperation .Target .NotIsNil )
        ) then
     begin
      .join&gt; ToArray: (
       [ 'I' anEntity .Name '_' anOperation .Name '_Params' ] strings:Cat
       nil
       MakeFacet: (
         IN aMade
        aMade -&gt; UID := ( [ Self .LUID '_Params' ] strings:Cat ) 
        aMade -&gt; %SUM := ( [ 'Параметры для операции ' anEntity .Name '.' anOperation .Name ] strings:Cat ) 
        aMade -&gt; Parent := ( anOperation .WeakRef )
        aMade -&gt; Visibility := PublicAccess
        aMade -&gt; Attributes := [
        
         elem_proc TuneProp
          Self -&gt; Visibility := PublicAccess 
          Self -&gt; Parent := ( aMade .WeakRef )
          Self -&gt; "needs field" := true
          Self -&gt; Stereotype := st_property::Attribute
          Self -&gt;^ cGetterVarUserCodeName ^:= cEmptyUserCode
          Self -&gt;^ cSetterVarUserCodeName ^:= cEmptyUserCode
          Self -&gt;^ cGetterImplementationUserCodeName ^:= [ ' Result := ' 'f_' Self .Name ';' ]
          Self -&gt;^ cSetterImplementationUserCodeName ^:= [ ' ' 'f_' Self .Name ' := ' 'aValue' ';' ]
         ; // TuneProp
         
         anOperation .Parameters
         .for&gt; (
           IN aParam
          aParam .Name 'a' .CutPrefix 
          aParam .Target
          MakeProperty: (
            IN aProp
           aProp .TuneProp
           RULES
            ( aParam .IsStereotype st_in )
             ( aProp -&gt; Stereotype := st_readonly::Attribute )
           ; // RULES
          ) // MakeProperty:
         ) // .for&gt;
         if ( anOperation .Target .NotIsNil ) then
         begin
          'ResultValue'
          anOperation .Target
          MakeProperty: (
            IN aProp
           aProp .TuneProp
          ) // MakeProperty:
         end // ( anOperation .Target .NotIsNil )
        ] // aMade -&gt; Attributes
       ) // MakeFacet:
       &gt;&gt;&gt; l_ParamsFacet
       l_ParamsFacet
      ) // .join&gt; ToArray:
      .join&gt; ToArray: (
       [ 'T' anEntity .Name '_' anOperation .Name '_Params' ] strings:Cat
       GarantModel::Tl3CProtoObject
       MakeClass: (
         IN aMade
        aMade -&gt; %SUM := ( [ 'Реализация ' l_ParamsFacet .Name ] strings:Cat )
        aMade -&gt; Parent := ( anOperation .WeakRef )
        aMade -&gt; Visibility := PrivateAccess
        aMade -&gt; Stereotype := st_SimpleClass
        aMade -&gt; Implements := [ l_ParamsFacet ]
        aMade -&gt; Implemented := ( l_ParamsFacet -&gt; Attributes )
        aMade -&gt; Operations := [
         if ( anOperation .Parameters .NotEmpty ) then
         begin
          'Create'
          MakeProcedure: (
            IN aConstructor
           aConstructor -&gt; Parent := ( aMade .WeakRef )
           aConstructor -&gt; Visibility := PublicAccess 
           aConstructor -&gt; Stereotype := st_ctor::Operation
           aConstructor -&gt; Parameters := ( anOperation .Parameters )
           aConstructor -&gt;^ cVarUserCodeName ^:= cEmptyUserCode
           aConstructor -&gt;^ cImplementationUserCodeName ^:= [
            ' inherited Create;'
            aConstructor .Parameters
            .for&gt; (
              IN aParam
             \n
             ' ' 'f_' aParam .Name 'a' .CutPrefix ' := ' aParam .Name ';' 
            ) // for&gt;
           ] // aConstructor -&gt;^ cImplementationUserCodeName
          ) // MakeProcedure:
         end // ( anOperation .Parameters .NotEmpty )
         'Make'
         l_ParamsFacet
         MakeFunction: (
           IN aConstructor
          aConstructor -&gt; Parent := ( aMade .WeakRef )
          aConstructor -&gt; Visibility := PublicAccess 
          aConstructor -&gt; Stereotype := st_factory::Operation
          aConstructor -&gt; Parameters := ( anOperation .Parameters )
         ) // MakeFunction:
        ] // aMade -&gt; Operations
       ) // MakeClass: 
       &gt;&gt;&gt; l_ParamsClass
       l_ParamsClass
      ) // .join&gt; ToArray:   
     end // ( anOperation .Parameters .NotEmpty )
     .join&gt; ToArray: (
      [ 'Op_' anEntity .Name '_' anOperation .Name ] strings:Cat
      nil
      MakeClass: (
        IN aMade
       aMade -&gt; %SUM := ( [ 'Класс для вызова операции ' anEntity .Name '.' anOperation .Name ] strings:Cat )
       aMade -&gt; Parent := ( anOperation .WeakRef )
       aMade -&gt; Visibility := PublicAccess
       aMade -&gt; Stereotype := st_SimpleClass
       aMade -&gt; Operations := [
       
        : MakeCallPrimPrim:
          IN aType
          IN aTargetType
          IN aDocSuffix
          ^ IN aLambda
         if ( aTargetType .NotIsNil ) then 
          'Call'
         else
          'Broadcast' 
         aType
         MakeFunction: (
           IN aFunc
          aFunc -&gt; %SUM := ( [ 'Вызов операции ' anEntity .Name '.' anOperation .Name ' ' aDocSuffix ] strings:Cat ) 
          aFunc -&gt; Stereotype := st_static::Operation
          aFunc -&gt; Visibility := PublicAccess
          aFunc -&gt; Abstraction := at_final
          aFunc -&gt; Parameters := (
           if ( aTargetType .NotIsNil ) then
           begin 
            [ 'aTarget' aTargetType MakeParam ] 
            .join&gt; ( anOperation .Parameters ) 
           end // ( aTargetType .NotIsNil )
           else
           begin
            anOperation .Parameters
           end // ( aTargetType .NotIsNil )
          ) // aFunc -&gt; Parameters
          aFunc -&gt; UsedElements := [ 
           GarantModel::l3Base 
           GarantModel::vcmBase 
          ] // aFunc -&gt; UsedElements
          aFunc aLambda DO
         ) // MakeFunction:
        ; // MakeCallPrimPrim:  
        
        : MakeCallPrim:
          IN aTargetType
          IN aDocSuffix
          ^ IN aLambda
         if ( anOperation .Target .IsNil ) then
          GarantModel::Boolean
         else
          ( anOperation .Target )
         aTargetType
         aDocSuffix 
         MakeCallPrimPrim: (
           IN aFunc 
          aFunc aLambda DO 
         ) // MakeCallPrimPrim: 
        ; // MakeCallPrim  
        
        : MakeCall
          IN aTargetType
          IN aDocSuffix
         aTargetType    
         aDocSuffix    
         MakeCallPrim: (
           IN aFunc 
          aFunc -&gt;^ cVarUserCodeName ^:= [ 'var' \n ' l_Params : IvcmExecuteParams;' ]
          aFunc -&gt;^ cImplementationUserCodeName ^:= [ 
           ' l3FillChar(Result, SizeOf(Result));' \n
           ' if (aTarget &lt;&gt; nil) then' \n
           ' begin' \n
           '  l_Params := '
           if ( l_ParamsFacet .IsNil ) then 
            'vcmParams'
           else
           begin 
            'TvcmExecuteParams.MakeForInternal' 
            '(' 
            l_ParamsClass .TypeName
            '.Make' anOperation .Parameters .map&gt; .Name .CommaListWith()
            ')'
           end // ( l_ParamsFacet .IsNil )
           ';' \n
           '  aTarget.Operation(opcode_' anEntity .Name '_' anOperation .Name ', l_Params);' \n
           '  with l_Params do' \n
           '  begin' \n
           '   if Done then' \n
           '   begin' \n
           '    '
           'Result := '
           if ( anOperation .Target .IsNil ) then 
            'true'
           else
           begin
            l_ParamsFacet .TypeName '(Data).ResultValue'
           end // ( anOperation .Target .IsNil )
           ';' \n
           '   end;//Done' \n
           '  end;//with l_Params' \n
           ' end;//aTarget &lt;&gt; nil'
          ] // aFunc -&gt;^ cImplementationUserCodeName
//          aFunc -&gt; UsedElements := (
//           aFunc -&gt; UsedElements
//           .join&gt; ToArray: GarantModel::StdRes
//          ) // aFunc -&gt; UsedElements
         ) // MakeCallPrim:
        ; // MakeCall
        GarantModel::IvcmEntity 'у сущности' MakeCall
        GarantModel::IvcmAggregate 'у агрегации' MakeCall
        
        GarantModel::IvcmEntityForm 
        'у формы' 
        MakeCallPrim: (
          IN aFunc
         aFunc -&gt;^ cVarUserCodeName ^:= cEmptyUserCode 
         aFunc -&gt;^ cImplementationUserCodeName ^:= [ 
          ' l3FillChar(Result, SizeOf(Result));' \n
          ' if (aTarget &lt;&gt; nil) then' \n
          '  Result := Call(aTarget.Entity'
          if ( anOperation .Parameters .NotEmpty ) then
          begin
           ', ' anOperation .Parameters .map&gt; .Name .CommaList 
          end // ( anOperation .Parameters .NotEmpty )
          ')' ';'
         ] // aFunc -&gt;^ cImplementationUserCodeName
        ) // MakeCallPrim:
        
        GarantModel::IvcmContainer 
        'у контейнера' 
        MakeCallPrim: (
          IN aFunc
         aFunc -&gt;^ cVarUserCodeName ^:= cEmptyUserCode 
         aFunc -&gt;^ cImplementationUserCodeName ^:= [ 
          ' l3FillChar(Result, SizeOf(Result));' \n
          ' if (aTarget &lt;&gt; nil) then' \n
          '  Result := Call(aTarget.AsForm'
          if ( anOperation .Parameters .NotEmpty ) then
          begin
           ', ' anOperation .Parameters .map&gt; .Name .CommaList 
          end // ( anOperation .Parameters .NotEmpty )
          ')' ';'
         ] // aFunc -&gt;^ cImplementationUserCodeName
        ) // MakeCallPrim:
        
        if ( 
            ( anOperation .Target .IsNil )
            AND ( anOperation .UPisTrue "Needs Broadcast" )
           ) then
        begin   
         nil
         nil
         'у всех зарегистрированных сущностей' 
         MakeCallPrimPrim: (
           IN aFunc
          aFunc -&gt;^ cVarUserCodeName ^:= [ 'var' \n ' l_Params : IvcmExecuteParams;' ]
          aFunc -&gt;^ cImplementationUserCodeName ^:= [
           ' if (vcmDispatcher &lt;&gt; nil) then' \n 
           ' begin' \n
           '  l_Params := ' 
           if ( l_ParamsFacet .IsNil ) then 
            'vcmParams'
           else
           begin 
            'TvcmExecuteParams.MakeForInternal'
            '(' 
            l_ParamsClass .TypeName 
            '.Make' 
            anOperation .Parameters .map&gt; .Name .CommaListWith() 
            ')'
           end // ( l_ParamsFacet .IsNil )
           ';' \n
           '  vcmDispatcher.EntityOperationBroadcast(opcode_' anEntity .Name '_' anOperation .Name ', l_Params);' \n
           ' end//vcmDispatcher &lt;&gt; nil'
          ] // aFunc -&gt;^ cImplementationUserCodeName
//          aFunc -&gt; UsedElements := (
//           aFunc -&gt; UsedElements
//           .join&gt; ToArray: GarantModel::StdRes
//          ) // aFunc -&gt; UsedElements
         ) // MakeCallPrimPrim:
        end
       ] // aMade -&gt; Operations :=
      ) // MakeClass:
     ) // .join&gt; ToArray:
    ) // .for&gt;
   ) // .for&gt;
  end // ( Self .IsVCMControls )
  
  .joinWithLambded&gt; (
  Self .OperationsEx
  .filter&gt; .IsIterator
  .filter&gt; ( .IsServiceIterator ! )
  .filter&gt; ( .IsOverride ! )
  .filter&gt; ( l_Children SWAP .IteratorAction .Name .HasModelElementWithName ! )
  ) ( .ToArray: .IteratorAction )
  
  array:Copy
 )
 &gt;&gt;&gt; Result
; // ChildrenEx

elem_iterator ChildrenWithoutOwnFile
 Cached:
 ( 
  Self .ChildrenEx 
  .filter&gt; ( .NeedOwnFile ! ) 
 )
 &gt;&gt;&gt; Result
; // ChildrenWithoutOwnFile

elem_iterator ChildrenWithOwnFile
 Cached:
 ( 
  Self .ChildrenEx 
  .filter&gt; .NeedOwnFile
  array:Copy
 )
 &gt;&gt;&gt; Result
; // ChildrenWithOwnFile

INTERFACE FUNCTION MakeConstants:
  STRING IN aName
  ^ IN aLambda
 aName nil MakeParam: ( 
   IN aMade
  aMade -&gt; Stereotype := st_Constants
  aMade aLambda DO
 )
 &gt;&gt;&gt; Result 
; // MakeConstants:
  
INTERFACE FUNCTION MakeConstant:
  STRING IN aName
  PRINTABLE IN aValue
  ^ IN aLambda
 aName nil MakeParam: ( 
   IN aMade
  aMade -&gt; Class := class_Attribute
  if ( aValue .NotIsNil ) then
  begin
   aMade -&gt; 'extprop:pas:Value' := aValue
  end // ( aValue .NotIsNil )
  aMade aLambda DO
 )
 &gt;&gt;&gt; Result 
; // MakeConstant:

ModelElement elem_func ElementOrParentThatCanHaveIniOperations
 RULES
  ( Self .IsClassOrMixIn )
   Self
  ( Self .IsUtilityPack )
   Self
  ( Self .IsUserType )
   Self
  ( Self .Parent .IsNil )
   nil
  DEFAULT 
   ( Self .Parent call.me )
 ; // RULES
 &gt;&gt;&gt; Result
; // ElementOrParentThatCanHaveIniOperations

elem_iterator ConstantsEx
 Cached:
 (
  VAR l_Constants
  Self .Constants &gt;&gt;&gt; l_Constants
  l_Constants
  
  RULES
   ( Self .IsLocalConst )
    begin
     VAR l_ConstantsName
     [ 
      'LCImpl' 
      if ( Self .IsChoices ) then 
      begin
       '_' Self .Parent .Name '_'
      end // ( Self .IsChoices )
      Self .Name 
     ] strings:Cat &gt;&gt;&gt; l_ConstantsName
     if ( Self .ElementOrParentThatCanHaveIniOperations call.me l_ConstantsName .HasModelElementWithName ! ) then
     begin
      .join&gt; ToArray: (
       l_ConstantsName MakeConstants: (
         IN aConstants
        if ( Self .IsChoices ) then 
        begin
         aConstants -&gt; %SUM := ( [ 'Варианты выбора для диалога ' Self .Parent .Name ] strings:Cat )
        end // ( Self .IsChoices )
        else
        begin
         aConstants -&gt; %SUM := ( [ 'Локализуемые строки ' Self .Name ] strings:Cat )
        end // ( Self .IsChoices ) 
        aConstants -&gt; Visibility := ( Self .Visibility )
        aConstants -&gt; Speller := ( Self .WeakRef )
        aConstants -&gt; Parent := ( Self .WeakRef )
        aConstants -&gt; "ifdef" := ( Self .GetUP "ifdef" )
        aConstants -&gt; "ifndef" := ( Self .GetUP "ifndef" )
        aConstants -&gt; "children prefix" := ( Self .GetUP "children prefix" )
        aConstants -&gt; "elements prefix" := ( [ 'str_' Self .GetUP "elements prefix" ] strings:Cat )
        aConstants -&gt; Attributes := [
         Self .Attributes
         .join&gt; ( Self .ChildrenEx )
         .for&gt; (
           IN anItem
           
          STRING FUNCTION ItemValue
           anItem .GetUP 'Value' &gt;&gt;&gt; Result
           if ( Result .IsNil ) then
           begin
            anItem .GetUP "Value" &gt;&gt;&gt; Result
           end // ( Result .IsNil )
           if ( Result .IsNil ) then
           begin
            anItem .GetUP 'extprop:pas:Value' &gt;&gt;&gt; Result
           end // ( Result .IsNil )
           if ( Result .IsNil ) then
           begin
            anItem .Documentation &gt;&gt;&gt; Result
           end // ( Result .IsNil )
           Result '\\"' '"' string:Replace &gt;&gt;&gt; Result
           Result '\\' '\' string:Replace &gt;&gt;&gt; Result
          ; // ItemValue
          
          VAR l_Name
          [ 
           Self .GetUP 'extprop:pas:ElementPrefix' 
           if ( anItem .IsChoice ) then
           begin
            Self .Parent .Name
            '_Choice_'
           end // ( anItem .IsChoice )
           anItem .Name 
          ] strings:Cat &gt;&gt;&gt; l_Name
          [ 'str_' l_Name ] strings:Cat
          [ '('
            'rS : -1;'
            ' rLocalized : false;' 
            ' rKey : ' cQuote l_Name cQuote ';'
            ' rValue : ' ItemValue
            ')' ] strings:Cat
          MakeConstant: (
            IN aConstant
           if ( anItem .IsMessage ) then
           begin
            aConstant -&gt; Target := GarantModel::Tl3MessageID
           end // ( anItem .IsMessage )
           else
           begin
            aConstant -&gt; Target := GarantModel::Tl3StringIDEx
           end // ( anItem .IsMessage )
           aConstant -&gt; Visibility := ( anItem .Visibility ) 
           aConstant -&gt; Speller := ( anItem .WeakRef )
           aConstant -&gt; %SUM := ( 
            if ( anItem .Documentation .IsNil ) then
            begin
             ItemValue
            end // ( anItem .Documentation .IsNil )
            else
            begin
             anItem .Documentation 
            end // ( anItem .Documentation .IsNil )
           ) // aConstant -&gt; %SUM
           aConstant -&gt; "ifdef" := ( anItem .GetUP "ifdef" )
           aConstant -&gt; "ifndef" := ( anItem .GetUP "ifndef" )
          ) // MakeConstant:
         ) // .for&gt;
        ] // aConstants -&gt; Attributes
       ) // l_ConstantsName MakeConstants:
      ) // .join&gt; ToArray:
     end //
    end // ( Self .IsLocalConst )
   ( Self .IsTypedef )
    begin
     VAR l_OtherEnum
     Self .MainAncestor &gt;&gt;&gt; l_OtherEnum
     RULES
      ( l_OtherEnum .IsEnum )
       RULES
        ( Self .Name l_OtherEnum .Name == )
         RULES
          ( l_OtherEnum .Attributes .NotEmpty )
           begin
            VAR l_ConstantsName
            [ Self .Name cUnderline l_OtherEnum .Name cUnderline 'Constants' ] strings:Cat &gt;&gt;&gt; l_ConstantsName
            RULES
             ( 
              Self .Parent call.me 
              .filter&gt; ( .Name l_ConstantsName == )
              .IsEmpty
             )
              begin
               .join&gt;
               [
                VAR l_ElementPrefix
                l_OtherEnum .GetUP 'extprop:pas:ElementPrefix' &gt;&gt;&gt; l_ElementPrefix
                l_ConstantsName MakeConstants: (
                  IN aConstants
                 aConstants -&gt; %SUM := ( [ 'Алиасы для значений ' l_OtherEnum .Parent .Name cDot l_OtherEnum .Name ] strings:Cat )
                 aConstants -&gt; Visibility := PublicAccess
                 //aConstants -&gt; 'extprop:pas:ElementPrefix' := l_ElementPrefix
                 aConstants -&gt; Attributes := [
                  l_OtherEnum .Attributes .for&gt; (
                    IN anItem
                   VAR l_Name 
                   [ l_ElementPrefix anItem .Name ] strings:Cat &gt;&gt;&gt; l_Name
                   l_Name
                   [ l_OtherEnum .EffectiveUnitName cDot l_Name ] strings:Cat 
                   MakeConstant: (
                     IN aConstant
                    RULES
                     ( anItem .Documentation .IsNotNil )
                      ( aConstant -&gt; %SUM := ( anItem .Documentation ) )
                    ; // RULES 
                   ) // MakeConstant:
                  ) // l_OtherEnum .Attributes .for&gt;
                 ] // aConstants -&gt; Attributes
                ) // MakeConstants:
               ] // .join&gt;
              end
            ; // RULES
           end // ( l_OtherEnum .Attributes .NotEmpty )
         ; // RULES
       ; // RULES
     ; // RULES
    end // ( Self .IsTypedef )
   ( Self .IsVCMFormDefinition )
    begin
     VAR l_PublishedForms
     [] &gt;&gt;&gt; l_PublishedForms
     Self .ImplementorsEx
     .filter&gt; .IsVCMForm
     .for&gt; (
       IN aForm
      VAR l_ConstantsName
      [ aForm .Name 'IDs' ] strings:Cat &gt;&gt;&gt; l_ConstantsName
      if ( l_Constants l_ConstantsName .HasModelElementWithName ! ) then
      begin
       VAR l_Name
       [ 'fm_' aForm .TypeName 'T' .CutPrefix ] strings:Cat &gt;&gt;&gt; l_Name
       if ( l_Name .AddToArray?: l_PublishedForms ) then
       begin
        .join&gt; ToArray: (
         l_ConstantsName MakeConstants: (
           IN aConstants
          aConstants -&gt; Visibility := PublicAccess
          aConstants -&gt; Attributes := [
           l_Name
           [ '(rFormID : (rName : ' cQuote aForm .TypeName 'T' .CutPrefix cQuote '; rID : 0); rFactory : nil)' ] strings:Cat
           MakeConstant: (
             IN aConstant
            aConstant -&gt; Visibility := PublicAccess 
            aConstant -&gt; %SUM := ( [ 'Идентификатор формы ' aForm .TypeName ] strings:Cat )
            aConstant -&gt; Target := GarantModel::TvcmFormDescriptor
           ) // MakeConstant: 
          ] // aConstants -&gt; Attributes
         ) // l_ConstantsName MakeConstants: 
        ) // .join&gt; ToArray:  
       end // ( l_Name .AddToArray?: l_PublishedForms )
      end // ( l_Constants l_ConstantsName .HasModelElementWithName ! )   
     ) // .for&gt;
    end // ( Self .IsVCMFormDefinition )
   ( Self .IsUserType )
    begin
     VAR l_ConstantsName
     [ Self .Name 'Constants' ] strings:Cat &gt;&gt;&gt; l_ConstantsName
     if ( l_Constants l_ConstantsName .HasModelElementWithName ! ) then
     begin
      .join&gt; ToArray: (
       l_ConstantsName MakeConstants: (
         IN aConstants
        aConstants -&gt; %SUM := ( [ 'Константы для типа формы ' Self .Name ] strings:Cat )
        aConstants -&gt; Visibility := PublicAccess
        aConstants -&gt; Attributes := [
         [ Self .Name 'Name' ] strings:Cat
         nil
         MakeConstant: (
           IN aConstant
          aConstant -&gt; Visibility := PublicAccess 
          aConstant -&gt; %SUM := ( [ 'Строковый идентификатор пользовательского типа "' Self .Documentation '"' ] strings:Cat )
          aConstant -&gt; Value := ( [ cQuote Self .Name cQuote ] strings:Cat )
         ) // MakeConstant: 
         
         Self .Name
         if ( Self .MainAncestor .IsNil ) then
         begin
          'TvcmUserType(0)'
         end // ( Self .MainAncestor .IsNil )
         else
         begin
          [ 'TvcmUserType(' Self .MainAncestor .Name ' + 1)' ] strings:Cat
         end // ( Self .MainAncestor .IsNil )
         MakeConstant: (
           IN aConstant
          aConstant -&gt; Visibility := PublicAccess 
          aConstant -&gt; Target := GarantModel::TvcmUserType
          aConstant -&gt; %SUM := ( Self .Documentation )
          aConstant -&gt; "is define" := true
          aConstant -&gt; "no unit prefix" := true
         ) // MakeConstant: 
        ] // aConstants -&gt; Attributes
       ) // l_ConstantsName MakeConstants:
      ) // .join&gt; ToArray:
     end // ( l_Constants l_ConstantsName .HasModelElementWithName ! )
     
     [ Self .Name 'LocalConstants' ] strings:Cat &gt;&gt;&gt; l_ConstantsName
     if ( l_Constants l_ConstantsName .HasModelElementWithName ! ) then
     begin
      .join&gt; ToArray: (
       l_ConstantsName MakeConstants: (
         IN aConstants
        aConstants -&gt; %SUM := ( [ 'Локализуемые константы для типа формы ' Self .Name ] strings:Cat )
        aConstants -&gt; Stereotype := st_LocalConst
        aConstants -&gt; Visibility := PublicAccess
        aConstants -&gt; Attributes := [
         [ Self .Name 'Caption' ] strings:Cat
         [ cQuote Self .Documentation cQuote ] strings:Cat
         MakeConstant: (
           IN aConstant
          aConstant -&gt; Visibility := PublicAccess 
          aConstant -&gt; %SUM := ( [ 'Заголовок пользовательского типа "' Self .Documentation '"' ] strings:Cat )
         ) // MakeConstant: 
         
         if ( Self .GetUP "SettingsCaption" .NotIsNil ) then
         begin
          [ Self .Name 'SettingsCaption' ] strings:Cat
          [ cQuote Self .GetUP "SettingsCaption" cQuote ] strings:Cat
          MakeConstant: (
            IN aConstant
           aConstant -&gt; Visibility := PublicAccess 
           aConstant -&gt; %SUM := ( [ 'Заголовок пользовательского типа "' Self .Documentation '"' ' для настройки панелей инструментов' ] strings:Cat )
          ) // MakeConstant: 
         end // ( Self .GetUP "SettingsCaption" .NotIsNil )
        ] // aConstants -&gt; Attributes
       ) // l_ConstantsName MakeConstants:
      ) // .join&gt; ToArray:
     end // ( l_Constants l_ConstantsName .HasModelElementWithName ! )
    end // ( Self .IsUserType )
   ( Self .IsVCMControls )
    begin
     RULES
      ( Self .ChildrenEx
        .filter&gt; .IsVCMOperations
        .NotEmpty )
      begin
       VAR l_PublishedEntities
       [] &gt;&gt;&gt; l_PublishedEntities
       VAR l_PublishedOperations
       [] &gt;&gt;&gt; l_PublishedOperations
       .join&gt; ToArray: (
        'EntitiesConsts' MakeConstants: (
          IN aConstants
         aConstants -&gt; Visibility := ProtectedAccess 
         aConstants -&gt; Parent := ( Self .WeakRef )
         aConstants -&gt; Attributes := [
          Self .ChildrenEx
          .filter&gt; .IsVCMOperations
          .for&gt; (
            IN anEntity
           VAR l_Name
           anEntity .Name &gt;&gt;&gt; l_Name
           if ( l_Name .AddToArray?: l_PublishedEntities ) then
           begin 
            [ 'en_' l_Name ] strings:Cat
            if ( l_Name anEntity .MainAncestor .Name == ) then
            begin
             [ anEntity .MainAncestor .EffectiveUnitName '.' 'en_' l_Name ] strings:Cat
            end
            else
            begin
             [ cQuote l_Name cQuote ] strings:Cat
            end 
            MakeConstant: (
              IN aConstant
             aConstant -&gt; Visibility := PublicAccess 
             aConstant -&gt; Parent := ( aConstants .WeakRef )
            ) // MakeConstant: 
            [ 'en_cap' l_Name ] strings:Cat
            if ( l_Name anEntity .MainAncestor .Name == ) then
            begin
             [ anEntity .MainAncestor .EffectiveUnitName '.' 'en_cap' l_Name ] strings:Cat
            end
            else
            begin
             [ cQuote anEntity .Documentation \n cSpace string:Replace cQuote ] strings:Cat
            end 
            MakeConstant: (
              IN aConstant
             aConstant -&gt; Visibility := PublicAccess 
             aConstant -&gt; Parent := ( aConstants .WeakRef )
            ) // MakeConstant: 
           end // ( l_Name .AddToArray?: l_PublishedEntities )
           anEntity .OperationsEx
           .filter&gt; .IsVCMOperation
           .for&gt; (
             IN anOperation
            if ( anOperation .Name .AddToArray?: l_PublishedOperations ) then 
            begin
             [ 'op_' anOperation .Name ] strings:Cat
             [ cQuote anOperation .Name cQuote ] strings:Cat
             MakeConstant: (
               IN aConstant
              aConstant -&gt; Visibility := PublicAccess 
              aConstant -&gt; Parent := ( aConstants .WeakRef )
             ) // MakeConstant: 
             [ 'op_cap' anOperation .Name ] strings:Cat
             [ cQuote anOperation .Documentation \n cSpace string:Replace cQuote ] strings:Cat
             MakeConstant: (
               IN aConstant
              aConstant -&gt; Visibility := PublicAccess 
              aConstant -&gt; Parent := ( aConstants .WeakRef )
             ) // MakeConstant: 
            end // ( anOperation .Name .AddToArray?: l_PublishedOperations )
           ) // .for&gt;
          ) // .for&gt;
         ] // aConstants -&gt; Attributes
        ) // 'EntitiesConsts' MakeConstants:
       ) // join&gt; ToArray:
      end // .IsVCMOperations .NotEmpty
     ; // RULES 
    end // ( Self .IsVCMControls )
  ; // RULES
  array:Copy
 )
 &gt;&gt;&gt; Result
; // ConstantsEx

elem_iterator ConstantsAndChildrenWithoutOwnFile
 Cached:
 ( 
  Self .ConstantsEx
  .join&gt; ( Self .ChildrenWithoutOwnFile )
 )
 &gt;&gt;&gt; Result
; // ConstantsAndChildrenWithoutOwnFile

elem_iterator AllOwnChildren
 Cached:
 ( 
  Self .ConstantsAndChildrenWithoutOwnFile
  .join&gt; ( Self .AttributesAndOperations )
 )
 &gt;&gt;&gt; Result
; // AllOwnChildren

ARRAY FUNCTION .OperationsNeededElements
  ARRAY IN anArray
 anArray .mapToTargetAndValueType&gt;
 .join&gt; ( 
  anArray 
  .filter&gt; .IsMessageOperation
  .filter&gt; ( .GetUP "Message ID" 'CM_' SWAP StartsStr )
  .map&gt; ( DROP GarantModel::Controls ) 
 ) // .join&gt;
 .joinWithLambded&gt; anArray ( .Parameters .mapToTargetAndValueType&gt; )
 .joinWithLambded&gt; anArray ( .AttributesAndOperations call.me )
 .joinWithLambded&gt; ( anArray .filter&gt; .IsFactoryMethod ) ( .MethodParameters .mapToTargetAndValueType&gt; )
 .joinWithLambded&gt; ( anArray .filter&gt; .IsIterator ) ( .MethodParameters .mapToTargetAndValueType&gt; )
 .joinWithLambded&gt; ( anArray .filter&gt; .IsFactoryMethod ) ( .ToArray: .MainImplementsInterface )
 .joinWithLambded&gt; ( anArray .filter&gt; .IsMethod .map&gt; .MainAncestor .filterNil&gt; ) ( .MethodParameters .mapToTargetAndValueType&gt; )
 .joinWithLambded&gt; ( anArray .filter&gt; .IsMethod 
                     .map&gt; .MainAncestor 
                     .filterNil&gt; 
                     .map&gt; .MethodType 
                     .filterNil&gt; ) ( .ToArray )
 .joinWithLambded&gt; anArray .CanRaise
 .joinWithLambded&gt; anArray .CanRaiseInSet 
 &gt;&gt;&gt; Result 
; // .OperationsNeededElements

elem_iterator NeededElementsFromInheritsOrImplements
 Cached:
 (
  ( Self .InheritsEx )
  .join&gt; ( Self .ImplementsEx .filter&gt; ( .IsEvdSchemaElement ! ) )
 )
 &gt;&gt;&gt; Result
; // NeededElementsFromInheritsOrImplements

elem_iterator AttributesAndOperationsNeededElements
 Self .AttributesAndOperations
 .join&gt; ( Self .Properties )
 .join&gt; ( Self .Fields )
 array:CopyWithoutDuplicates
 .OperationsNeededElements
 &gt;&gt;&gt; Result
; // AttributesAndOperationsNeededElements

BOOLEAN elem_func InheritsFromOrSomeAncestorImplements
  ModelElement IN anIntf
 RULES 
  ( Self anIntf .InheritsFrom )
   true 
  ( Self anIntf .SomeAncestorImplements )
   true
  DEFAULT
   false     
 ; // RULES      
 &gt;&gt;&gt; Result      
; // InheritsFromOrSomeAncestorImplements
       
BOOLEAN elem_func HasManagedAttributes
 Cached:
 (
  RULES
   ( Self .IsNil )
    false
   DEFAULT
    ( 
     Self .Fields
     .filter&gt; .IsFieldForCleanup
     .NotEmpty
    )
  ; // RULES  
 )
 &gt;&gt;&gt; Result
; // HasManagedAttributes

BOOLEAN elem_func NeedsInitEntities
 Self .UPisTrue 'extprop:NeedsInitEntities'
 &gt;&gt;&gt; Result
; // NeedsInitEntities

BOOLEAN elem_func HasAnyVCMController
 Cached:
 (
  //Self .Children
  //.join&gt; ( Self .Attributes )
  Self .Attributes
  .filter&gt; .IsVCMController
  .NotEmpty
  //Self .UPisTrue 'extprop:HasAnyVCMController'
 ) 
 &gt;&gt;&gt; Result
; // HasAnyVCMController

elem_iterator UserTypes
 Self .ChildrenEx
 .filter&gt; .IsUserType
 &gt;&gt;&gt; Result
; // UserTypes

BOOLEAN elem_func NeedsMakeControls
 Cached:
 (
  Self .UserTypes
  .join&gt; (
   Self .OwnControls
  ) // .join&gt;
  .NotEmpty
 )
 &gt;&gt;&gt; Result
; // NeedsMakeControls

/*{
// Реализует ли хоть одну операцию VCM
%f _ImplementsSomeVCMOperation
// возвращаемый результат: boolean
@ %SU
	[{&lt;{}{%R#f_IsVCMOperations()=true}{C}&gt;!=0}{\
	%f_set_var(RESULT,"false")\
	&lt;{}{%O#f_IsVCMOperation()=true}\
	[{"%O{ShowInContextMenu}"!=""|%O{ShowInContextMenu}!=undefined|"%O{ContextMenuWeight}"!=""|"%O{ShowInToolbar}"!=""|%O{ShowInToolbar}!=undefined}\
	%f_set_var(RESULT,"true")\
	%f_cycle_break(%S)\
	]\
	&gt;\
	[{%{RESULT}N!=true}\
	&lt;{}{%C#f_IsControl()=true}{%C}\
	[{%C&lt;{}{%R#f_IsVCMOperations()=true}{C}&gt;!=0}\
	%f_set_var(RESULT,"true")\
	%f_cycle_break(%S)\
	]\
	&gt;\
	]\
	%{RESULT}N\
	}\
	true\
	]
}*/

BOOLEAN elem_func ImplementsSomeVCMOperation
 Cached:
 (
  RULES
   ( Self .ImplementsEx 
     .filter&gt; .IsVCMOperations
     .NotEmpty )
    true 
   ( Self .ImplementedEx
     .join&gt; ( Self .Overridden )
     .filter&gt; .IsVCMOperation
     .NotEmpty )
    true  
   DEFAULT
    false
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // ImplementsSomeVCMOperation

elem: AsExecuteDo:
  ^ IN aLambda
 Self .DecorateMethodAndDo: ( 
   IN aMethod
  aMethod -&gt; OpModify := opModifyExecute
  aMethod aLambda DO 
 ) // Self .DecorateMethodAndDo:
; // AsExecuteDo:

elem: AsAreaDo:
  ^ IN aLambda
 Self .DecorateMethodAndDo: ( 
   IN aMethod
  aMethod -&gt; OpModify := opModifyArea
  aMethod aLambda DO 
 ) // Self .DecorateMethodAndDo:
; // AsAreaDo:

elem: AsTestDo:
  ^ IN aLambda
 Self .DecorateMethodAndDo: ( 
   IN aMethod
  aMethod -&gt; OpModify := opModifyTest
  aMethod aLambda DO 
 ) // Self .DecorateMethodAndDo:
; // AsTestDo:

elem: AsGetStateDo:
  ^ IN aLambda
 Self .DecorateMethodAndDo: ( 
   IN aMethod
  aMethod -&gt; OpModify := opModifyGetState
  aMethod aLambda DO 
 ) // Self .DecorateMethodAndDo:
; // AsGetStateDo:

elem_iterator AllUserTypes
 Cached:
 (
  Self .UserTypes
  .joinWithLambded&gt; ( Self .InheritsEx ) call.me
  .joinWithLambded&gt; ( Self .ImplementsEx ) call.me
 )
 &gt;&gt;&gt; Result 
; // AllUserTypes

BOOLEAN elem_func HasStates
 Self .UPisTrue "has states"
 &gt;&gt;&gt; Result
; // HasStates

BOOLEAN FUNCTION .IsIntEx
  IN Self
 RULES
  ( Self IsInt )
    true
  ( Self IsString )
   RULES
    ( '-' Self StartsStr )
     true
    DEFAULT
     false
   ; // RULES   
  DEFAULT
   false
 ; // RULES
 &gt;&gt;&gt; Result
; // .IsIntEx

elem_iterator InitEntitiesUC
 [ 
  ' inherited;'
  
  elem: EntityNamePrim
   'en_' Self .Name
  ; // EntityNamePrim
  
  elem: EntityName
   Self .EntityNamePrim ', '
  ; // EntityName
  
  elem: OperationFullName
   Self .Parent .EntityName 'op_' Self .Name ', '
  ; // OperationFullName
  
  if ( Self .ImplementsSomeVCMOperation ) then
  begin
   [ \n 
     ' with Entities.Entities do' \n ]
   [ ' begin' ]
   VAR l_PublishedEntities
   [] &gt;&gt;&gt; l_PublishedEntities
   
   STRING elem_func OnGetTarget
     IN anEntity
    VAR l_Implementor 
    Self .Operations
    .filter&gt; ( .Implements .filter&gt; ( anEntity .IsSameModelElement ) .NotEmpty )
    .FirstElement &gt;&gt;&gt; l_Implementor
    RULES
     ( l_Implementor .NotIsNil )
      ( l_Implementor .MethodName )
     DEFAULT
      'nil'
    ; // RULES
    &gt;&gt;&gt; Result
   ; // OnGetTarget
   
   elem: PublishFormEntity
     IN anEntity
    anEntity .IfDefBraceLnBefore:  
    [ \n
     '  PublishFormEntity(' anEntity .EntityName Self anEntity .OnGetTarget ');' ]
   ; // PublishFormEntity 
   
   Self .ImplementsEx
   .filter&gt; .IsVCMOperations
   .filter&gt; ( .Name .AddToArray?: l_PublishedEntities )
   .for&gt; (
     IN anEntity
    Self anEntity .PublishFormEntity 
   ) // .for&gt;
   
   Self .Dependencies
   .filter&gt; .IsStereotype st_GroupItemsInContextMenu::Dependency
   .filter&gt; ( .Target .IsVCMOperations )
   .for&gt; (
     IN aDep
     [ \n '  GroupItemsInContextMenu(' aDep .Target .EntityNamePrim ');' ]
   ) // .for&gt;

   Self .Dependencies
   .filter&gt; .IsStereotype st_ToolbarAtBottom::Dependency
   .filter&gt; ( .Target .IsVCMOperations )
   .for&gt; (
     IN aDep
     [ \n '  ToolbarAtBottom(' aDep .Target .EntityNamePrim ');' ]
   ) // .for&gt;
   
   Self .Dependencies
   .filter&gt; .IsStereotype st_ContextMenuWeight::Dependency
   .filter&gt; ( .Target .IsVCMOperations )
   .filter&gt; ( .GetUP "Value" .IsIntEx )
   .for&gt; (
     IN aDep
     [ \n '  ContextMenuWeight(' aDep .Target .EntityName aDep .GetUP "Value" ');' ]
   ) // .for&gt;

   Self .OwnControls
   .for&gt; (
     IN aControl
    aControl .ImplementsEx
    .filter&gt; .IsVCMOperations
    .filter&gt; ( .Name .AddToArray?: l_PublishedEntities )
    .for&gt; (
      IN anEntity
     Self anEntity .PublishFormEntity 
    ) // .for&gt;
    aControl .ImplementsEx
    .filter&gt; .IsVCMOperations
    .for&gt; (
      IN anEntity
     [ \n '  MakeEntitySupportedByControl(' anEntity .EntityName aControl .Name ');' ]
    ) // .for&gt;
   ) // .for&gt;
   
   STRING elem_func PrefixParam
    if ( Self .UPisTrue "no prefix" ) then
     ', true'
    else
     ''
    &gt;&gt;&gt; Result  
   ; // PrefixParam
   
   elem: OperationOptions
    if ( Self .GetUP "ShowInContextMenu" IsBool ) then
    begin
     [ \n 
      '  ShowInContextMenu(' 
      Self .OperationFullName 
      Self .GetUP "ShowInContextMenu"
      Self .PrefixParam
      ');'
     ] 
    end // ( Self .GetUP "ShowInContextMenu" IsBool )
    
    if ( Self .GetUP "ShowInToolbar" IsBool ) then
    begin
     [ \n 
      '  ShowInToolbar(' 
      Self .OperationFullName 
      Self .GetUP "ShowInToolbar"
      Self .PrefixParam
      ');'
     ] 
    end // ( Self .GetUP "ShowInToolbar" IsBool )
    
    if ( Self .GetUP "ContextMenuWeight" .IsIntEx ) then
    begin
     [ \n 
      '  ContextMenuWeight(' 
      Self .OperationFullName 
      Self .GetUP "ContextMenuWeight"
      Self .PrefixParam
      ');'
     ] 
    end // ( Self .GetUP "ContextMenuWeight" .IsIntEx )
   ; // OperationOptions
   
   VAR l_PublishedOperations
   [] &gt;&gt;&gt; l_PublishedOperations
   
   Self .ImplementedEx
   .filter&gt; .IsVCMOperation
   .filter&gt; ( 
     IN anOperation
    anOperation .Parent .Name anOperation .Name Cat .AddToArray?: l_PublishedOperations 
   )
   .for&gt; (
     IN anOperation
    anOperation .IfDefBraceLnBefore: 
    [ \n
     '  ' 
     if ( anOperation .IsInternalOperation ) then
      'PublishOpWithResult'
     else
      'PublishOp'
     '(' anOperation .OperationFullName
     if (
         ( anOperation .UPisTrue "is FormActivate" ! )
         OR ( anOperation .IsInternalOperation )
        ) then
     begin
      if ( anOperation .IsInternalOperation ) then
      begin
       anOperation .MethodName
       // %o%f_pas_MethodName("callgate")
      end // ( anOperation .IsInternalOperation )
      else
      begin
       anOperation .AsExecuteDo: .MethodName
      end // ( anOperation .IsInternalOperation )
     end
     else
      'nil'
     ', ' 
     if ( anOperation .UPisTrue "is query" ! ) then
     begin
      anOperation .AsTestDo: .MethodName
     end // ( anOperation .UPisTrue "is query" ! )
     else
      'nil'
     ', ' 
     if ( anOperation .HasStates ) then
     begin
      anOperation .AsGetStateDo: .MethodName
     end // ( anOperation .HasStates )
     else
      'nil'
     anOperation .PrefixParam
     ');' 
    ]
    anOperation .OperationOptions
   ) // .for&gt; 
   
   Self .Overridden
   .filter&gt; .IsVCMOperation
   .for&gt; (
     IN anOperation
    anOperation .IfDefBraceLnBefore: 
     ( anOperation .OperationOptions )
   ) // .for&gt; 
   
   [ \n
     ' end;//with Entities.Entities' ]
  end // ( Self .ImplementsSomeVCMOperation )
  
  VAR l_PublishedExludes
  [] &gt;&gt;&gt; l_PublishedExludes
  
  Self .ChildrenEx
  .filter&gt; .IsExcludeUserTypes
  .filter&gt; ( .IsIncludeUserTypes ! )
  .for&gt; (
    IN anExclude
   VAR l_Excludes
   [] &gt;&gt;&gt; l_Excludes
   
   elem_proc CollectExcludedUserTypes
    Self .InheritsEx
    .filter&gt; .IsUserType
    .filter&gt; .AddToArray?: l_Excludes
    .for&gt; DROP
    
    Self .InheritsEx
    .filter&gt; .IsExcludeUserTypes
    .filter&gt; ( .IsIncludeUserTypes ! )
    .for&gt; call.me
   ; // CollectExcludedUserTypes
   
   anExclude .CollectExcludedUserTypes
   
   l_Excludes 
   .for&gt; (
     IN aUserType
    anExclude .ImplementedEx
    .filter&gt; .IsVCMOperation
    .filter&gt; ( 
      IN anOperation
     [ aUserType .Name anOperation .Parent .Name anOperation .Name ] strings:Cat .AddToArray?: l_PublishedExludes
    )
    .for&gt; (
      IN anOperation
     anOperation .IfDefBraceLnBefore:
     [ \n
       ' AddUserTypeExclude(' aUserType .Name 'Name' ', ' anOperation .OperationFullName  anOperation .UPisTrue "no prefix" ');' 
     ] 
    ) // .for&gt;
   ) // .for&gt;
  ) // .for&gt;
  
  Self .ChildrenEx
  .filter&gt; .IsIncludeUserTypes
  .for&gt; (
    IN anInclude
   VAR l_Includes
   [] &gt;&gt;&gt; l_Includes
   
   elem_proc CollectIncludedUserTypes
    Self .InheritsEx
    .filter&gt; .IsUserType
    .filter&gt; .AddToArray?: l_Includes
    .for&gt; DROP
    
    Self .InheritsEx
    .filter&gt; .IsIncludeUserTypes
    .for&gt; call.me
   ; // CollectIncludedUserTypes
   
   anInclude .CollectIncludedUserTypes
   
   Self .AllUserTypes
   .filter&gt; ( .NotInArray: l_Includes )
   .for&gt; (
     IN aUserType
    anInclude .ImplementedEx
    .filter&gt; .IsVCMOperation
    .filter&gt; ( 
      IN anOperation
     [ aUserType .Name anOperation .Parent .Name anOperation .Name ] strings:Cat .AddToArray?: l_PublishedExludes
    )
    .for&gt; (
      IN anOperation
     anOperation .IfDefBraceLnBefore:
     [ \n
       ' AddUserTypeExclude(' aUserType .Name 'Name' ', ' anOperation .OperationFullName  anOperation .UPisTrue "no prefix" ');' 
     ] 
    ) // .for&gt;
   ) // .for&gt;
  ) // .for&gt;
 ]
 &gt;&gt;&gt; Result
; // InitEntitiesUC

elem_iterator SignalDataSourceChangedUC
 [ 
  ' inherited;' \n
  ' if (aNew = nil) then' \n
  ' begin' \n
  Self .Attributes
  .filter&gt; .IsVCMController
  .for&gt; (
    IN anAttr
   [ '  ' anAttr .AttrName ' := ' 'nil' ';' \n ] 
  ) // .for&gt;
  ' end//aNew = nil' \n
  ' else' \n
  ' begin' \n
  Self .Attributes
  .filter&gt; .IsVCMController
  .for&gt; (
    IN anAttr
   RULES
    (
     ( anAttr .IsUseCaseController )
     OR ( anAttr .AttrType .IsUseCaseController )
    ) 
     [ 
       '  ' 'aNew.CastUCC(' anAttr .AttrType .TypeName ', ' anAttr .AttrName
       if ( anAttr .Name .IsNil ) then
        ', true'
       ')' ';' \n 
     ]
    ( anAttr .Name .IsNil )
     [
       '  ' anAttr .AttrName ' := aNew As ' anAttr .AttrType .TypeName ';' \n
     ]
    DEFAULT
     [
       '  ' 'Supports(aNew, ' anAttr .AttrType .TypeName ', ' anAttr .AttrName ');' \n
     ] 
   ; // RULES  
  ) // .for&gt;
  ' end;//aNew = nil'
 ]
 &gt;&gt;&gt; Result
; // SignalDataSourceChangedUC

elem_iterator OverriddenEx
 Cached:
 (
  VAR l_Overridden
  Self .Overridden &gt;&gt;&gt; l_Overridden
  
  l_Overridden
  
  if ( Self .IsClassOrMixIn ) then
  begin
   if ( Self .HasManagedAttributes ) then
   begin
    if ( Self GarantModel::l3UnknownPrim .InheritsFromOrSomeAncestorImplements ) then
    begin
     if ( l_Overridden GarantModel::l3UnknownPrim.ClearFields .HasModelElement ! ) then
     begin     
      .join&gt; ToArray: ( GarantModel::l3UnknownPrim.ClearFields .OverrideMethod )
     end // ( l_Overridden GarantModel::l3UnknownPrim.ClearFields .HasModelElement )
    end // ( Self GarantModel::l3UnknownPrim .InheritsFromOrSomeAncestorImplements )
   end // ( Self .HasManagedAttributes )
   
   if ( Self .IsScriptKeyword ) then
   begin
    if ( Self .IsMixIn ! ) then
    begin
     if ( Self .Abstraction at_abstract != ) then
     begin
      if ( Self GarantModel::TtfwRegisterableWord .InheritsFromOrSomeAncestorImplements ) then
      begin
       if ( l_Overridden GarantModel::TtfwRegisterableWord.GetWordNameForRegister .HasModelElement ! ) then
       begin     
        .join&gt; ToArray: ( GarantModel::TtfwRegisterableWord.GetWordNameForRegister .OverrideMethod )
       end // ( l_Overridden GarantModel::TtfwRegisterableWord.GetWordNameForRegister .HasModelElement )
      end // ( Self GarantModel::TtfwRegisterableWord .InheritsFromOrSomeAncestorImplements ) 
     end // ( Self .Abstraction at_abstract != )
    end // ( Self .IsMixIn ! )

    BOOLEAN VAR l_HasDoIt
    ( l_Overridden 
      .join&gt; ( Self .ImplementedEx ) 
      GarantModel::TtfwWordPrim.DoDoIt .HasModelElement )
    &gt;&gt;&gt; l_HasDoIt
    
    VAR l_Op
    Self .KeywordOperation &gt;&gt;&gt; l_Op
    if (
        ( l_Op .IsNotNil ) 
        AND ( l_Op .IsSomeKeyWord )
       ) then
    begin
     if (
          ( l_Op .GetUP "SupressNextImmediate" .IsNotNil )
          AND ( l_Op .GetUP "SupressNextImmediate" 'None' != )
        ) then
     begin
      if ( l_Overridden GarantModel::TtfwCompilingWord.SuppressNextImmediate .HasModelElement ! ) then
      begin     
       .join&gt; ToArray: ( GarantModel::TtfwCompilingWord.SuppressNextImmediate .OverrideMethod )
      end // ( l_Overridden GarantModel::TtfwCompilingWord.SuppressNextImmediate .HasModelElement ! )
     end // ( l_Op .GetUP "SupressNextImmediate" .IsNotNil )
     
     if ( l_Overridden GarantModel::TtfwWord.GetResultTypeInfo .HasModelElement ! ) then
     begin     
      .join&gt; ToArray: ( GarantModel::TtfwWord.GetResultTypeInfo .OverrideMethod )
     end // ( l_Overridden GarantModel::TtfwWord.GetResultTypeInfo .HasModelElement ! )
     
     if ( l_Overridden GarantModel::TtfwWord.GetAllParamsCount .HasModelElement ! ) then
     begin     
      .join&gt; ToArray: ( GarantModel::TtfwWord.GetAllParamsCount .OverrideMethod )
     end // ( l_Overridden GarantModel::TtfwWord.GetAllParamsCount .HasModelElement ! )
     
     if ( l_Op .IsVarWorker ) then
     begin
      if ( l_Overridden GarantModel::TtfwWord.RightParamsCount .HasModelElement ! ) then
      begin     
       .join&gt; ToArray: ( GarantModel::TtfwWord.RightParamsCount .OverrideMethod )
      end // ( l_Overridden GarantModel::TtfwWord.RightParamsCount .HasModelElement ! )
     end // ( l_Op .IsVarWorker )
     
     if ( l_Op .UPisTrue "bind params" ) then
     begin
      if ( l_Overridden GarantModel::TtfwClassLike.BindParams .HasModelElement ! ) then
      begin     
       .join&gt; ToArray: ( GarantModel::TtfwClassLike.BindParams .OverrideMethod )
      end // ( l_Overridden GarantModel::TtfwClassLike.BindParams .HasModelElement ! )
     end // ( l_Op .UPisTrue "bind params" )
     
     if ( l_Overridden GarantModel::TtfwWord.ParamsTypes .HasModelElement ! ) then
     begin     
      .join&gt; ToArray: ( GarantModel::TtfwWord.ParamsTypes .OverrideMethod )
     end // ( l_Overridden GarantModel::TtfwWord.ParamsTypes .HasModelElement ! )
     
     if ( 
         ( l_Op .GetUP 'extprop:prop_stereo' .IsValueValid )
         OR ( l_Op .UPisTrue "lvalue" )
        ) then
     begin
      if ( l_Overridden GarantModel::TtfwWord.SetValuePrim .HasModelElement ! ) then
      begin     
       .join&gt; ToArray: ( GarantModel::TtfwWord.SetValuePrim .OverrideMethod )
      end // ( l_Overridden GarantModel::TtfwWord.SetValuePrim .HasModelElement ! )
     end // ( l_Op .GetUP 'extprop:prop_stereo' .IsValueValid )
     
     if ( l_Op .IsVarWorker ) then
     begin
      if ( l_Overridden GarantModel::TtfwAnonimousWord.DoRun .HasModelElement ! ) then
      begin     
       .join&gt; ToArray: ( GarantModel::TtfwAnonimousWord.DoRun .OverrideMethod )
       true &gt;&gt;&gt; l_HasDoIt
      end // ( l_Overridden GarantModel::TtfwAnonimousWord.DoRun .HasModelElement ! )
     end // ( l_Op .IsVarWorker )
     else
     begin
      if ( l_HasDoIt ! ) then
      begin     
       .join&gt; ToArray: ( GarantModel::TtfwWordPrim.DoDoIt .OverrideMethod )
       true &gt;&gt;&gt; l_HasDoIt
      end // ( l_HasDoIt ! )
     end // ( l_Op .IsVarWorker )
     
    end // ( l_Op .IsNotNil )
    
    if ( l_HasDoIt ! ) then
    begin
     if ( 
         Self .InheritsEx 
         .filter&gt; ( GarantModel::TtfwRegisterableWord .IsSameModelElement )
         .NotEmpty 
        ) then
     begin
      //Self .Name Msg
      .join&gt; ToArray: ( GarantModel::TtfwWordPrim.DoDoIt .OverrideMethod )
     end // .filter&gt; ( GarantModel::TtfwRegisterableWord .IsSameModelElement )
    end // ( l_HasDoIt ! )
    
   end // ( Self .IsScriptKeyword )
   
   if ( Self .GetUP "is immediate" IsBool ) then
   begin
    if ( Self GarantModel::TtfwWord .InheritsFromOrSomeAncestorImplements ) then
    begin
     if ( l_Overridden GarantModel::TtfwWord.IsImmediate .HasModelElement ! ) then
     begin     
      .join&gt; ToArray: ( GarantModel::TtfwWord.IsImmediate .OverrideMethod )
     end // ( l_Overridden GarantModel::TtfwWord.IsImmediate .HasModelElement )
    end // ( Self GarantModel::TtfwWord .InheritsFromOrSomeAncestorImplements ) 
   end // ( Self .GetUP "is immediate" IsBool )
   
   RULES
    ( Self .IsInterfaceFactory )
     ()
    ( Self .IsWrapper )
     ()
    DEFAULT
     begin
      VAR l_Tag
      Self .ImplementsEx 
      .filter&gt; .IsTag
      .FirstElement &gt;&gt;&gt; l_Tag
      if ( l_Tag .NotIsNil ) then
      begin
       VAR l_GetTaggedDataType
       l_Overridden 
       .join&gt; ( Self .ImplementedEx ) 
       .filter&gt; ( GarantModel::k2TaggedDataHolder.GetTaggedDataType .IsSameModelElement )
       .FirstElement &gt;&gt;&gt; l_GetTaggedDataType
       
       if ( l_GetTaggedDataType .IsNil ) then
       begin
        .join&gt; ToArray: ( 
         GarantModel::k2TaggedDataHolder.GetTaggedDataType .OverrideMethod: (
           IN aMade
          aMade -&gt;^ cVarUserCodeName ^:= cEmptyUserCode
          aMade .AddMethodWithParams: cImplementationUserCodeName l_Tag ( 
            IN aTag
           [ 
            ' Result := k2_typ' aTag .Name ';'
           ]
          ) // aMade .AddMethodWithParams: cImplementationUserCodeName Self
         ) // GarantModel::k2TaggedDataHolder.GetTaggedDataType .OverrideMethod:
        ) // .join&gt; ToArray:
       end // ( l_GetTaggedDataType .IsNil )
       else
       begin
        l_GetTaggedDataType -&gt;^ cVarUserCodeName ^:= cEmptyUserCode
        l_GetTaggedDataType .AddMethodWithParams: cImplementationUserCodeName l_Tag ( 
          IN aTag
         [ 
          ' Result := k2_typ' aTag .Name ';'
         ]
        ) // aMade .AddMethodWithParams: cImplementationUserCodeName Self
       end // ( l_GetTaggedDataType .IsNil )
      end // ( l_Tag .NotIsNil )
     end // DEFAULT
   ; // RULES 
    
  end // ( Self .IsClassOrMixIn )
  
  if ( Self .IsTestCase ) then
  begin
   if ( Self GarantModel::TBaseTest .InheritsFromOrSomeAncestorImplements ) then
   begin
    if ( l_Overridden GarantModel::TAbstractTest.GetFolder .HasModelElement ! ) then
    begin     
     .join&gt; ToArray: ( GarantModel::TAbstractTest.GetFolder .OverrideMethod )
    end // ( l_Overridden GarantModel::TAbstractTest.GetFolder .HasModelElement )
    
    if ( l_Overridden GarantModel::TAbstractTest.GetModelElementGUID .HasModelElement ! ) then
    begin     
     .join&gt; ToArray: ( GarantModel::TAbstractTest.GetModelElementGUID .OverrideMethod )
    end // ( l_Overridden GarantModel::TAbstractTest.GetModelElementGUID .HasModelElement )
   end // ( Self GarantModel::TBaseTest .InheritsFromOrSomeAncestorImplements )
  end // ( Self .IsTestCase )
  
  if ( Self .IsVCMFormsPack ) then
  begin
   if ( Self .OperationsEx
        .filter&gt; .IsModuleOperationPrim
        .NotEmpty ) then
   begin     
    .join&gt; ToArray: ( 
     GarantModel::TComponent.Loaded .OverrideMethod: (
       IN aMade
      aMade -&gt;^ cVarUserCodeName ^:= cEmptyUserCode
      aMade .AddMethodWithParams: cImplementationUserCodeName Self (
        IN Self
       [ 
        ' inherited;' 
        Self .OperationsEx
        .filter&gt; .IsModuleOperationPrim
        .for&gt; (
          IN anOp
         anOp .IfDefBraceLnBefore: (
          [
           \n
           ' PublishOp(' 
           cQuote
           if ( anOp .UPisTrue "no prefix" ! ) then 
            'op' 
           anOp .Name
           cQuote
           ', '
           anOp .AsExecuteDo: .MethodName
           ', '
           if ( anOp .UPisTrue "no test" ) then
            'nil'
           else
           begin 
            anOp .AsTestDo: .MethodName
           end // ( anOp .UPisTrue "no test" )
           ');'
           
           if ( anOp .GetUP "ShowInToolbar" IsBool ) then
           begin
            \n
            ' ShowInToolbar(' 
            cQuote
            if ( anOp .UPisTrue "no prefix" ! ) then 
             'op' 
            anOp .Name
            cQuote
            ', '
            anOp .GetUP "ShowInToolbar"
            ');'
           end // ( anOp .GetUP "ShowInToolbar" IsBool )
           
           if ( anOp .GetUP "ShortCut" .NotIsNil ) then
           begin
            \n
            ' SetShortCut(' 
            cQuote
            if ( anOp .UPisTrue "no prefix" ! ) then 
             'op' 
            anOp .Name
            cQuote
            ', '
            cQuote
            anOp .GetUP "ShortCut"
            cQuote
            ');'
           end // ( anOp .GetUP "ShortCut" .NotIsNil )
          ] 
         ) // anOp .IfDefBraceLnBefore:
        ) // .for&gt;
       ] 
      ) // aMade .AddMethodWithParams: cImplementationUserCodeName Self (
     ) // GarantModel::TComponent.Loaded .OverrideMethod:
    ) // .join&gt; ToArray:
   end // Loaded
   
   if ( Self .ChildrenEx
        .filter&gt; .IsVCMForm
        .filter&gt; ( .Abstraction at_final == )
        .NotEmpty ) then
   begin     
    .join&gt; ToArray: ( 
     GarantModel::TvcmModule.GetEntityForms .OverrideMethod: (
       IN aMade
      aMade -&gt;^ cVarUserCodeName ^:= cEmptyUserCode
      aMade .AddMethodWithParams: cImplementationUserCodeName Self (
        IN Self
       [ 
        ' inherited;'
        Self .ChildrenEx
        .filter&gt; .IsVCMForm
        .filter&gt; ( .Abstraction at_final == )
        .for&gt; (
          IN aForm
         [
          \n 
          ' aList.Add(' aForm .TypeName ');'
         ] 
        ) // .for&gt;
       ]
      ) // aMade .AddMethodWithParams: cImplementationUserCodeName Self (
     ) // GarantModel::TvcmModule.GetEntityForms .OverrideMethod:
    ) // .join&gt; ToArray: ( 
   end // GetEntityForms
  end // ( Self .IsVCMFormsPack )
  
  if ( Self .IsViewAreaControllerImp ) then
  begin
   if ( Self .HasAnyVCMController ) then
   begin
    .join&gt; ToArray: (
     GarantModel::vcmFormDataSourcePrimWithFlexUseCaseControllerType.InitRefs .OverrideMethod: (
       IN aMade
      aMade -&gt;^ cVarUserCodeName ^:= cEmptyUserCode
      aMade .AddMethodWithParams: cImplementationUserCodeName Self (
        IN Self
       [
        ' inherited;'
        Self .Attributes
        .filter&gt; .IsVCMController
        .for&gt; (
          IN anAttr
         \n ' '
         if (
             ( anAttr .Name .IsNil )
             OR ( anAttr .Name 'SDS' == )
            ) then
         begin
          anAttr .AttrName ' := aDS As ' anAttr .AttrType .TypeName ';'
         end
         else
         begin
          'Supports(aDS, ' anAttr .AttrType .TypeName ', ' anAttr .AttrName ');'
         end 
        ) // .for&gt;
       ]
      ) // aMade .AddMethodWithParams: cImplementationUserCodeName Self
     ) // GarantModel::vcmFormDataSourcePrimWithFlexUseCaseControllerType.InitRefs .OverrideMethod:
    ) // .join&gt; ToArray:
    .join&gt; ToArray: (
     GarantModel::vcmFormDataSourcePrimWithFlexUseCaseControllerType.ClearRefs .OverrideMethod: (
       IN aMade
      aMade -&gt;^ cVarUserCodeName ^:= cEmptyUserCode
      aMade .AddMethodWithParams: cImplementationUserCodeName Self (
        IN Self
       [
        ' inherited;'
        Self .Attributes
        .filter&gt; .IsVCMController
        .for&gt; (
          IN anAttr
         \n ' ' anAttr .AttrName ' := nil;'
        ) // .for&gt;
       ]
      ) // aMade .AddMethodWithParams: cImplementationUserCodeName Self
     ) // GarantModel::vcmFormDataSourcePrimWithFlexUseCaseControllerType.ClearRefs .OverrideMethod:
    ) // .join&gt; ToArray:
   end // ( Self .HasAnyVCMController )
  end // ( Self .IsViewAreaControllerImp )

  if ( Self .IsVCMForm ) then
  begin
   if ( Self .HasAnyVCMController ) then
   begin
    .join&gt; ToArray: ( 
     GarantModel::vcmLayout.SignalDataSourceChanged .OverrideMethod: (
       IN aMade
      aMade -&gt;^ cVarUserCodeName ^:= cEmptyUserCode
      aMade .AddMethodWithParams: cImplementationUserCodeName Self .SignalDataSourceChangedUC
     ) // GarantModel::vcmLayout.SignalDataSourceChanged .OverrideMethod:
    ) // .join&gt; ToArray:
   end // ( Self .HasAnyVCMController )
   
   if ( Self .NeedsInitEntities ) then
   begin
    .join&gt; ToArray: ( 
     GarantModel::vcmLayout.InitEntities .OverrideMethod: (
       IN aMade
      aMade -&gt;^ cVarUserCodeName ^:= cEmptyUserCode
      aMade .AddMethodWithParams: cImplementationUserCodeName Self .InitEntitiesUC
     ) // GarantModel::vcmLayout.InitEntities .OverrideMethod:
    ) // .join&gt; ToArray:
   end // ( Self .NeedsInitEntities )
   
   if ( Self .NeedsMakeControls ) then
   begin   
    .join&gt; ToArray: ( 
     GarantModel::vcmLayout.MakeControls .OverrideMethod: (
       IN aMade
      aMade -&gt;^ cVarUserCodeName ^:= cEmptyUserCode
      aMade .AddMethodWithParams: cImplementationUserCodeName Self ( 
        IN aForm
       [ 
        ' inherited;'
        aForm .UserTypes
        .for&gt; (
          IN aUserType
         [ \n ' with AddUsertype(' aUserType .Name 'Name,' \n ]
         [ '  ' 'str_' aUserType .Name 'Caption,' \n ]
         [ 
           '  ' 'str_' aUserType .Name 
           if ( aUserType .GetUP "SettingsCaption" .NotIsNil ) then
            'Settings'
           'Caption,' \n 
         ]
         [ '  ' aUserType .GetUP "VisibleToUser" false ?!= ',' \n ]
         [ '  ' aUserType .GetUP "ImageIndex" ',' \n ]
         [ '  ' aUserType .GetUP "Weight" ',' \n ]
         [ '  ' 
           VAR l_UseToolbar
           aUserType .Attributes
           .filter&gt; ( .Name 'UseToolbarOfUserTypeName' == )
           .FirstElement &gt;&gt;&gt; l_UseToolbar
           if ( l_UseToolbar .IsNil ) then
           begin
            cQuote cQuote
           end // ( l_UseToolbar .IsNil )
           else
           begin
            l_UseToolbar .Target .Name 'Name'
           end // ( l_UseToolbar .IsNil )
           ',' \n ]
         [ '  ' 
           if ( aUserType .UPisTrue "NeedOnQueryMaximized" ) then
           begin
            aUserType .Name 'QueryMaximized' Cat .FromTie
           end // ( aUserType .UPisTrue "NeedOnQueryMaximized" )
           else
            'nil' 
           ',' \n ]
         [ '  ' 
           if ( aUserType .UPisTrue "NeedOnQueryOpen" ) then
           begin
            aUserType .Name 'QueryOpen' Cat .FromTie
           end // ( aUserType .UPisTrue "NeedOnQueryOpen" )
           else
            'nil' 
           ',' \n ]
         [ '  ' 
           if ( aUserType .UPisTrue "NeedOnQueryClose" ) then
           begin
            aUserType .Name 'QueryClose' Cat .FromTie
           end // ( aUserType .UPisTrue "NeedOnQueryClose" )
           else
            'nil' 
           ',' \n ]
         [ '  '
           RULES
            ( aUserType .UPisTrue "CanClose" )
             'vcm_ccEnable'
            ( aUserType .GetUP "CanClose" false ?== )
             'vcm_ccDisable'
            DEFAULT
             'vcm_ccNone' 
           ; // RULES
         ]
         [ ') do' \n ]
         [ ' begin' \n ]
         if ( aUserType .GetUP "CanHaveToolbars" false ?== ) then
         begin
          [ '  ' 'CanHaveToolbars := false;' \n ]
         end // ( aUserType .GetUP "CanHaveToolbars" false ?== )
         [ ' end;//with AddUsertype(' aUserType .Name 'Name' ]
        ) // .for&gt;
        
        STRING elem_func ControlParentName
         RULES
          ( Self .IsVCMCustomForm )
           'Self'
          DEFAULT
           ( Self .AttrName ) 
         ; // RULES
         &gt;&gt;&gt; Result
        ; // ControlParentName
        
        aForm .OwnControls
        .for&gt; (
          IN aControl
         aControl .IfDefBraceLnBefore: (
          if ( aControl .NeedPutToDFM ! ) then
          begin
           if ( aControl .IsControlOverride ! ) then
           begin
            [ \n ' ' 
              aControl .FieldName 
              ' := ' 
              aControl .AttrType .TypeName '.Create' 
              '('
              if ( aControl GarantModel::TvgReminder .InheritsFrom ) then
              begin
               aControl .Parent .ControlParentName
              end // ( aControl GarantModel::TvgReminder .InheritsFrom )
              else
               'Self' 
              ')'
              ';' 
            ]
            [ \n ' ' 
              aControl .FieldName 
              '.Name'
              ' := ' 
              cQuote aControl .Name cQuote
              ';'
            ]  
           end // ( aControl .IsControlOverride ! )
           if ( aControl GarantModel::TvgReminder .InheritsFrom ! ) then
           begin
            if ( aControl .IsComponent ! ) then
            begin
             [ \n ' ' 
               if ( aControl .IsControlOverride ) then
               begin
                aControl .AttrName 
               end // ( aControl .IsControlOverride )
               else
               begin
                aControl .FieldName 
               end // ( aControl .IsControlOverride )
               '.Parent'
               ' := ' 
               aControl .Parent .ControlParentName
               ';'
             ]  
             VAR l_Doc
             aControl .Documentation &gt;&gt;&gt; l_Doc
             if ( l_Doc .NotIsNil ) then
             begin
              if ( aControl .GetUP "need Caption" false ?!= ) then
              begin
               [ \n ' ' 
                 aControl .FieldName
                 '.Caption'
                 ' := ' 
                 cQuote l_Doc cQuote
                 ';'
               ]
              end // ( aControl .GetUP "need Caption" false ?!= )
             end // if ( l_Doc .NotIsNil )
            end // ( aControl .IsComponent ! )
           end // ( aControl GarantModel::TvgReminder .InheritsFrom ! )
          end // ( aControl .NeedPutToDFM ! )
          
          aControl .Zones
          .for&gt; (
            IN aZone
           [ 
             \n ' with DefineZone(vcm_zt' aZone .GetUP "ZoneType" ', ' 
             if ( aControl .NeedPutToDFM ) then
             begin
              aControl .AttrName
             end // ( aControl .NeedPutToDFM )
             else
             begin
              aControl .AttrName
              //aControl .FieldName
             end // ( aControl .NeedPutToDFM )
           ]
           [ ') do' \n ]
           [ ' begin' \n ]
           
           if ( aZone .UPisTrue "MergeTopTollbarWithContainer" ) then
           begin
            [ '  FormStyle.Toolbars.Top.MergeWithContainer := vcm_bTrue;' \n ]
           end // ( aZone .UPisTrue "MergeTopTollbarWithContainer" )
           
           if ( aZone .UPisTrue "MergeBottomTollbarWithContainer" ) then
           begin
            [ '  FormStyle.Toolbars.Bottom.MergeWithContainer := vcm_bTrue;' \n ]
           end // ( aZone .UPisTrue "MergeBottomTollbarWithContainer" )
           
           RULES
            ( aZone .UPisTrue "CanClose" )
             [ '  CanClose := vcm_ccEnable;' \n ]
            ( aZone .GetUP "CanClose" false ?== )
             [ '  CanClose := vcm_ccDisable;' \n ]
           ; // RULES
           
           if ( aZone .UPisTrue "Need UC" ) then
           begin
            HookOut: ( 
             Indented: 
              Indented: 
               ( aZone .UserCode: '' '!!!' ) 
            ) // HookOut:
           end // ( aZone .UPisTrue "Need UC" )
           
           [ ' end;//with DefineZone(vcm_zt' aZone .GetUP "ZoneType" ]
          ) // .for&gt;
         ) // aControl .IfDefBraceLnBefore:
        ) // .for&gt;
       ]
      ) // aMade .AddMethodWithParams: cImplementationUserCodeName Self
     ) // GarantModel::vcmLayout.MakeControls .OverrideMethod:
    ) // .join&gt; ToArray:
   end // MakeControls
  end // ( Self .IsVCMForm )
  
  if ( Self .IsUseCaseControllerImp ) then
  begin
   if ( Self .ImplementedEx .filter&gt; .IsVCMArea .NotEmpty ) then
   begin   
    if ( l_Overridden GarantModel::vcmFormSetDataSource.ClearAreas .HasModelElement ! ) then
    begin     
     .join&gt; ToArray: ( GarantModel::vcmFormSetDataSource.ClearAreas .OverrideMethod )
    end // ( l_Overridden GarantModel::vcmFormSetDataSource.ClearAreas .HasModelElement ! )
   end // ( Self .ImplementedEx .filter&gt; .IsVCMArea .NotEmpty )
  end // ( Self .IsUseCaseControllerImp )
 ) 
 &gt;&gt;&gt; Result
; // OverriddenEx

elem_iterator ImplementedAndOverridden
 Cached:
 (
  Self .ImplementedEx
  .join&gt; ( Self .OverriddenEx )
 ) 
 &gt;&gt;&gt; Result
; // ImplementedAndOverridden

elem_iterator NeededElements
 Cached:
 (
  if ( Self .IsScriptKeywordsPack ) then
  begin
   [empty]
  end // ( Self .IsScriptKeywordsPack ) 
  else
  begin 
   Self .NeededElementsFromInheritsOrImplements
  end // ( Self .IsScriptKeywordsPack )
  .join&gt; ( Self .AttributesAndOperationsNeededElements )
  if ( Self .IsTypedef ! ) then
  begin
   .join&gt; ( Self .ImplementedAndOverridden .OperationsNeededElements )
  end // Self .IsTypedef !
  if ( Self .IsClassOrMixIn ) then
  begin
   .joinWithLambded&gt; ( Self .ClassImplementsPrim ) .InterfaceForClassImplements
  end // ( Self .IsClassOrMixIn )
  .joinWithLambded&gt; ( Self .NeededElementsFromInheritsOrImplements .filter&gt; .IsMixIn ) call.me
  Self .NeededElementsFromInheritsOrImplements .filter&gt; .IsMixIn .for&gt; ( 
    IN anItem
   .joinWithLambded&gt; ( anItem .ConstantsAndChildrenWithoutOwnFile ) call.me
  )
 )
 &gt;&gt;&gt; Result
; // NeededElements

elem_iterator NeededElements:
  ^ IN aChildAcceptable
 if ( Self aChildAcceptable DO ) then
 begin 
  Self .NeededElements
 end // ( Self aChildAcceptable DO )
 else
  [empty]
 &gt;&gt;&gt; Result 
; // NeededElements:

elem_iterator NeededElementsTotal
  IN aChildAcceptable
  
 [empty]
  
 .joinWithLambded&gt; ( Self .ConstantsAndChildrenWithoutOwnFile .filter&gt; ( aChildAcceptable DO ) ) .NeededElements
 
 .joinWithLambded&gt; ( Self .ConstantsAndChildrenWithoutOwnFile ) ( aChildAcceptable call.me )
 
 &gt;&gt;&gt; Result
; // NeededElementsTotal

elem_iterator NeededElementsTotal:
  ^ IN aChildAcceptable
 Self aChildAcceptable .NeededElementsTotal
 &gt;&gt;&gt; Result
; // NeededElementsTotal:

BOOLEAN elem_func IsForInterfacePrim
 Cached:
 (
  RULES
   ( Self .Visibility PublicAccess == )
    true
   ( Self .Visibility ProtectedAccess == )
    true
   DEFAULT
    false 
  ; // RULES
 ) 
 &gt;&gt;&gt; Result
; // IsForInterfacePrim

BOOLEAN elem_func IsForInterface
 Cached:
 (
  RULES
   ( Self .Parent .IsNotNil )
    RULES
     ( Self .Parent call.me )
      ( Self .IsForInterfacePrim )
     DEFAULT
      false
    ; // RULES
   ( Self .IsForInterfacePrim )
    true  
   DEFAULT
    false
  ; // RULES
 ) 
 &gt;&gt;&gt; Result
; // IsForInterface

BOOLEAN elem_func IsForImplementation
 Cached:
 (
  Self .IsForInterface ! 
 ) 
 &gt;&gt;&gt; Result
; // IsForImplementation

elem_iterator DependsEx
 Cached:
 (
  Self .Depends
  array:Copy
 ) 
 &gt;&gt;&gt; Result
; // DependsEx

elem_iterator IntfUses
 Cached:
 (
  GarantModel::l3IntfUses .ToArray
  
  if ( Self .IsInterfaces ) then
  begin
   .join&gt; ( Self .DependsEx .filter&gt; .IsInterfaces )
  end // ( Self .IsInterfaces )
  
  .join&gt; ( Self .NeededElements: .IsForInterface )
  .join&gt; ( Self .NeededElementsTotal: .IsForInterface )
  
  if ( Self .IsControllerInterfaces ) then
  begin
   .join&gt; ToArray: GarantModel::vcmInterfaces 
   .join&gt; ToArray: GarantModel::vcmControllers
  end // ( Self .IsControllerInterfaces )
  
  if ( Self .IsVCMControls ) then
  begin
   .join&gt; ToArray: GarantModel::vcmExternalInterfaces 
  end // ( Self .IsVCMControls )
  
  if ( Self .IsVCMCustomForm ) then
  begin
   if ( Self .NeedsInitEntities ) then
   begin
    .join&gt; ToArray: GarantModel::vcmInterfaces
   end // ( Self .NeedsMakeControls )
   if ( Self .Abstraction at_final != ) then
   begin
    .join&gt; ToArray: GarantModel::vcmExternalInterfaces
    // - вообще это надо только для Internal операций
   end // ( Self .Abstraction at_final != )
   
   if ( Self .IsMixIn ! ) then
   begin
    //.join&gt; ToArray: ( Self .DefaultAncestor )
    .join&gt; ToArray: ( Self .MainAncestorThatNotMixIn )
   end // ( Self .IsMixIn ! )
   if ( Self .Abstraction at_final == ) then
   begin
    if ( Self .IsVCMForm ) then
    begin
     .join&gt; ToArray: GarantModel::TvcmEntities
    end // ( Self .IsVCMForm )
    .join&gt; ( 
     Self .AllControls
     .filter&gt; .NeedPutToDFM
     .join&gt; ( Self .OwnControls )
     .map&gt; .AttrType
     .filterNil&gt;
    ) // .join&gt;
   end // ( Self .Abstraction at_final == )
   else
   begin
    .join&gt; ( 
     Self .OwnControls
     .map&gt; .AttrType
     .filterNil&gt;
    ) // .join&gt;
   end // ( Self .Abstraction at_final == )
  end // ( Self .IsVCMCustomForm )
  
  if ( Self .IsVCMFormsPack ) then
  begin
   .join&gt; ToArray: GarantModel::vcmExternalInterfaces
   .join&gt; ToArray: GarantModel::TvcmModule
  end // ( Self .IsVCMFormsPack )
  
 ) 
 &gt;&gt;&gt; Result
; // IntfUses

BOOLEAN elem_func IsInjects
 Self .IsStereotype st_injects::Dependency 
 &gt;&gt;&gt; Result
; // IsInjects

elem_iterator InjectedElements
 Cached:
 (
  Self .Injected
  .filter&gt; .IsInjects
  .map&gt; .Parent
  .join&gt; ( Self '.pas.ms.script.inj' '_InjectedElements' .LoadList )
  array:Copy
 ) 
 &gt;&gt;&gt; Result
; // InjectedElements

BOOLEAN elem_func IsFactoryInTie
 ( Self .IsFactory )
 AND ( Self .InTie )
 &gt;&gt;&gt; Result
; // IsFactoryInTie

INTERFACE elem_func InstanceFreeMethod
 Cached:
 (
  VAR l_TypeName
  Self .TypeName &gt;&gt;&gt; l_TypeName
  l_TypeName 'Free' Cat MakeProcedure: ( 
    IN aMade
   aMade -&gt; %SUM := ( 'Метод освобождения экземпляра синглетона ' l_TypeName Cat )
   aMade -&gt; Visibility := PrivateAccess
   aMade -&gt; "ifdef" := ( Self .IfDefStr )
   aMade -&gt; "ifndef" := ( Self .IfNDefStr )
   aMade -&gt;^ cVarUserCodeName ^:= cEmptyUserCode
   aMade -&gt;^ cImplementationUserCodeName ^:= [ 
    if ( Self .HasFactory ) then
    begin
     ' IUnknown(' 'g_' l_TypeName ') := nil;' 
    end
    else
    begin
     ' l3Free(' 'g_' l_TypeName ');' 
    end // ( Self .HasFactory )
   ]
  ) 
 )
 &gt;&gt;&gt; Result
; // InstanceFreeMethod

elem_iterator GlobalOperationsPrim
 Cached:
 (
  RULES
   ( Self .IsInterface )
    ( 
     Self .OperationsEx
     .filter&gt; .IsStaticMethod
     .filter&gt; ( .IsFactoryInTie ! )
    ) 
   ( Self .IsRecord )
    ( 
     Self .OperationsEx
     .filter&gt; .IsConstructor
    ) 
   ( Self .IsUtilityPack )
    ( Self .OperationsEx )
   ( Self .IsClassOrMixIn ) 
    (
     if ( Self .IsSingleton ) then
     begin
      [ Self .InstanceFreeMethod ]
     end // ( Self .IsSingleton )
     else
      [empty]
    )
   DEFAULT
    [empty]
  ; // RULES
  
  VAR l_Operations
  array:Copy &gt;&gt;&gt; l_Operations
  l_Operations
  
  .joinWithLambded&gt; (
  Self .OperationsEx
  .filter&gt; .IsIterator
  .filter&gt; ( .IsServiceIterator ! )
  .filter&gt; ( .IsOverride ! )
  .filter&gt; ( l_Operations SWAP .IteratorStub .Name .HasModelElementWithName ! )
  ) ( .ToArray: .IteratorStub )
 )
 &gt;&gt;&gt; Result
; // GlobalOperationsPrim

elem_iterator GlobalOperations
 Self .GlobalOperationsPrim
 .filter&gt; ( .IsIni ! )
 .filter&gt; ( .IsFini ! )
 .filter&gt; ( .IsKeyWord ! )
 .filter&gt; ( .IsGlobalKeyWord ! )
 &gt;&gt;&gt; Result
; // GlobalOperations

elem_iterator OperationsUsed
 [empty]
 .joinWithLambded&gt; ( Self .OperationsEx ) .UsesInDependencies
 
 .joinWithLambded&gt; (
  Self .GlobalOperations
  .filter&gt; .IsStaticOp
  .filter&gt; ( .UPisTrue 'extprop:isAsm' )
 ) ( DROP ToArray: GarantModel::l3LocalStub )
 
 .joinWithLambded&gt; ( Self .OperationsEx ) call.me
 &gt;&gt;&gt; Result
; // OperationsUsed

ModelElement elem_func SetType
 Cached:
 (
  Self .ImplementsEx
  .filter&gt; .IsUseCaseController
  .FirstElement &gt;&gt;&gt; Result
  if ( Result .IsNil ) then
  begin
   Self .InheritsEx
   .filter&gt; .IsUseCaseControllerImp
   .filter&gt; ( DROP Result .IsNil )
   .for&gt; (
     IN aG
    aG .ImplementsEx
    .filter&gt; .IsUseCaseController
    .FirstElement &gt;&gt;&gt; Result
   ) // .for&gt;
  end // ( Result .IsNil )
  Result
 )
 &gt;&gt;&gt; Result
; // SetType

ModelElement elem_func FormDataSourceType
 Cached:
 (
  Self .ImplementsEx
  .filter&gt; .IsViewAreaController
  .filter&gt; ( .Abstraction at_abstract != )
  .FirstElement &gt;&gt;&gt; Result
  if ( Result .IsNil ) then
  begin
   Self .InheritsEx
//   .filter&gt; .IsViewAreaControllerImp
   .filter&gt; ( DROP Result .IsNil )
   .for&gt; (
     IN aG
    aG .ImplementsEx
    .filter&gt; .IsViewAreaController
    .filter&gt; ( .Abstraction at_abstract != )
    .FirstElement &gt;&gt;&gt; Result
   ) // .for&gt;
  end // ( Result .IsNil )
  Result
 )
 &gt;&gt;&gt; Result
; // FormDataSourceType

elem_iterator MixInValues
 Cached:
 (
  Self .Attributes
  .filter&gt; ( .IsStereotype st_impurity_value::Attribute )
  
  if ( Self .IsUseCaseControllerImp ) then
  begin
   if ( Self .Abstraction at_abstract != ) then
   begin
    VAR l_MixInValues
    DUP &gt;&gt;&gt; l_MixInValues
    if ( l_MixInValues 'SetType' .HasModelElementWithName ! ) then
    begin
     VAR l_SetType
     Self .SetType &gt;&gt;&gt; l_SetType
     if ( l_SetType .NotIsNil ) then
     begin
      .join&gt; ToArray: (
       'SetType' l_SetType MakeField
      ) // .join&gt; ToArray:
     end // ( l_SetType .NotIsNil )
    end // ( l_MixInValues 'SetType' .HasModelElementWithName ! )
   end // ( Self .Abstraction at_abstract != )
  end // ( Self .IsUseCaseControllerImp )

  if ( Self .IsViewAreaControllerImp ) then
  begin
   if ( Self .Abstraction at_final == ) then
   begin
    VAR l_MixInValues
    DUP &gt;&gt;&gt; l_MixInValues
    if ( l_MixInValues 'FormDataSourceType' .HasModelElementWithName ! ) then
    begin
     VAR l_SetType
     Self .FormDataSourceType &gt;&gt;&gt; l_SetType
     if ( l_SetType .NotIsNil ) then
     begin
      .join&gt; ToArray: (
       'FormDataSourceType' l_SetType MakeField
      ) // .join&gt; ToArray:
     end // ( l_SetType .NotIsNil )
    end // ( l_MixInValues 'SetType' .HasModelElementWithName ! )
   end // ( Self .Abstraction at_abstract != )
  end // ( Self .IsViewAreaControllerImp )
 )
 &gt;&gt;&gt; Result
; // MixInValues

BOOLEAN elem_func InheritsOrImplementsMixIn
 Cached:
 (
  RULES
   ( Self .InheritsEx .filter&gt; .IsMixIn .NotEmpty )
    true
   ( Self .ImplementsEx .filter&gt; .IsMixIn .NotEmpty )
    true
   DEFAULT
    false
  ; // RULES 
 )
 &gt;&gt;&gt; Result
; // InheritsOrImplementsMixIn

BOOLEAN elem_func ImplementsMixIn
 Cached:
 (
  RULES
   //( Self .InheritsEx .filter&gt; .IsMixIn .NotEmpty )
   // true
   ( Self .ImplementsEx .filter&gt; .IsMixIn .NotEmpty )
    true
   DEFAULT
    false
  ; // RULES 
 )
 &gt;&gt;&gt; Result
; // ImplementsMixIn

elem_iterator OtherMixinValuesUses
 [empty]
 .joinWithLambded&gt; ( Self .InheritsEx ) ( .MixInValues .mapToTarget&gt; )
 .joinWithLambded&gt; ( Self .InheritsEx ) call.me
 &gt;&gt;&gt; Result
; // OtherMixinValuesUses

BOOLEAN elem_func IsClass
 Self .IsSimpleClass &gt;&gt;&gt; Result
; // IsClass

BOOLEAN elem_func NeedRegisterInScriptsPrim
 Cached:
 (
  RULES
   ( Self .GetUP "register in scripts" false ?== )
    false
   ( Self .UPisTrue "register in scripts" )
    true
   ( Self .InheritsEx .filter&gt; call.me .NotEmpty )
    true
   ( Self .IsGuiControl )
    true 
   DEFAULT
    false
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // NeedRegisterInScriptsPrim

BOOLEAN elem_func NeedRegisterInScripts
 Cached:
 (
  RULES
   ( Self .IsMixIn )
    false
   ( Self .IsVCMCustomForm )
    true
   ( Self .NeedRegisterInScriptsPrim )
    RULES
     ( Self .Name 'Hack' string:Pos -1 != )
      false
     ( Self .IsMixIn )
      false 
     ( Self .Abstraction at_abstract == ) 
      true
     ( Self .IsScriptKeyword )
      false
     ( Self .IsTestClass ) 
      false
     ( Self .IsClass )
      true 
     ( Self .IsEnum )
      true 
     ( Self .IsException )
      true
     ( Self .IsInterface )
      true
     DEFAULT
      false
    ; // RULES
   DEFAULT
    false
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // NeedRegisterInScripts

elem_iterator ImplementsIsInterface
 Cached:
 (
  Self .ImplementsEx .filter&gt; .IsInterface
 ) 
 &gt;&gt;&gt; Result
; // ImplementsIsInterface

elem_iterator Used
 Cached:
 (
  Self .UsesInDependencies
  if ( Self .IsInterface ! ) then
  begin
   .join&gt; ( Self .InjectedElements )
   .joinWithLambded&gt; ( Self .ImplementsIsInterface ) .InjectedElements
  end // Self .IsInterface !
  .joinWithLambded&gt; ( Self .InheritsEx .filter&gt; .IsMixIn ) call.me
  .joinWithLambded&gt; ( Self .ImplementsEx .filter&gt; .IsMixIn ) call.me
  .join&gt; ( Self .OperationsUsed )
  
  if ( Self .IsVCMForm ) then
  begin
   .joinWithLambded&gt; ( Self .OwnControls ) ( .ImplementsEx .filter&gt; .IsVCMOperations )
   .joinWithLambded&gt; ( Self .ChildrenEx .filter&gt; .IsExcludeUserTypes ) ( .ImplementedEx .filter&gt; .IsVCMOperation )
   .join&gt; ( Self .OverriddenEx .filter&gt; .IsVCMOperation )
   .join&gt; ( Self .ImplementedEx .filter&gt; .IsVCMOperation )
   if ( Self .HasFactory ) then
   begin
    .join&gt; ToArray: GarantModel::vcmBase
    .join&gt; ToArray: GarantModel::l3Base
   end // ( Self .HasFactory )
  end // ( Self .IsVCMForm )
  
  if ( Self .IsFormSetFactory ) then
  begin
   .join&gt; ToArray: GarantModel::vcmBase
  end // ( Self .IsFormSetFactory )
  
  if ( Self .InheritsOrImplementsMixIn ) then
  begin
   .join&gt; ( Self .OtherMixinValuesUses )
  end // ( Self .InheritsOrImplementsMixIn )
  
  if ( Self .IsSingleton ) then
  begin
   .join&gt; ToArray: GarantModel::SysUtils 
   .join&gt; ToArray: GarantModel::l3Base
  end // ( Self .IsSingleton )

  if ( Self .IsViewAreaControllerImp ) then
  begin
   if ( Self .HasAnyVCMController ) then
   begin
    .join&gt; ToArray: GarantModel::SysUtils
   end // ( Self .HasAnyVCMController )
  end // ( Self .IsViewAreaControllerImp )

  if ( Self .IsMessage ) then
  begin
   .join&gt; ToArray: GarantModel::Dialogs
  end // ( Self .IsMessage )
  
  if ( Self .IsClassOrMixIn ) then
  begin
   if ( Self .ImplementedAndOverridden 
        .filter&gt; .IsIterator 
        .NotEmpty ) then
   begin
    .join&gt; ToArray: GarantModel::l3Base 
   end // ( Self .ImplementedAndOverridden .filter&gt; .IsIterator .NotEmpty )
   .joinWithLambded&gt; ( Self .ImplementedAndOverridden ) .UsesInDependencies
   .join&gt; ( Self .ImplementsEx .filter&gt; .IsTag )
  end // ( Self .IsClassOrMixIn )
  
  if ( Self .NeedRegisterInScripts ) then
  begin
   RULES
    ( Self .IsEnum )
     begin
      .join&gt; ToArray: GarantModel::TtfwTypeRegistrator(Proxy)
     end // ( Self .IsEnum )
    ( Self .IsException )
     begin
      .join&gt; ToArray: GarantModel::TtfwTypeRegistrator(Proxy)
     end // ( Self .IsException )
    ( Self .IsInterface )
     begin
      .join&gt; ToArray: GarantModel::TtfwTypeRegistrator(Proxy)
     end // ( Self .IsInterface )
    ( Self GarantModel::TtfwWord .InheritsFrom ! )
     begin
      .join&gt; ToArray: GarantModel::TtfwClassRef(Proxy) 
     end // ( Self GarantModel::TtfwWord .InheritsFrom ! )
   ; // RULES
  end // ( Self .NeedRegisterInScripts )
  
  if ( Self .IsTestCase ) then
  begin
   .join&gt; ToArray: GarantModel::TestFrameWork 
  end // ( Self .IsTestCase )  
  
  if ( Self .IsScriptKeywordsPack ) then
  begin
   if (
       Self .InheritsEx
       .filter&gt; .IsVCMCustomForm
       .filter&gt; ( .Abstraction at_final == )
       .NotEmpty
      ) then
   begin
    Self .InheritsEx
    .filter&gt; .IsVCMCustomForm
    .filter&gt; ( .Abstraction at_final == )
    .for&gt; (
      IN aForm
     .join&gt; ( 
      aForm .AllControls
      .map&gt; .AttrType
      .filterNil&gt;
     ) // .join&gt;
    ) // .for&gt;
    .join&gt; ToArray: GarantModel::TtfwClassRef(Proxy) 
   end // .filter&gt; .IsVCMCustomForm
  end // ( Self .IsScriptKeywordsPack )
  
  if ( Self .IsVCMCustomForm ) then
  begin
   if (
       ( Self .NeedsMakeControls )
       OR ( Self .NeedsInitEntities )
      ) then
   begin
    .join&gt; ToArray: GarantModel::vcmInterfaces
   end // ( Self .NeedsMakeControls )
  end // ( Self .IsVCMCustomForm )
  
  .joinWithLambded&gt;
  ( Self .UsesInDependencies
    .filter&gt; .IsVCMCustomForm )
  ( .UserTypes )
  
  if ( Self .IsVCMCustomForm ) then
  begin
   .join&gt; ( Self .ChildrenWithOwnFile )
   if ( Self .HasAnyVCMController ) then
   begin
    .join&gt; ToArray: GarantModel::SysUtils
   end // ( Self .HasAnyVCMController )
  end // ( Self .IsVCMCustomForm )
  
  if ( Self .IsUseCaseControllerImp ) then
  begin
   if ( Self .ImplementedEx .filter&gt; .IsVCMArea .NotEmpty ) then
   begin   
    .join&gt; ToArray: GarantModel::TvcmViewAreaControllerRef
   end // ( Self .ImplementedEx .filter&gt; .IsVCMArea .NotEmpty )
  end // ( Self .IsUseCaseControllerImp )
  
  if ( Self .IsScriptKeyword ) then
  begin
   if ( Self GarantModel::TtfwModuleOperationWord .InheritsFromOrSomeAncestorImplements ) then
   begin
    .join&gt; ToArray: GarantModel::StdRes
   end // ( Self GarantModel::TtfwModuleOperationWord .InheritsFromOrSomeAncestorImplements )
  end // ( Self .IsScriptKeyword )

  if ( Self .IsVCMApplication ) then
  begin
   Self @ (
     IN anOp
    .join&gt; ToArray: anOp
   ) .IterateVCMFormsPacksFromApplication
   Self @ (
     IN anOp
    .join&gt; ToArray: anOp
   ) .OutRecall
  end // ( Self .IsVCMApplication )
  
  if ( Self .IsVCMControls ) then
  begin
   .join&gt; ToArray: GarantModel::TvcmOperationsForRegister
   .join&gt; ToArray: GarantModel::TvcmOperationStateForRegister
  end // ( Self .IsVCMControls )

  if ( Self .IsVCMFormsPack ) then
  begin
   if ( Self .Abstraction at_final == ) then
   begin
    .join&gt; ToArray: GarantModel::TvcmModulesForRegister
    .join&gt; ToArray: GarantModel::TvcmModuleOperationsForRegister
   end // ( Self .Abstraction at_final == )
  end // ( Self .IsVCMFormsPack )

  .join&gt; ( Self .UsedElements )
  array:CopyWithoutDuplicates
 )
 &gt;&gt;&gt; Result
; // Used

elem_iterator UsedTotal
 Self .Used
 .joinWithLambded&gt; ( Self .AllOwnChildren ) call.me
 &gt;&gt;&gt; Result
; // UsedTotal

elem_iterator AbstractUses
 Cached:
 (
  [empty]
  ( 
   Self .InheritsEx
   .filter&gt; .IsSimpleClass 
   .filter&gt; ( .Abstraction at_abstract == )
  ) .for&gt; ( 
    IN aG
   .joinWithLambded&gt; ( 
    aG .ImplementsEx
    .filter&gt; .IsMixIn
   ) // .joinWithLambded&gt; 
   .UsesInDependencies
   .join&gt; ( aG call.me ) 
  ) // .for&gt;
 ) 
 &gt;&gt;&gt; Result
; // AbstractUses

BOOLEAN elem_func IsTestForTestLibrary
 RULES
  ( Self .IsTestClass )
   true
  ( Self .IsTestCaseMixIn )
   true
  ( Self .IsTestCase )
   RULES
    ( Self .Abstraction at_abstract == )
     false
    DEFAULT
     true
   ; // RULES 
  DEFAULT
   false
 ; // RULES
 &gt;&gt;&gt; Result
; // IsTestForTestLibrary

elem_iterator DependsVCMGUI
 Cached:
 (
  Self .DependsEx
  .filter&gt; .IsVCMGUI
  array:Copy
 ) 
 &gt;&gt;&gt; Result
; // DependsVCMGUI

elem_iterator DependsTestLibrary
 Cached:
 (
  Self .DependsEx
  .filter&gt; .IsTestLibrary
  array:Copy
 )
 &gt;&gt;&gt; Result
; // DependsTestLibrary

ARRAY FUNCTION .fold&gt;
  ARRAY IN anArray
 %SUMMARY
  'Преобразует список списков в один плоский список.'
 ;
 [empty]
 anArray .for&gt; ( SWAP JOIN )
 &gt;&gt;&gt; Result
; // .fold&gt;

ARRAY FUNCTION .transform&gt;
  ARRAY IN anArray
  ^ IN aLambda
 %SUMMARY
  'Применяет aLambda к каждому элементу anArray.'
  'Предполагается, что aLambda возвращает список.'
  'Результатом явлется объединённый список результатов aLambda.'
 ;
 anArray
 .map&gt; ( aLambda DO )
 .fold&gt;
 &gt;&gt;&gt; Result
; // .transform&gt;

elem_iterator ImplUses
 Cached:
 (
  GarantModel::l3ImplUses .ToArray
  if ( Self .IsScriptKeywordsPack ) then
  begin
   .join&gt; ( Self .NeededElementsFromInheritsOrImplements )
  end // ( Self .IsScriptKeywordsPack )  
  
  .join&gt; ( Self .NeededElements: .IsForImplementation )
  .join&gt; ( Self .NeededElementsTotal: .IsForImplementation )
  .join&gt; ( Self .UsedTotal )
  
  if ( Self .IsScriptKeywordsPack ) then
  begin
   .join&gt; ( Self .ChildrenWithOwnFile )
   .join&gt; ToArray: GarantModel::SysUtils
   .join&gt; ToArray: GarantModel::TtfwTypeRegistrator(Proxy)
   .join&gt; ToArray: GarantModel::TypeInfoExt
  end // ( Self .IsScriptKeywordsPack )
  
  if ( Self .IsTarget ) then
  begin
   .join&gt; ( Self .ChildrenWithOwnFile )
  end // ( Self .IsTarget )
  
  if ( Self .IsVCMFormsPack ) then
  begin
   .join&gt; ( Self .ChildrenWithOwnFile )

   .join&gt; (
    Self .ChildrenWithOwnFile
    .map&gt; .ImplementsEx
    .fold&gt;
    .filter&gt; .IsVCMFormDefinition
   ) // .join&gt;
  end // ( Self .IsVCMFormsPack )
  
  if ( Self .IsVCMForm ) then
  begin
   if ( Self .Abstraction at_final != ) then
   begin
    .join&gt; ToArray: GarantModel::StdRes
   end // ( Self .Abstraction at_final != )
  end // ( Self .IsVCMForm )
  
  if ( Self .IsVCMFormSetFactory ) then
  begin
   .join&gt; ToArray: GarantModel::SysUtils
   .join&gt; ( Self .ChildrenWithOwnFile )
  end // ( Self .IsVCMFormSetFactory )
  
  if ( Self .IsVCMApplication ) then
  begin
   .join&gt; ( Self .ChildrenWithOwnFile )
   .join&gt; ToArray: GarantModel::evExtFormat
   if ( Self .Abstraction at_final == ) then
   begin
    .join&gt; ToArray: GarantModel::StdRes
   end // ( Self .Abstraction at_final == )
  end // ( Self .IsVCMApplication )
  
  if ( Self .IsVCMUseCaseRealization ) then
  begin
   .join&gt; ( Self .ChildrenWithOwnFile )
  end // ( Self .IsVCMUseCaseRealization )
  
  if ( Self .IsTestLibrary ) then
  begin
   .join&gt; ( Self .ChildrenWithOwnFile .filter&gt; .IsTestUnit )
  end // ( Self .IsTestLibrary )
  
  if ( Self .IsTestUnit ) then
  begin
   .join&gt; ( Self .ChildrenWithOwnFile .filter&gt; .IsTestForTestLibrary )
  end // ( Self .IsTestUnit )
  
  if ( Self .IsClassOrMixIn ) then
  begin
   .join&gt; ( Self .AbstractUses )
  end // ( Self .IsClassOrMixIn )
   
  if ( Self .IsTestClass ) then
  begin
   .join&gt; ToArray: GarantModel::Variants 
   .join&gt; ToArray: GarantModel::ActiveX 
   .join&gt; ToArray: GarantModel::tc5OpenAppClasses 
   .join&gt; ToArray: GarantModel::tc5PublicInfo 
   .join&gt; ToArray: GarantModel::tc6OpenAppClasses 
   .join&gt; ToArray: GarantModel::tc6PublicInfo
  end // ( Self .IsTestClass )
   
  if ( Self .Name 'l3IID' == ) then
  begin
   .join&gt; ToArray: GarantModel::Windows 
   .join&gt; ToArray: GarantModel::SysUtils
  end // ( Self .Name 'l3IID' == )
  
  RULES
   ( Self .IsTestTarget )
    begin
     .join&gt; ToArray: GarantModel::SysUtils
     .join&gt; ToArray: GarantModel::l3Base
     .join&gt; ToArray: GarantModel::TKBridge
     .join&gt; ToArray: GarantModel::KTestRunner
     .join&gt; ToArray: GarantModel::TextTestRunner
     .join&gt; ToArray: GarantModel::GUITestRunner
     if ( Self .UPisTrue "no scripts" ! ) then
     begin
      .join&gt; ToArray: GarantModel::TvcmInsiderTest 
     end // ( Self .UPisTrue "no scripts" ! )
    end // ( Self .IsTestTarget )
  ; // RULES 
  
  RULES
   ( Self .IsVCMTestTarget )
    begin
     RULES
      (
       Self .DependsVCMGUI
       .filter&gt; ( .GetUP "F1Like" false ?== )
       .IsEmpty
      )
       ( .join&gt; ToArray: GarantModel::TF1AutoTestSuite )
      DEFAULT
       ( .join&gt; ToArray: GarantModel::TAutoTestsSuite )
     ; // RULES 
     .join&gt; ToArray: GarantModel::StdRes
    end // ( Self .IsVCMTestTarget )
   ( Self .IsTestTarget )
    begin
     if ( Self .UPisTrue "is insider test" ! ) then
     begin
      if ( Self .UPisTrue "no scripts" ! ) then
      begin
       .join&gt; ToArray: GarantModel::TAutoTestsSuite
       .join&gt; ToArray: GarantModel::TtfwScriptEngineEX
      end // ( Self .UPisTrue "no scripts" ! )
     end // ( Self .UPisTrue "is insider test" ! )
    end // ( Self .IsTestTarget )
   ( Self .IsVCMGUI ) 
    ( .join&gt; ToArray: GarantModel::StdRes )
  ; // RULES
  
  RULES
   ( Self .IsTestLibrary )
    begin
     .join&gt; ( Self .DependsTestLibrary )
          
     RULES
      (
       Self .ChildrenEx 
       .filter&gt; .IsTestUnit 
       .filter&gt; ( 
        .ChildrenEx 
        .filter&gt; .IsTestClass 
        .NotEmpty
       ) // .filter&gt;
       .NotEmpty
      )
      begin
       .join&gt; ToArray: GarantModel::tc5OpenApp 
       .join&gt; ToArray: GarantModel::tc6OpenApp
      end
     ; // RULES
    end // ( Self .IsTestLibrary )
   ( Self .IsTestTarget )
    begin
    
     VAR l_Parent
     Self .Parent &gt;&gt;&gt; l_Parent
     
     // Сначала перебираем чужие тестовые библиотеки:
     .join&gt; (
      Self .DependsTestLibrary
      .filter&gt; ( .Parent l_Parent .IsSameModelElement ! )
      array:Copy
     ) // .join&gt;
     
     // Потом перебираем свои тестовые библиотеки:
     .join&gt; (
      Self .DependsTestLibrary
      .filter&gt; ( .Parent l_Parent .IsSameModelElement )
      array:Copy
     ) // .join&gt;
     
    end // ( Self .IsTestTarget ) 
   ( Self .IsDLL ) 
    begin
     VAR l_Parent
     Self .Parent &gt;&gt;&gt; l_Parent
     
     Self .DependsEx
     .filter&gt; .IsLibrary
     .filter&gt; ( .Parent l_Parent .IsSameModelElement )
     .for&gt; (
       IN aLibrary
      
      aLibrary .ChildrenEx
      .for&gt; (
        IN aChild
       .join&gt; ToArray: aChild
      ) // .for&gt;
       
      aLibrary .ChildrenEx 
      .filter&gt; .IsUnit
      .for&gt; (
        IN aUnit
       aUnit .ChildrenEx 
       .for&gt; (
         IN aClass
        .join&gt; ToArray: aClass
       ) // .for&gt;
      ) // .for&gt;
     ) // .for&gt;
    end // ( Self .IsDLL )
   ( Self .IsVCMGUI )
    begin
     .join&gt; ( Self .DependsTestLibrary )
     
     Self .DependsEx
     .filter&gt; .IsVCMUseCase
     .for&gt; (
       IN aUseCase
      aUseCase .ChildrenEx
      .filter&gt; .IsVCMUseCaseRealization
      .for&gt; (
        IN aUseCaseRealization
       .join&gt; ToArray: aUseCaseRealization
      ) // .for&gt;
     ) // .for&gt;
    end // ( Self .IsVCMGUI )
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // ImplUses

elem_iterator IntfAndImplUses
 Self .IntfUses
 .join&gt; ( Self .ImplUses )
 &gt;&gt;&gt; Result
; // IntfAndImplUses

elem_iterator ProjectUsesPrim
 Cached:
 (
  GarantModel::l3IntfUses .ToArray
  
  RULES
   ( Self .IsVCMGUI )
    begin
     if ( Self .GetUP "F1Like" false ?!= ) then
     begin
      .join&gt; ToArray: GarantModel::nsApplication 
     end // ( Self .GetUP "F1Like" false ?!= )
     .join&gt; ToArray: GarantModel::Tl3ExceptionsLog 
     .join&gt; ToArray: GarantModel::ControlResizeBugFix
    end // ( Self .IsVCMGUI )
   ( Self .IsVCMTestTarget )
    begin
     .joinWithLambded&gt; ( Self .DependsVCMGUI ) call.me
    end // ( Self .IsVCMTestTarget )
   ( Self .IsExe )
    begin
     .join&gt; ToArray: GarantModel::Tl3ExceptionsLog 
     if ( Self .UPisTrue "console" ! ) then
     begin
      .join&gt; ToArray: GarantModel::ControlResizeBugFix
     end // ( Self .UPisTrue "console" ! )
    end // ( Self .IsExe )
  ; // RULES
  
  .join&gt; ( Self .IntfAndImplUses )
  
  RULES
   ( Self .IsVCMGUI )
    begin
     .join&gt; ToArray: GarantModel::Tl3MouseWheelHelper
    end // ( Self .IsVCMGUI )
  ; // RULES
  
  ARRAY VAR l_Uses
  [] &gt;&gt;&gt; l_Uses
  
  .mapToUnitProducer&gt;
  //.filter&gt; ( Self ?!= )
  .filter&gt; ( .NotInArray: l_Uses )
  // - возможно это стоит включить, а также включить сюда фильтрацию дубликатов
  //   чтобы уменьшить повторно выполняемую работу в ProjectUses AccumulateUses
  .for&gt; (
   .AddToArray: l_Uses
  ) // .for&gt;
  
  l_Uses
 )
 &gt;&gt;&gt; Result
; // ProjectUsesPrim

elem_iterator ProjectUses
 ARRAY VAR l_ProjectUses
 [] &gt;&gt;&gt; l_ProjectUses
 ARRAY VAR l_InUses
 [] &gt;&gt;&gt; l_InUses
 
 PROCEDURE AccumulateUses
   ARRAY IN aUses
  aUses 
  .filter&gt; .AddToArray?: l_InUses
  .for&gt; (
    IN anItem
   anItem .AddToArray: l_ProjectUses
   RULES
    ( anItem IsString )
     ()
    DEFAULT
     ( anItem .ProjectUsesPrim call.me ) 
   ; // RULES 
  ) // .for&gt;
 ; // AccumulateUses
 
 Self .ProjectUsesPrim AccumulateUses
 
 l_ProjectUses
 &gt;&gt;&gt; Result
; // ProjectUses
     
ModelElement elem_func SecondAttribute
 Cached:
 (
  Self .Attributes .SecondElement
 )
 &gt;&gt;&gt; Result
; // SecondAttribute

STRING elem_func FineDocumentation
 Self .Documentation &gt;&gt;&gt; Result
 if ( Result .IsNotNil ) then
 begin
  Result cOpenComment '[' string:Replace &gt;&gt;&gt; Result
  Result cCloseComment ']' string:Replace &gt;&gt;&gt; Result
  [ cOpenComment '* ' Result cSpace cCloseComment ] strings:Cat &gt;&gt;&gt; Result
 end // Result .IsNotNil
; // FineDocumentation

elem_proc OutDocumentation
 STRING VAR l_Doc
 Self .FineDocumentation &gt;&gt;&gt; l_Doc
 if ( l_Doc .IsNotNil ) then
 begin
  Indented: ( l_Doc .Out )
 end // l_Doc .IsNotNil
; // OutDocumentation

STRING elem_func MethodCallingConventions
 RULES
  ( Self .InTie )
   'stdcall'
  ( Self .IsMethod )
   ( Self .FirstOperation .GetUP "calling conventions" )
  ( Self .IsFunction )
   ( Self .FirstOperation .GetUP "calling conventions" )
  DEFAULT
   ( Self .GetUP "calling conventions" )
 ; // RULES
 &gt;&gt;&gt; Result
 
 if ( Result 'none' == ) then
 begin
  cEmptyStr &gt;&gt;&gt; Result
 end // ( Result 'none' == )
 
 if ( Result .IsNotNil ) then
 begin
  cSpace Result ';' Cat Cat &gt;&gt;&gt; Result
 end // ( Result .IsNotNil )
; // MethodCallingConventions

CONST cConstPrefix 'const '

STRING elem_func InPrefix
 Cached:
 (
  RULES
   ( Self .IsNil )
    cConstPrefix
   ( Self .IsRecord )
    cConstPrefix
   ( Self .IsUnion )
    cConstPrefix
   ( Self .IsArray )
    cConstPrefix
   ( Self .IsInterface )
    cConstPrefix
   ( Self .IsTypedef )
    RULES
     ( Self .IsPointer )
      cEmptyStr
     DEFAULT
      ( Self .MainAncestor call.me )
    ; // RULES  
   ( Self .IsMixInParamType )
    cConstPrefix
   ( Self .IsString )
    cConstPrefix
   ( Self .IsUntyped )
    cConstPrefix
   DEFAULT
    cEmptyStr
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // InPrefix

STRING elem_func ParamPrefix
 RULES
  ( Self .IsStereotype st_in )
   ( Self .Target .InPrefix )
  ( Self .IsStereotype st_const )
   cConstPrefix
  ( Self .IsStereotype st_noconst )
   cEmptyStr
  ( Self .IsOutParam )
   'out '
  ( Self .IsStereotype st_inout )
   'var '
  DEFAULT
   ( Self .Target .InPrefix ) 
 ; // RULES
 &gt;&gt;&gt; Result
; // ParamPrefix

BOOLEAN elem_func IsDestructor
 RULES
  ( Self .MethodName 'Destroy' == )
   true
  ( Self .MethodName 'destroy' == )
   true
  DEFAULT
   false 
 ; // RULES 
 &gt;&gt;&gt; Result
; // IsDestructor

OUTABLE elem_func MethodKeyword
 Cached:
 (
  RULES
   ( Self .IsStaticConstructor )
    'function'
   ( Self .IsConstructor )
    ( 'constructor' )
   ( Self .IsFactory )
    ( 'class function' )
   ( Self .IsDestructor )
    ( 'destructor' )
   DEFAULT
   (
     ModelElement VAR l_Type
     Self .MethodType &gt;&gt;&gt; l_Type
     VAR l_IsFunc
     ( l_Type .IsNotNil ) AND ( l_Type .TypeName .IsNotNil ) &gt;&gt;&gt; l_IsFunc
     
     [
     RULES
      ( Self .ParentIsInterface )
       ()
      ( Self .UPisTrue 'extprop:isGlobal' )
       ()
      ( Self .IsStaticMethod )
       'class '
     ; // RULES 
  
     if l_IsFunc then
     begin
      'function'
     end // l_IsFunc
     else
     begin
      'procedure'
     end // l_IsFunc
     ]
   ) // DEFAULT
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // MethodKeyword

BOOLEAN elem_func IsInline
 Self .IsStereotype st_inline::Operation 
 &gt;&gt;&gt; Result
; // IsInline

BOOLEAN elem_func IsOperationOverride
 Self .IsStereotype st_override::Operation
 &gt;&gt;&gt; Result
; // IsOperationOverride

INTEGER elem_func MethodAbstraction
 Cached:
 (
  Self .OpKind CASE
   opkind_Normal
    ( 
     RULES
      ( Self .IsMessageOperation )
       at_message
      (
       ( Self .IsIterator )
       AND ( Self .MainAncestor .IsNotNil )
      ) 
       at_override
      ( Self .IsStaticConstructor )
       at_final
      ( Self .Parent .IsUtilityPack )
       at_final
      ( Self .Parent .IsStaticObject )
       at_final
      ( Self .ParentIsInterface )
       at_final
      ( Self .IsFunction )
       at_final
      ( Self .IsOperationOverride )
       at_override
      DEFAULT
       ( Self .Abstraction )
     ; // RULES
    ) // opkind_Normal
   opkind_Implemented
    (
     RULES
      ( Self .IsVCMOperationPrim )
       at_final
      ( Self .Parent .IsContract )
       at_abstract
      ( Self .ParentIsInterface )
       RULES
        ( Self .IsIteratorF ) 
         at_final
        ( Self .IsIterator )
         RULES
          ( 'F' Self .Name EndsStr )
           at_final
          DEFAULT
           at_virtual
         ; // RULES 
        DEFAULT
         at_final
       ; // RULES 
      ( Self .IsInline )
       at_final
      DEFAULT
       at_override 
     ; // RULES
    ) // opkind_Implemented
   opkind_Overridden
    RULES
     ( Self .IsInline )
      at_final
     DEFAULT 
      at_override
    ; // RULES  
   DEFAULT
    at_final 
  END // CASE
 ) 
 &gt;&gt;&gt; Result
; // MethodAbstraction

STRING elem_func MethodNamePrefix
 RULES
  ( Self .IsAreaGetter )
   'DoGet_'
  ( Self .IsSetter )
   begin
    RULES
     ( Self .InTie )
      'Set'
     ( Self .UPisTrue "pm" )
      'pm_Set'
     DEFAULT
      'Set_'
    ; // RULES  
   end // ( Self .IsSetter )
  ( Self .IsProperty )
   begin
    RULES
     ( Self .InTie )
      'Get'
     ( Self .UPisTrue "pm" )
      'pm_Get'
     DEFAULT
      'Get_'
    ; // RULES  
   end // ( Self .IsProperty )
  DEFAULT
   cEmptyStr
 ; // RULES 
 &gt;&gt;&gt; Result
; // MethodNamePrefix

STRING CompileTime-VAR g_MethodParentPrefix ''
BOOLEAN CompileTime-VAR g_EnableMethodDirectives true
BOOLEAN CompileTime-VAR g_EnableMethodDocumentation true

ANY elem_func ExtValue
 Cached:
 (
  Self .GetUP 'extprop:pas:Value' &gt;&gt;&gt; Result
  if ( Result .IsValueValid ) then
  begin
   RULES
    ( Result IsString )
     begin
      RULES
       ( '.[]' Result EndsStr )
        begin
         '[]' &gt;&gt;&gt; Result
        end // ( '.[]' Result EndsStr )
       ( '.nil' Result EndsStr )
        begin
         'nil' &gt;&gt;&gt; Result
        end // ( '.[]' Result EndsStr )
       ( '1.0' Result EndsStr )
        ()
       ( '.0' Result EndsStr )
       // - вообще тут надо проверять, что впереди буква
        begin
         '0' &gt;&gt;&gt; Result
        end // ( '.[]' Result EndsStr )
       ( 
        ( ']' Result EndsStr )
        AND ( '[' Result StartsStr ! )
       ) 
        begin
         VAR l_Head
         Result cDot string:Split &gt;&gt;&gt; Result &gt;&gt;&gt; l_Head
         if ( Result .IsNil ) then
         begin
          l_Head &gt;&gt;&gt; Result
         end // ( Result .IsNil )
        end // ( '.[]' Result EndsStr )
       ( 'vcmUserControls.vcm_utAny' Result == )
        ( 'vcm_utAny' &gt;&gt;&gt; Result )
       ( 'vcm_ztvcm_ztAny' Result == )
        ( 'vcm_ztAny' &gt;&gt;&gt; Result )
       ( 'evdInterfaces.evDefaultStoreFlags' Result == )
        ( 'evDefaultStoreFlags' &gt;&gt;&gt; Result )
       DEFAULT
        begin
         VAR l_Type
         Self .ValueType &gt;&gt;&gt; l_Type
         if ( l_Type .IsNotNil ) then
         begin
          VAR l_Target
          Self .Target &gt;&gt;&gt; l_Target
          if (
              ( l_Target .IsNil )
              OR ( l_Target l_Type != ) 
             ) then
          begin
           VAR l_Unit
           l_Type .EffectiveUnitName &gt;&gt;&gt; l_Unit
           if ( Self .EffectiveUnitName l_Unit != ) then
           begin 
            l_Unit cDot Cat &gt;&gt;&gt; l_Unit
            if ( l_Unit Result StartsStr ! ) then
            begin
             l_Unit Result Cat &gt;&gt;&gt; Result
            end // ( l_Unit Result StartsStr ! ) 
           end // ( Self .EffectiveUnitName l_Unit != )
          end // ( Self .Target l_Type != )
         end // ( l_Type .IsNotNil )
        end // DEFAULT
      ; // RULES
     end // ( Result IsString )
   ; // RULES
  end // ( Result .IsValueValid )
  Result
 )
 &gt;&gt;&gt; Result
; // ExtValue

elem_proc MethodInterfacePrim
 IN aPrefix
 IN aOverload
 IN aOfObject
 IN aBody
 
 : OutOverload
  aOverload DO 
 ; // OutOverload
 
 : OutCallingConventions
  Self .MethodCallingConventions
 ; // OutCallingConventions

 : OutReintroduce
  RULES
   ( Self .IsStaticConstructor )
    ()
   ( Self .ParentIsInterface )
    ()
   ( Self .IsConstructor )
    ( ' reintroduce;' )
   ( Self .IsFactory )
    ( ' reintroduce;' )
  ; // RULES
 ; // OutReintroduce
 
 RULES
  ( Self .IsNil )
   ()
  DEFAULT 
  begin
   Self .IfDef:
   (
    [ 
     aPrefix DO
     
     ModelElement VAR l_Type
     Self .MethodType &gt;&gt;&gt; l_Type
     
     VAR l_IsFunc
   
     RULES
      ( Self .IsSetter ) 
       ( 
         false &gt;&gt;&gt; l_IsFunc
         'procedure' 
       )
      DEFAULT
       ( 
         ( l_Type .IsNotNil ) AND ( l_Type .TypeName .IsNotNil ) &gt;&gt;&gt; l_IsFunc
         Self .MethodKeyword 
       )
     ; // RULES  
     
     if ( Self .IsFunction ! ) then
     begin
      cSpace
      
      g_MethodParentPrefix
      
      RULES
       ( Self .IsProperty )
        (
         Self .MethodNamePrefix 
         Self .MethodName 
        )
       DEFAULT
        ( Self .MethodName  )
      ; // RULES
      
     end // ( Self .IsFunction ! )
     
     VAR l_WasParam
     false &gt;&gt;&gt; l_WasParam
     
     VAR l_MethodAbstraction
     Self .MethodAbstraction &gt;&gt;&gt; l_MethodAbstraction
     
     RULES
      ( Self .IsSetter )
       ( 
        Self .PropertyKeys 
        .join&gt; ToArray: ( l_Type .ValueParam )
       )
      ( Self .IsProperty )
       ( Self .PropertyKeys )
      DEFAULT
      ( Self .MethodParameters )
     ; // RULES  
     .for&gt; (
       IN aParam
      if ( l_WasParam ! ) then
       '('
      
      aParam .IfDefBraceLnBefore:
      (
       if ( l_WasParam ) then
       begin
        ';' \n cSpace
       end 
       
       true &gt;&gt;&gt; l_WasParam
       
       aParam .ParamPrefix
       aParam .Name
       
       VAR l_Type 
       aParam .Target &gt;&gt;&gt; l_Type
       if ( l_Type .IsNotNil ) then
       begin
        ': ' l_Type .TypeName
       end // ( l_Type .IsNotNil )
       
       //if ( l_MethodAbstraction at_override != ) then
       begin
        VAR l_Value
        aParam .ExtValue &gt;&gt;&gt; l_Value
        //aParam .GetUP 'Value' &gt;&gt;&gt; l_Value
        if ( l_Value .IsValueValid ) then
        begin
         ' = ' l_Value
        end // ( l_Value .IsValueValid )
       end // ( l_MethodAbstraction at_override != )
       
       VAR l_Doc
       aParam .FineDocumentation &gt;&gt;&gt; l_Doc
       if ( l_Doc .IsNotNil ) then
       begin
        \n cSpace l_Doc
       end // ( l_Doc .IsNotNil )
      ) // aParam .IfDefBraceLnBefore:
     ) // Self .MethodParameters .for&gt;
   
     if ( l_WasParam ) then
      ')'
     
     if l_IsFunc then
     begin
      ': ' l_Type .TypeName
     end // l_IsFunc
   
     aOfObject DO
     ';'
     
     if g_EnableMethodDirectives then
     begin
      l_MethodAbstraction CASE
       at_final (
        OutReintroduce
        OutOverload
        OutCallingConventions
       ) 
       at_virtual ( 
        OutReintroduce
        OutOverload
        ' virtual;'
        OutCallingConventions 
       )
       at_abstract ( 
        OutReintroduce
        OutOverload
        ' virtual; abstract;' 
        OutCallingConventions
       )
       at_override 
        ' override;'
       at_message ( 
        ' message ' Self .GetUP "Message ID" ';'
       ) 
      END // CASE
     end // g_EnableMethodDirectives
     
     VAR l_WasComma
     false &gt;&gt;&gt; l_WasComma
     VAR l_WasOut
     false &gt;&gt;&gt; l_WasOut
     
     RULES
      ( Self .IsSetter )
       ( Self .CanRaiseInSet )
      DEFAULT
       ( Self .CanRaise )
     ; // RULES
     .for&gt; (
       IN anItem
      if ( l_WasOut ! ) then
      begin
       true &gt;&gt;&gt; l_WasOut
       cSpace cOpenComment ' can raise '
      end // ( l_WasOut ! )
      anItem .TypeName .WithComma: l_WasComma .KeepInStack
     ) // Self .CanRaise .for&gt;
     if l_WasOut then
     begin
      cSpace
      cCloseComment
     end // l_WasOut
    ] 
    .Out? ? (
     if g_EnableMethodDocumentation then
      if ( Self .IsProperty ! ) then
      begin
       Self .OutDocumentation
      end // ( Self .IsProperty ! )
     Self aBody DO
    ) // .Out? ?
   ) // Self .IfDef: 
  end // DEFAULT
 ; // RULES 
; // MethodInterfacePrim

elem: AsSetterDo:
  ^ IN aLambda
 RULES
  ( Self .IsWriteonlyProperty )
   ( Self aLambda DO )
  DEFAULT 
   (
    Self .DecorateMethodAndDo: ( 
      IN aMethod
     aMethod -&gt; OpModify := opModifySetter
     aMethod aLambda DO 
    ) // Self .DecorateMethodAndDo:
   ) // DEFAULT
 ; // RULES
; // AsSetterDo:

elem: AsIteratorFDo:
  ^ IN aLambda
 Self .DecorateMethodAndDo: ( 
   IN aMethod
  aMethod -&gt; OpModify := opModifyIteratorF
  aMethod -&gt;^ cVarUserCodeName ^:= [
  'var' \n
  ' Hack : Pointer absolute anAction;'
  ]
  aMethod -&gt;^ cImplementationUserCodeName ^:= [
  ' try' \n
  '  '
  if ( Self .UPisTrue "needs result" ) then
   'Result := '
  RULES
   ( Self .IsMethodAndImplementsIterator ) 
    ( Self .MainImplements .MethodName )
   DEFAULT
    ( Self .Name )
  ; // RULES  
  Self .ParametersList
  ';'
  \n
  ' finally' \n
  '  l3FreeLocalStub(Hack);' \n
  ' end;//try..finally'
  ]
  aMethod aLambda DO 
 ) // Self .DecorateMethodAndDo:
; // AsIteratorFDo:

elem_proc MethodInterfaceEx
 IN aPrefix
 IN aOverload
 IN aOfObject
 IN aBody
 
 : NormalCall 
  Self aPrefix aOverload aOfObject aBody .MethodInterfacePrim
 ; // NormalCall
 
 : CallAsGetter
  if ( Self .ReadsField ! ) then
   if ( Self .UPisTrue "inherits getter from some ancestor" ! ) then
    NormalCall
 ; // CallAsGetter
 
 : CallAsSetter
  if ( Self .WritesField ! ) then
   if ( Self .UPisTrue "inherits setter from some ancestor" ! ) then
    ( Self .AsSetterDo: ( aPrefix aOverload aOfObject aBody .MethodInterfacePrim ) )
 ; // CallAsSetter
 
 RULES
  ( Self .IsModuleOperationPrim )
   begin
    if ( Self .UPisTrue "no test" ! ) then
    begin
     Self .AsTestDo: ( aPrefix aOverload aOfObject aBody .MethodInterfacePrim )
    end // ( Self .UPisTrue "no test" ! )
    Self .AsExecuteDo: ( aPrefix aOverload aOfObject aBody .MethodInterfacePrim )
   end // ( Self .IsModuleOperationPrim )
  ( Self .IsVCMOperationPrim )
   (
    //if ( Self .IsInternalOperation ! ) then
    begin
     if ( 
         ( Self .UPisTrue "is query" ! )
         AND ( Self .UPisTrue "no test" ! )
        ) then
     begin
      Self .AsTestDo: ( aPrefix aOverload aOfObject aBody .MethodInterfacePrim )
     end // ( Self .UPisTrue "is query" ! ) ..
    end // ( Self .IsInternalOperation ! )
    if (
        ( Self .UPisTrue "is FormActivate" ! ) 
        OR ( Self .IsInternalOperation )
       ) then
    begin
     Self .AsExecuteDo: ( aPrefix aOverload aOfObject aBody .MethodInterfacePrim )
    end // ( Self .UPisTrue "is FormActivate" ! )
    if ( Self .IsInternalOperation ! ) then
    begin
     if ( Self .HasStates ) then
     begin
      Self .AsGetStateDo: ( aPrefix aOverload aOfObject aBody .MethodInterfacePrim )
     end // ( Self .HasStates )
    end // ( Self .IsInternalOperation ! )
    if ( Self .IsInternalOperation ) then
     NormalCall
   ) // ( Self .IsVCMOperationPrim )
  ( Self .IsVCMArea )
   begin
    CallAsGetter
    if ( g_Implementor .NotIsNil ) then
    begin
     ( Self .AsAreaDo: ( aPrefix aOverload aOfObject aBody .MethodInterfacePrim ) )
    end // ( g_Implementor .NotIsNil )
   end // ( Self .IsVCMArea )
  ( Self .IsReadonlyProperty )
   CallAsGetter
  ( Self .IsWriteonlyProperty ) 
   CallAsSetter
  ( Self .IsProperty ) 
   ( 
    CallAsGetter
    CallAsSetter 
   ) // ( Self .IsProperty )
  ( Self .IsIterator )
   (
    NormalCall
    if ( 'F' Self .Name EndsStr ! )
     if ( Self .IsOverride ! ) then
     begin
      ( Self .AsIteratorFDo: ( aPrefix aOverload aOfObject aBody .MethodInterfacePrim ) )
     end // ( Self .IsOverride ! )
   ) // ( Self .IsIterator )
  ( Self .IsMethodAndImplementsIterator )
   (
    NormalCall
    if ( 'F' Self .Name EndsStr ! )
     //if ( Self .IsOverride ! ) then
     begin
      ( Self .AsIteratorFDo: ( aPrefix aOverload aOfObject aBody .MethodInterfacePrim ) )
     end // ( Self .IsOverride ! )
   ) // ( Self .IsIterator )
  DEFAULT
   NormalCall 
 ; // RULES
; // MethodInterfaceEx
 
elem_proc MethodInterfaceEx:
 ^ IN aPrefix
 ^ IN aOverload
 ^ IN aOfObject
 ^ IN aLambda
 Self aPrefix aOverload aOfObject aLambda .MethodInterfaceEx
; // MethodInterfaceEx:

BOOLEAN elem_func CanBeClassAncestor
 RULES
  ( Self .IsClassOrMixIn )
   true
  ( Self .IsException )
   true
  ( Self .IsEvdSchemaElement ) 
   true
  ( Self .IsTypedef )
   RULES
    ( Self .IsPointer )
     false
    DEFAULT
     ( Self .MainAncestor call.me )
   ; // RULES  
  DEFAULT
   false
 ; // RULES
 &gt;&gt;&gt; Result
; // CanBeClassAncestor

ModelElement elem_func MainClassAncestor
 Cached:
 (
  Self .InheritsEx
  .filter&gt; .CanBeClassAncestor 
  .FirstElement
 )
 &gt;&gt;&gt; Result
; // MainClassAncestor

elem_iterator MixInPropertiesTotal
 Cached:
 (
  Self .Properties
  .joinWithLambded&gt; ( Self .ImplementsEx .filter&gt; .IsPureMixIn ) call.me
  .joinWithLambded&gt; ( Self .InheritsEx .filter&gt; .IsPureMixIn ) call.me
 ) 
 &gt;&gt;&gt; Result
; // PropertiesTotal

elem_iterator InterfacePropertiesTotal
 Cached:
 (
  Self .Properties
  .joinWithLambded&gt; ( Self .ImplementsEx .filter&gt; .IsPureMixIn ) .MixInPropertiesTotal
 ) 
 &gt;&gt;&gt; Result
; // InterfacePropertiesTotal

elem_iterator InterfaceProperties
 Cached:
 (
  RULES
   ( Self .IsPureMixIn )
    ( Self .Properties )
   DEFAULT
    ( Self .InterfacePropertiesTotal )
  ; // RULES 
 ) 
 &gt;&gt;&gt; Result
; // InterfaceProperties

INTERFACE elem_func InstanceMethod
 Cached:
 (
  VAR l_TypeName
  Self .TypeName &gt;&gt;&gt; l_TypeName
  'Instance' Self MakeFunction: (
    IN aMade
   aMade -&gt; Stereotype := st_static::Operation
   aMade -&gt; %SUM := ( 'Метод получения экземпляра синглетона ' l_TypeName Cat )
   aMade -&gt; Visibility := PublicAccess
   aMade -&gt;^ cVarUserCodeName ^:= cEmptyUserCode
   aMade -&gt;^ cImplementationUserCodeName ^:= [ 
   ' if (' 'g_' l_TypeName ' = nil) then' \n
   ' begin' \n
   '  l3System.AddExitProc(' l_TypeName 'Free' ');' \n
   '  g_' l_TypeName ' := Create' 
   if ( Self .IsVCMCustomForm ) then
   begin
    '(' 'nil' ')'
   end // ( Self .IsVCMCustomForm )
   ';' \n
   ' end;' \n
   ' Result := g_' l_TypeName ';'
   ]
  )
 )
 &gt;&gt;&gt; Result
; // InstanceMethod

INTERFACE elem_func ExistsMethod
 Cached:
 (
  VAR l_TypeName
  Self .TypeName &gt;&gt;&gt; l_TypeName
  'Exists' GarantModel::Boolean MakeFunction: (
    IN aMade
   aMade -&gt; Stereotype := st_static::Operation
   aMade -&gt; %SUM := 'Проверяет создан экземпляр синглетона или нет'
   aMade -&gt; Visibility := PublicAccess
   aMade -&gt;^ cVarUserCodeName ^:= cEmptyUserCode
   aMade -&gt;^ cImplementationUserCodeName ^:= [ 
   ' Result := g_' l_TypeName ' &lt;&gt; nil;'
   ]
  ) 
 )
 &gt;&gt;&gt; Result
; // ExistsMethod

INTERFACE elem_func FakeMethod
 Cached:
 (
  'Fake' MakeProcedure: ( 
    IN aMade
   aMade -&gt; %SUM := 'это нужно чтобы правильно генерировались вызовы методов доступа к свойствам'
   aMade -&gt; Visibility := PrivateAccess
   aMade -&gt; Abstraction := at_virtual
   aMade -&gt;^ cVarUserCodeName ^:= cEmptyUserCode
   aMade -&gt;^ cImplementationUserCodeName ^:= ' Assert(false);'
  )
 )
 &gt;&gt;&gt; Result
; // FakeMethod

INTERFACE elem_func InitConstructor
 Cached:
 (
  'Init' MakeProcedure: (
    IN aMade
   aMade -&gt; Stereotype := st_ctor::Operation
   aMade -&gt; Visibility := PublicAccess
   aMade -&gt; Abstraction := at_final
   aMade -&gt; UID := ( Self .LUID 'Init' Cat )
   if ( Self .IsAutoHelper ) then
   begin
    aMade -&gt; Parameters := [ 
     Self .ImplementsEx .for&gt; (
       IN aR
      'a' aR .TypeName Cat aR MakeParam 
     )
    ]
    aMade -&gt;^ cImplementationUserCodeName ^:= [
     Self .ImplementsEx .for&gt; (
       IN aR
      ' ' 'f_' aR .TypeName ' := ' 'a' aR .TypeName ';'
     )
    ]
   end // ( Self .IsAutoHelper )
   aMade -&gt;^ cVarUserCodeName ^:= cEmptyUserCode
   //aMade -&gt;^ cImplementationUserCodeName ^:= ' Assert(false);'
  ) 
 )
 &gt;&gt;&gt; Result
; // InitConstructor

BOOLEAN elem_func NeedsFakeMethod
 Cached:
 (
  RULES
   ( Self .IsAutoHelper )
    true
   ( Self .Properties .filter&gt; ( .ReadsField ! ) .NotEmpty )
    true 
   DEFAULT
    false 
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // NeedsFakeMethod

BOOLEAN elem_func IsSettingsHolder
 Self .IsStereotype st_SettingsHolder
 &gt;&gt;&gt; Result
; // IsSettingsHolder

BOOLEAN elem_func UseNewGen
 Cached:
 (
  RULES
   ( Self .IsNil )
    false
   ( Self .IsUserType )
    true 
   ( Self .IsElementProxy )
    true
   ( Self .IsTestClass )
    true
   ( Self .IsTestCase )
    true
   ( Self .IsScriptKeyword )
    true
   ( Self .IsScriptKeywordsPack )
    true
   ( Self .IsUtilityPack )
    true
   ( Self .IsScriptKeywords )
    true
   ( Self .IsWrapper )
    true
   ( Self .IsTagTable )
    false
   ( Self .IsInterfaceFactory )
    false
   ( Self .IsEVD )
    true 
   ( Self .UPisTrue "UseNewGen" )
    true 
   ( Self .GetUP "finished" false ?== ) 
    true
   ( Self .ForceUseNewGen )
    true 
   ( Self .IsVCMForm )
    true
   ( Self .IsVCMDataModule )
    true
   ( Self .IsVCMCustomForm )
    true
   ( Self .IsGuiControl )
    true
   ( Self .IsUseCaseControllerImp )
    true
    //( Self .Parent call.me )
   ( Self .IsViewAreaControllerImp )
    true
    //( Self .Parent call.me )
   ( Self .IsVCMControls )
    true
   ( Self .IsMixIn )
    true
   ( Self .IsControllerInterfaces )
    true
   ( Self .IsInternalInterfaces )
    true
   ( Self .IsInterfaces )
    true
   ( Self .IsService )
    true 
   ( Self .IsServiceImplementation )
    true 
   ( Self .IsSettingsHolder ) 
    ( Self .Parent call.me )
   ( Self .IsVCMFormSetFactory )
    true
    //( Self .Parent call.me )
   ( Self .IsVCMFormsPack ) 
    true
    //( Self .Parent call.me )
   ( Self .IsVCMApplication ) 
    true
   ( Self .IsTestResults ) 
    true
   ( Self .IsSimpleClass ) 
    true
   ( Self .IsTestLibrary ) 
    true
   ( Self .IsLibrary ) 
    ( Self .Parent call.me )
   ( Self .IsVCMTestTarget ) 
    true
   ( Self .IsTestTarget ) 
    true
   ( Self .IsVCMGUI ) 
    true
   ( Self .IsExeTarget ) 
    true
   ( Self .IsDLL ) 
    true
   ( Self .IsTarget ) 
    true
   DEFAULT
    ( Self .Parent call.me )
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // UseNewGen

elem_iterator AllOperationsForOverload
 Cached:
 (
  RULES
   ( Self .IsPureMixIn )
    ( Self .InterfaceOwnOperations )
   ( Self .IsInterface )
    ( Self .InterfaceOperationsTotal )
   ( Self .IsStaticObject )
    ( 
      Self .OperationsEx
      .filter&gt; ( .IsStaticConstructor ! )
      .join&gt; ( Self .ImplementedEx )
      
      if ( Self .NeedsFakeMethod ) then
      begin
       .join&gt; ToArray: ( Self .FakeMethod )
       .join&gt; ToArray: ( Self .InitConstructor )
      end // ( Self .NeedsFakeMethod )
    )
   ( Self .IsClassOrMixIn )
    ( 
      Self .OperationsEx
      
      VAR l_CastMethods
      [] &gt;&gt;&gt; l_CastMethods
      
      ( Self .ClassImplementsPrim ) .for&gt; (
        IN anItem
       .joinWithLambded&gt; 
       ( 
        anItem .InterfaceForClassImplements 
        .filter&gt; ( .AddToArray?: l_CastMethods )
       ) 
       (
         IN anItem
        anItem .ToArray: .CastMethod
       )
      )
      .filter&gt; ( .IsStereotype st_responsibility::Operation ! ) 
      .filter&gt; ( .IsServiceIterator ! ) 
      .filter&gt; ( .IsIni ! )
      .filter&gt; ( .IsFini ! )
      
      (
       VAR l_VCMOperations
       [] &gt;&gt;&gt; l_VCMOperations
       
       .join&gt; ( 
         Self .ImplementedEx
        .filter&gt; ( .IsInline ! )
        .filter&gt; (
          IN anOp
          if ( anOp .IsVCMOperationPrim ) then
          begin
           VAR l_Name
           anOp .MethodName &gt;&gt;&gt; l_Name
           if ( l_Name .StringNotInArray: l_VCMOperations ) then
           begin
            l_Name .AddToArray: l_VCMOperations
            true
           end // ( l_Name .StringNotInArray: l_VCMOperations )
           else 
            false
          end // .IsVCMOperationPrim
          else
           true
        ) // .filter&gt;
        array:Copy
       ) // join&gt; ( Self .ImplementedEx )
      )
       
      if ( Self .IsSingleton ) then
      begin
       if ( Self .HasFactory ! ) then
       begin
        .join&gt; ToArray: ( Self .InstanceMethod )
       end // ( Self .HasFactory ! )
       if ( Self .OperationsEx 'Exists' .HasModelElementWithName ! ) then
       begin
        .join&gt; ToArray: ( Self .ExistsMethod )
       end // ( Self .OperationsEx 'Exists' .HasModelElementWithName ! )
      end // ( Self .IsSingleton )
    )
   DEFAULT
    ( Self .OperationsEx )
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // AllOperationsForOverload

elem_iterator AllOperationsForDefine
 Cached:
 (
  RULES
   ( Self .IsPureMixIn )
    ( Self .Properties )
   ( Self .IsInterface )
    ( Self .InterfacePropertiesTotal )
   ( 
    ( Self .IsStaticObject )
    OR ( Self .IsClassOrMixIn )
   ) 
    ( 
     Self .Properties
     .filter&gt; ( IN anItem
      ( anItem .ReadsField ! )
      OR ( anItem .WritesField ! )
     )
    )
   DEFAULT
    [empty]
  ; // RULES
  .join&gt; ( Self .AllOperationsForOverload )
  RULES
   ( Self .IsClassOrMixIn )
    ( 
     .join&gt; 
     ( 
      Self .OverriddenEx
      .filter&gt; ( .IsVCMOperationPrim ! )
     )
     .filter&gt; ( .IsInline ! ) 
    ) 
  ; // RULES
  .filter&gt; ( .Visibility UnknownAccess != )
 )
 &gt;&gt;&gt; Result
; // AllOperationsForDefine

elem_proc MethodInterfaceForEx:
  ^ IN anOperations
  ^ IN aLambda
 Self .MethodInterfaceEx: () ( 
  ARRAY VAR l_Ops
  anOperations DO &gt;&gt;&gt; l_Ops
  if ( l_Ops .IsNotNil ) then
  begin
   if ( Self .UPisTrue "force overload" ) then
   begin
    ' overload;'
   end // ( Self .UPisTrue "force overload" )
   else
   begin
    if ( l_Ops 
         .filter&gt; ( .IsProperty ! )
         .filter&gt; ( .IsVCMOperationPrim ! )
         .filter&gt; ( .IsModuleOperationPrim ! )
         .filter&gt; ( .MethodName Self .MethodName == ) 
         .CountIt &gt; 1 ) then
    begin
     ' overload;'
    end // l_Ops ..
   end // ( Self .UPisTrue "force overload" )
  end // ( l_Ops .IsNotNil )
 ) () (
  aLambda DO
 )
; // MethodInterfaceForEx:

elem_proc MethodInterfaceFor:
  ^ IN anOperations
 Self .MethodInterfaceForEx: ( anOperations DO ) DROP
; // MethodInterfaceFor:
  
STRING elem_func PropertyName
 Cached:
 (
  RULES
   ( Self .InTie )
    ( Self .Name .FromTie )
   DEFAULT
    ( Self .Name )
  ; // RULES   
 )   
 &gt;&gt;&gt; Result
; // PropertyName

elem_proc OutProperty
 Self .IfDef:
 (
  [
   'property '
   Self .PropertyName
   
   VAR l_WasParam
   false &gt;&gt;&gt; l_WasParam
 
   Self .PropertyKeys .for&gt; (
     IN aParam
    if l_WasParam then
     '; '
    else
    begin
     true &gt;&gt;&gt; l_WasParam
     '['
    end
    aParam .ParamPrefix
    aParam .Name
    ': '
    aParam .Target .TypeName
   )
 
   if l_WasParam then
    ']'
   ': '
   Self .MethodType .TypeName
 
   : OutRead
    \n cSpace 'read' cSpace 
    if ( Self .ReadsField ) then
     'f_'
    else
    begin
     Self .MethodNamePrefix 
    end // ( Self .ReadsField )
    Self .MethodName
   ; // OutRead
 
   : OutWrite
    \n cSpace 'write' cSpace
    if ( Self .WritesField ) then
     'f_'
    else
    begin
     Self .AsSetterDo: .MethodNamePrefix
    end // ( Self .WritesField )
    Self .MethodName
   ; // OutWrite
 
   RULES
    ( Self .IsReadonlyProperty )
     OutRead
    ( Self .IsWriteonlyProperty )
     ()
    ( Self .IsProperty )
     OutRead
   ; // RULES
   RULES
    ( Self .IsReadonlyProperty )
     ()
    ( Self .IsWriteonlyProperty )
     OutWrite
    ( Self .IsProperty )
     OutWrite
   ; // RULES
 
   if ( Self .UPisTrue "needs stored directive" ) then
   begin
    \n
    ' stored '
    Self .MethodName
    'Stored'
   end // ( Self .UPisTrue "needs stored directive" )
 
   VAR l_Value
   Self .ExtValue &gt;&gt;&gt; l_Value
   if ( l_Value .IsValueValid ) then
   begin
    \n
    ' default ' l_Value
   end // ( l_Value .IsValueValid )
   
   ';'
 
   if ( Self .UPisTrue "is default" ) then
   begin
    \n
    ' default;'
   end // ( Self .UPisTrue "is default" )
  ] .Out? ?
   ( Self .OutDocumentation )
 ) // Self .IfDef:
; // OutProperty

PROCEDURE .ByVisibility&gt;
  ARRAY IN anArray
  ^ IN aFilter
  ^ IN aOut
  
  BOOLEAN VAR l_WasOut
  STRING VAR l_Separator
  
  PROCEDURE DoOut
    IN anItem
   if ( l_WasOut ! ) then
   begin
    true &gt;&gt;&gt; l_WasOut
    l_Separator .Out
   end // ( l_WasOut )
   Indented: ( anItem aOut DO )
  ; // DoOut
  
 false &gt;&gt;&gt; l_WasOut 
 'private' &gt;&gt;&gt; l_Separator
 anArray .filter&gt; ( aFilter DO PrivateAccess == ) .for&gt; DoOut
 false &gt;&gt;&gt; l_WasOut 
 'protected' &gt;&gt;&gt; l_Separator
 anArray .filter&gt; ( aFilter DO ProtectedAccess == ) .for&gt; DoOut
 false &gt;&gt;&gt; l_WasOut 
 'public' &gt;&gt;&gt; l_Separator
 anArray .filter&gt; ( aFilter DO PublicAccess == ) .for&gt; DoOut
 'published' &gt;&gt;&gt; l_Separator
 anArray .filter&gt; ( aFilter DO PublishedAccess == ) .for&gt; DoOut
; // .ByVisibility&gt;

elem_proc OutField
 Self .IfDef:
 (
  [ 
   Self .FieldName
   ': '
   Self .MethodType .TypeName
   ';'
  ] .Out? ? (
   Self .OutDocumentation
  ) // .Out? ?
 ) // Self .IfDef:
; // OutField

INTEGER elem_func MethodVisibility
 Cached:
 (
  RULES
   ( Self .IsProperty )
    ProtectedAccess
   ( Self .IsStereotype st_Test )
    PublishedAccess 
   ( Self .OpKind opkind_Implemented == )
    RULES
     ( Self .Parent .IsPureMixIn )
      PublicAccess
     ( Self .ParentIsInterface )
      ProtectedAccess
     ( Self .IsStaticMethod ) 
      PublicAccess
     (
      ( Self .Visibility PrivateAccess == ) 
      AND ( Self .Abstraction at_abstract == )
     ) 
      ProtectedAccess
     DEFAULT
      ( Self .Visibility )
    ; // RULES
   ( Self .OpKind opkind_Overridden == )
    RULES
     ( 
      Self .IsStaticMethod 
      AND ( Self .Abstraction at_abstract == )
     )
      PublicAccess
     ( Self .Visibility PrivateAccess == ) 
      ProtectedAccess
     DEFAULT
      ( Self .Visibility )
    ; // RULES
   DEFAULT
    ( Self .Visibility )
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // MethodVisibility

elem_iterator ClassProperties
 Cached:
 (
  Self .Properties
  .join&gt; ( 
   ( Self .ImplementedEx )
   .filter&gt; .IsProperty
   .filter&gt; ( .Parent .IsContract )
  ) 
 )
 &gt;&gt;&gt; Result
; // ClassProperties

INTEGER elem_func FieldVisibility
 RULES
  ( Self .IsProperty )
   PrivateAccess
  DEFAULT
   ( Self .Visibility )
 ; // RULES
 &gt;&gt;&gt; Result
; // FieldVisibility

elem_proc OutClassInner
 Indented: (
  if ( Self .IsVCMCustomForm ) then
  begin
   if ( Self .Abstraction at_final == ) then
   begin
    Indented: (
     if ( Self .IsVCMForm ) then
     begin
      'Entities : TvcmEntities;' .Out
     end // ( Self .IsVCMForm )
     Self .AllControls
     .filter&gt; ( .IsControlOverride ! )
     .filter&gt; .NeedPutToDFM
     .for&gt; (
       IN aControl
      [ aControl .AttrName ' : ' aControl .AttrType .TypeName ';' ] .Out
     ) // .for&gt;
    ) // Indented:
   end // ( Self .Abstraction at_final == )
  end // ( Self .IsVCMCustomForm )
  Self .Fields .ByVisibility&gt; .FieldVisibility .OutField
  
  TF g_Implementor (
   Self &gt;&gt;&gt; g_Implementor
   VAR l_AllOps
   Self .AllOperationsForOverload &gt;&gt;&gt; l_AllOps
   
   Self .AllOperationsForDefine 
   .ByVisibility&gt; .MethodVisibility
   .MethodInterfaceFor: l_AllOps
 
   Self .ClassProperties .ByVisibility&gt; .Visibility .OutProperty
  ) // TF g_Implementor
  
  if ( Self .IsStaticObject ) then
  begin
   VAR l_WasSection
   false &gt;&gt;&gt; l_WasSection
   ( Self .Attributes .filter&gt; ( .Target .IsUnion ) ) .for&gt; (
     IN aProp
    aProp .Target .Attributes 
    .filter&gt; ( .IsStereotype st_switch::Attribute ! ) 
    .filter&gt; ( .Name 'void' SWAP StartsStr )
    .for&gt; (
      IN aField
     aField .Target .Attributes .for&gt; (
       IN aField
       
      if ( l_WasSection ! ) then
      begin
       'public' .Out
       true &gt;&gt;&gt; l_WasSection
      end // ( l_WasSection ! )
      
      Indented:
      (
       [ 
        'property ' aField .Name ': ' aField .Target .TypeName
        \n 
        cSpace 'read' cSpace aProp .Name cDot aField .Name
        \n
        cSpace 'write' cSpace aProp .Name cDot aField .Name
        ';'
       ] .Out 
      ) // Indented:
     )
    )
   )
  end // ( Self .IsStaticObject )
 ) // Indented:
 
 if ( Self .UPisTrue "need UC" ) then
 begin
  Self .UserCode: 'publ' ()
 end // ( Self .UPisTrue "need UC" )
  
; // OutClassInner

elem_iterator InheritsNotMixIn
 Cached:
 (
  Self .InheritsEx .filterMixIns&gt;
 )
 &gt;&gt;&gt; Result
; // InheritsNotMixIn

BOOLEAN elem_func IsInheritsNotMixInCount
 Cached:
 (
  Self .InheritsNotMixIn .NotEmpty
 )
 &gt;&gt;&gt; Result
; // IsInheritsNotMixInCount

ModelElement elem_func TagClass
 %SUMMARY 
  'Класс, реализующий тег.' 
  'Возможно будет расширяться, когда будем делать генерацию EVD-схемы.'
  'И станет полноценным классом с реализуемыми и перекрытыми методами.'
 ;
 Cached:
 (
  Self .TypeName 'Class' Cat nil MakeClass
 ) 
 &gt;&gt;&gt; Result
; // TagClass
        
ModelElement elem_func MainAncestorThatNotMixIn
 %SUMMARY 
  'Возвращает имя родительский класс, который не является примесью.' 
  'Или умолчательного предка'.
 ;
/*
	[{}{\
	%S%f_pas_DefaultAncestor()\
	}\
	&lt;{}{%G#f_IsMixIn()!=true}\
	%f_pas_TypeName(%G)[{%GS=Tag}Class]\
	&gt;\
        ]
*/
 Cached:
 (
  RULES
   ( Self .IsInheritsNotMixInCount ! )
    ( Self .DefaultAncestor )
   ( Self .InheritsNotMixIn .filter&gt; .IsTag .IsEmpty ) 
    ( Self .InheritsNotMixIn .FirstElement )
   DEFAULT
    begin
     Self .InheritsNotMixIn 
     .filter&gt; .IsTag 
     .map&gt; .TagClass
     .FirstElement
    end // DEFAULT
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // MainAncestorThatNotMixIn

ModelElement elem_func MixInParentName
 %SUMMARY 'Псевдо класс для указания родительсого типа примеси.' ;
 Cached:
 (
  Self .TypeName 'Parent_' Cat nil MakeClass
 ) 
 &gt;&gt;&gt; Result
; // MixInParentName
        
STRING elem_func PasPathOnly
 Cached:
 (
  Self .GetUP 'intf.pas:PathOnly' &gt;&gt;&gt; Result
  if ( Result .IsNil ) then
  begin
   Self .Parent call.me &gt;&gt;&gt; Result
  end // ( Result .IsNil )
  else
  begin
   Result '\MDProcess\components\' '\common\components\' string:ReplaceFirst &gt;&gt;&gt; Result
  end // ( Result .IsNil )
  Result
 )
 &gt;&gt;&gt; Result
; // PasPathOnly

STRING elem_func PathOnly
 Cached:
 (
  Self .FinalFileName sysutils:ExtractFilePath &gt;&gt;&gt; Result
  if ( Result .IsNil ) then
  begin
   Self .PasPathOnly &gt;&gt;&gt; Result
   if ( Result .IsNotNil ) then
   begin
    Result '\' .CutPrefix &gt;&gt;&gt; Result
    [ cRoot 
    // - это потому, что в пути нету диска, а для ExtractFileName он нужен
    Result ] cPathSep strings:CatSep &gt;&gt;&gt; Result
    Result cPathSep Cat &gt;&gt;&gt; Result
   end // ( Result .IsNotNil )
  end // ( Result .IsNil )
  Result
 )
 &gt;&gt;&gt; Result
; // PathOnly

elem_proc OutMixInInclude
 [ cOpenComment '$Include' ' ' Self .PathOnly Self .UnitName '.pas' cCloseComment ] .Out
; // OutMixInInclude

BOOLEAN elem_func HasNonMixInAncestor
 Cached:
 (
  RULES
   ( Self .IsInheritsNotMixInCount )
    true
   ( Self .InheritsEx .filter&gt; call.me .NotEmpty )
    true
   DEFAULT
    false
  ; // RULES   
 ) 
 &gt;&gt;&gt; Result
; // HasNonMixInAncestor

ModelElement elem_func_with_side_effects CalcParentAndInclude
 RULES
  ( Self .IsMixIn )
   RULES
    ( Self .IsInheritsNotMixInCount )
     ( Self .MainClassAncestor )
    DEFAULT
     ( Self .MixInParentName )
   ; // RULES  
  DEFAULT
   ( Self .MainAncestorThatNotMixIn )
 ; // RULES 
 &gt;&gt;&gt; Result
 
 : RefG
   IN aG
  if ( Result .IsNotNil ) then
  begin 
   [ aG .MixInParentName .TypeName ' = ' Result .TypeName ';' ] .Out
  end // ( Result .IsNotNil )
 ; // RefG
 
 VAR l_WasProlog
 false &gt;&gt;&gt; l_WasProlog
 
 : DoG
   IN aG
  aG &gt;&gt;&gt; Result
  //aG .TypeName &gt;&gt;&gt; Result
  
  if ( l_WasProlog ! ) then
  begin
   true &gt;&gt;&gt; l_WasProlog
   if ( aG GarantModel::l3Items .InheritsFrom ) then
   begin
   
    : OutIsProto
     [ cOpenComment '$Define ' 'l3Items_IsProto' cCloseComment ] .Out
    ; // OutIsProto
    
    RULES
     ( Self GarantModel::Tl3ProtoObject .InheritsFrom )
      OutIsProto
     ( 
      ( Self GarantModel::Tl3DataContainerWithoutIUnknownPrim .InheritsFrom )
      AND NOT ( Self GarantModel::Tl3DataContainerWithoutIUnknown .InheritsFrom )
     ) 
      OutIsProto
    ; // RULES
   end // ( aG GarantModel::l3Items .InheritsFrom )
  end // ( l_WasProlog ! )
  
  aG .OutMixInInclude
 ; // DoG
 
 Self .InheritsEx .filter&gt; .IsMixIn .for&gt; (
   IN aG
  if ( Result .IsNotNil ) then
  begin 
   if ( aG .HasNonMixInAncestor ! ) then
   begin
    aG RefG 
   end // ( aG .HasNonMixInAncestor ! )
  end // ( Result .IsNotNil )
  aG DoG
 )
 Self .ImplementsEx .filter&gt; .IsMixIn .for&gt; (
   IN aG
  aG RefG 
  aG DoG
 )
; // CalcParentAndInclude
        
elem_proc DefineMixInValues
 Self .MixInValues .for&gt; (
   IN aValue
  g_MixInParamTypes -&gt;^ ( aValue .Name ) ^:= ( aValue .Target )
 ) // Self .MixInValues .for&gt;
; // DefineMixInValues

elem_proc UndefineMixInValues
 Self .MixInValues .for&gt; (
   IN aValue
  g_MixInParamTypes -&gt;^ ( aValue .Name ) ^:= nil
 ) // Self .MixInValues .for&gt;
; // UndefineMixInValues

elem_proc DefineImplementedMixInValues
 Self .ImplementsIsInterface .for&gt; .DefineMixInValues
; // DefineImplementedMixInValues

elem_proc UndefineImplementedMixInValues
 Self .ImplementsIsInterface .for&gt; .UndefineMixInValues
; // DefineImplementedMixInValues

ARRAY CompileTime-VAR g_MixInValues nil

elem_iterator AllInlinedOperations
 Cached:
 (
  Self .ImplementedAndOverridden
  .filter&gt; .IsInline
 )
 &gt;&gt;&gt; Result
; // AllInlinedOperations

elem_proc OutOtherMixinValues
 Self .InheritsEx .for&gt; (
   IN aG
  aG .MixInValues .for&gt; (
    IN aValue
   if ( aValue .Name .TextNotInArray: g_MixInValues ) then
   begin
    aValue .Name .AddToArray: g_MixInValues
    [ 
     '{$If not Declared(' cUnderline aValue .Name cUnderline ')' '}'
     'type' ' '
     cUnderline aValue .Name cUnderline ' = ' aValue .Target .TypeName ';' 
     '{$IfEnd}'
     \n
    ] .Out
   end // ( aValue .Name .TextNotInArray: g_MixInValues )
  ) // aG .MixInValues .for&gt;
  aG call.me
 ) // Self .InheritsEx .for&gt;
; // OutOtherMixinValues

elem_proc OutClass

 Self .DefineImplementedMixInValues

 if ( Self .UPisTrue "need UC" ) then
 begin
  Self .UserCode: 'ci' ()
 end // ( Self .UPisTrue "need UC" ) 

 Self .MixInValues .for&gt; (
   IN aValue
  aValue .Name .AddToArray: g_MixInValues 
  [ cUnderline aValue .Name cUnderline ' = ' aValue .Target .TypeName ';' ] .Out
 )
 
 VAR l_Parent
 Self .CalcParentAndInclude &gt;&gt;&gt; l_Parent
 
 if ( Self .UPisTrue "need UC" ) then
 begin
  Self .UserCode: 'cit' ()
 end // ( Self .UPisTrue "need UC" ) 
 
 [ 
  Self .TypeName 
  ' = ' 
  
  Self .Abstraction CASE
   at_abstract
    [ cOpenComment 'abstract' cCloseComment cSpace ]
   at_final
    [ cOpenComment 'final' cCloseComment cSpace ]
  END // CASE
  
  'class'

  ARRAY VAR l_Implements 
  [] &gt;&gt;&gt; l_Implements

  VAR l_WasComma
  false &gt;&gt;&gt; l_WasComma
  
  l_Parent .ToArray
  .join&gt; ( 
   Self .ClassImplements 
   .filter&gt; .AddToArray?: l_Implements
  ) // .join&gt;
  .With()&gt; (
    IN anItem
   RULES 
    ( anItem .IsMixIn )
     ( anItem .TypeName .WithComma: l_WasComma .KeepInStack )
    DEFAULT
    begin
     anItem .IfDefBraceLn:
     ( 
      anItem .TypeName .WithComma: l_WasComma .KeepInStack
     ) // anItem .IfDefBraceLn:
    end // DEFAULT
   ; // RULES
  ) // .With()&gt;
 ] .Out
 
 Self .OutDocumentation
 Self .OutClassInner
 
 [ 'end;//' Self .TypeName ] .Out
 
 Self .UndefineImplementedMixInValues
; // OutClass

elem_proc OutInterfaceBody
 Indented: (
  VAR l_Ops
  Self .AllOperationsForDefine &gt;&gt;&gt; l_Ops
  VAR l_AllOps
  Self .AllOperationsForOverload &gt;&gt;&gt; l_AllOps
  l_Ops .for&gt; .MethodInterfaceFor: l_AllOps
  Self .InterfaceProperties .for&gt; .OutProperty
 ) // Indented:
; // OutInterfaceBody

elem_proc OutInterface

 Self .DefineMixInValues
 
 Self .MixInValues .for&gt; (
   IN aValue
  [ '//' cUnderline aValue .Name cUnderline ' = ' aValue .Target .TypeName ';' ] .Out
 ) // Self .MixInValues .for&gt;
 
 [ Self .TypeName ' = interface' Self .MainAncestor .TypeName .With() ] .Out
 Self .OutDocumentation
 
 VAR l_GUID
 Self .GUID &gt;&gt;&gt; l_GUID
 if ( l_GUID .IsNotNil ) then
 begin
  Indented: ( [ '[' cQuote cOpenComment l_GUID cCloseComment cQuote ']' ] .Out )
 end // ( l_GUID .IsNotNil )
 
 Self .OutInterfaceBody
 [ 'end;//' Self .TypeName ] .Out
 
 Self .UndefineMixInValues
 
; // OutInterface

elem_proc OutRecord
 [ 
  Self .TypeName ' = ' 

  Self .UPisTrue "packed" ? 'packed '

  'record' 
 ] .Out
 Self .OutDocumentation
 
 Indented: ( 
  VAR l_Switch
  Self .Attributes 
  .filter&gt; ( .IsStereotype st_switch::Attribute ) 
  .FirstElement
  &gt;&gt;&gt; l_Switch
  
  if ( l_Switch .IsNotNil ) then
  begin
   [ 
    'Case ' 
    
    if ( l_Switch .Name 'void' != ) then
    begin
     l_Switch .Name ': '
    end // ( l_Switch .Name 'void' != )
    
    l_Switch .Target .TypeName
    ' of' 
   ] .Out 
   Indented: (
    Self .Fields .for&gt; (
      IN aField
     [ 
      VAR l_Value
      aField .GetUP 'Value' &gt;&gt;&gt; l_Value
      
      if ( l_Value .IsValueValid ) then
       l_Value
      else
       '!!!' 
      ': ' 
      '('
      if ( 'void' aField .Name StartsStr ) then 
      begin
       VAR l_WasField
       false &gt;&gt;&gt; l_WasField
       aField .Target .Fields .for&gt; (
         IN aField
         
        if l_WasField then
         '; ' 
         
        aField .Name 
        ': '
        aField .Target .TypeName
        true &gt;&gt;&gt; l_WasField
       ) // aField .Target .Fields .for&gt;
      end // ( 'void' aField .Name StartsStr )
      else
      begin
       aField .Name 
       ': '
       aField .Target .TypeName
      end // ( 'void' aField .Name StartsStr )
      ');'
     ] .Out? ? (
      aField .OutDocumentation
     ) // .Out? ?
    ) // Self .Fields .for&gt;
   ) // Indented:
  end // ( l_Switch .IsNotNil )
  else
  begin
   Self .Fields .for&gt; .OutField 
  end // ( l_Switch .IsNotNil )
 ) // Indented:
 
 if ( Self .UPisTrue "need UC" ) then
 begin
  Self .UserCode: 'publ' ()
 end // ( Self .UPisTrue "need UC" ) 
 
 [ 'end;//' Self .TypeName ] .Out
; // OutRecord

elem_proc OutDefine
 [ cOpenComment '$Define ' Self .Name cCloseComment ] .Out
; // OutDefine

elem_proc OutUndef
 [ cOpenComment '$Undef ' Self .Name cCloseComment ] .Out
; // OutUndef

elem_proc OutStaticObject
 if ( Self .IsConstructorsHolder ! ) then
 begin
  if ( Self .UPisTrue "need UC" ) then
  begin
   Self .UserCode: 'ci' ()
  end // ( Self .UPisTrue "need UC" ) 
 
  [ 
   Self .TypeName ' = ' 

   Self .UPisTrue "packed" ? 'packed '

   'object' Self .MainAncestor .TypeName .With() 
  ] .Out
  
  Self .OutDocumentation
  Self .OutClassInner
  
  [ 'end;//' Self .TypeName ] .Out
 end // ( Self .IsConstructorsHolder ! )
; // OutStaticObject

elem_proc OutPureMixIn
 '(*' .Out
 Self .OutInterface
 '*)' .Out
; // OutPureMixIn

ANY elem_func ExtValueOrName
 Self .ExtValue &gt;&gt;&gt; Result
 if ( Result .IsValueValid ! ) then
 begin
  Self .Name &gt;&gt;&gt; Result
 end // ( Result .IsValueValid ! 
; // ExtValueOrName
 
elem_proc OutRange
 [ Self .TypeName 
   ' = ' 
   VAR l_First
   Self .FirstAttribute &gt;&gt;&gt; l_First
   VAR l_Second
   Self .SecondAttribute &gt;&gt;&gt; l_Second
   if ( l_Second .IsNil ) then
   begin
    l_First &gt;&gt;&gt; l_Second
   end // ( l_Second .IsNil )
   
   VAR l_ElementPrefix
   if ( Self .GetUP "elements prefix" '&lt;none&gt;' == ) then
   begin
    '' &gt;&gt;&gt; l_ElementPrefix
   end
   else
   begin 
    Self .MainAncestor .GetUP 'extprop:pas:ElementPrefix' &gt;&gt;&gt; l_ElementPrefix
   end
   
   : .ValueWithPrefix
     IN aValue
    if ( aValue IsString ! ) then
     aValue
    else 
    if ( l_ElementPrefix aValue StartsStr ) then
     aValue
    else
    begin
     l_ElementPrefix aValue
    end 
   ; // .ValueWithPrefix
   
   l_First .ExtValueOrName .ValueWithPrefix
   ' .. '
   l_Second .ExtValueOrName .ValueWithPrefix
   ';' 
 ] .Out
 Self .OutDocumentation
; // OutRange

elem_proc OutTypedef
 ModelElement VAR l_MainAncestor
 Self .MainAncestor &gt;&gt;&gt; l_MainAncestor
 [ Self .TypeName 
   ' = ' 
   if ( Self .UPisTrue "newRTTI" ) then
    'type '
   if ( Self .IsPointer ) then
    '^'
   if ( Self .IsClassRef ) then
   begin
    true &gt;&gt;&gt; g_WasForwarded
    'class of '
   end // ( Self .IsClassRef )
   if ( Self .IsPointer ! ) then
   begin
    STRING VAR l_OtherUnit
    l_MainAncestor .EffectiveUnitName &gt;&gt;&gt; l_OtherUnit
    if ( l_OtherUnit .IsNotNil ) then
    begin
     if ( Self .TypeName l_MainAncestor .TypeName SameText ) then
     begin
      STRING VAR l_OurUnit
      Self .EffectiveUnitName &gt;&gt;&gt; l_OurUnit
      if ( l_OurUnit l_OtherUnit != ) then
      begin
       l_OtherUnit cDot
      end // l_OurUnit l_OtherUnit !=
     end // Self .TypeName l_MainAncestor .TypeName ==
    end // l_OtherUnit .IsNotNil
   end // Self .IsPointer !
   l_MainAncestor .TypeName 
   ';' 
 ] .Out
 Self .OutDocumentation
; // OutTypedef

elem_proc OutEnum
 [ Self .TypeName ' = (' ] .Out
 Self .OutDocumentation
  STRING VAR l_Prefix
  Self .GetUP 'extprop:pas:ElementPrefix' &gt;&gt;&gt; l_Prefix
  VAR l_NeedComma
  false &gt;&gt;&gt; l_NeedComma
  Indented: ( 
   Self .Attributes .for&gt; (
     IN aChild
    aChild .IfDef: 
    (
     [ 
      l_Prefix aChild .Name
     
      VAR l_Value
      aChild .ExtValue &gt;&gt;&gt; l_Value
      if ( l_Value .IsValueValid ) then
      begin
       ' = ' l_Value ToPrintable
      end // ( l_Value .IsValueValid )
     ] strings:Cat 
      .WithComma: l_NeedComma .Out
     aChild .OutDocumentation
    ) // aChild .IfDef:
   ) // Self .Attributes .for&gt;
  ) // Indented:
 [ ');//' Self .TypeName ] .Out
; // OutEnum

elem_proc OutSetOf
 [ Self .TypeName ' = set of ' Self .MainAncestor .TypeName ';' ] .Out
 Self .OutDocumentation
; // OutSetOf

elem_proc OutFunction
 Self .MethodInterfaceEx: (
  Self .TypeName 
  ' = ' 
 ) () (
  if ( Self .UPisTrue "of object" ) then
  begin
   ' of object'
  end // ( Self .UPisTrue "of object" )
 )
 ( IN aMethod )
; // OutFunction

elem_proc OutArray
 if ( Self .IsOpenArray ! ) then
 begin
  [ 
   Self .TypeName ' = array ' 
   if ( Self .MainAncestor .IsNotNil ) then
   begin
    '[' Self .MainAncestor .TypeName '] '
   end // ( Self .MainAncestor .IsNotNil )
   'of ' 
   Self .FirstAttribute .Target .TypeName ';'
  ] .Out
  Self .OutDocumentation
 end // ( Self .IsOpenArray ! )
; // OutArray

ARRAY CompileTime-VAR g_OutedTypes nil
ARRAY CompileTime-VAR g_ForwardedTypes nil

elem_proc OutTypeKeyword

 : DoOutTypeKeyword
   if ( g_WasType ! ) then
   begin
    'type' .Out
    true &gt;&gt;&gt; g_WasType
    Self &gt;&gt;&gt; g_WasTypeOpener
    false &gt;&gt;&gt; g_WasConst
   end // g_WasType !
 ; // DoOutTypeKeyword
 
 RULES
  ( Self .IsMixIn )
   begin
    if g_WasConst then
     DoOutTypeKeyword
   end // ( Self .IsMixIn ) 
  ( Self .IsType )
   DoOutTypeKeyword
 ; // RULES
; // OutTypeKeyword
  
elem_proc OutForward
 if ( Self .NotInArray: g_OutedTypes ) then
 begin
  if ( Self .NotInArray: g_ForwardedTypes ) then
  begin
   Self .AddToArray: g_ForwardedTypes
   RULES
    ( Self .IsPureMixIn ) 
     ()
    DEFAULT 
    begin
     Self .IfDef: (
      Self .OutTypeKeyword
      Indented: (
       RULES
        ( Self .IsClass )
         ( 
          true &gt;&gt;&gt; g_WasForwarded
          [ Self .TypeName ' = class;' ] .Out OutLn 
         )
        ( Self .IsInterface )
         ( 
          true &gt;&gt;&gt; g_WasForwarded
          [ Self .TypeName ' = interface;' ] .Out OutLn 
         )
       ; // RULES  
      ) // Indented:
     ) // Self .IfDef:
    end // DEFAULT
   ; // RULES  
  end // ( Self .NotInArray: g_ForwardedTypes )
 end // ( Self .NotInArray: g_OutedTypes )
; // OutForward

BOOLEAN elem_func SomeOwnChildrenInheritsOrImplementsMixIn
 RULES
  (
   Self .ChildrenWithoutOwnFile 
   .filter&gt; .InheritsOrImplementsMixIn
   .NotEmpty
  )
   true
  DEFAULT
   false
 ; // RULES
 &gt;&gt;&gt; Result
; // SomeOwnChildrenInheritsOrImplementsMixIn

elem_iterator ForwardedEx
 Self .Forwarded
 RULES
  ( Self .IsPureMixIn )
   ()
  ( Self .IsTypedef )
   ()
  ( Self .IsInterface )
  begin
   RULES
    ( Self .Parent .IsInterface )
     ( .join&gt; ToArray: ( Self .Parent ) )
    ( Self .Parent .IsClass )
     RULES
      ( Self .Parent .IsService )
       ()
      ( Self .Parent .InheritsOrImplementsMixIn )
       ()
      ( Self .Parent .SomeOwnChildrenInheritsOrImplementsMixIn )
       ()
      DEFAULT
       ( .join&gt; ToArray: ( Self .Parent ) )
     ; // RULES  
   ; // RULES  
  end // ( Self .IsInterface )
 ; // RULES
 //.joinWithLambded&gt; ( Self .AllOwnChildren ) call.me
 &gt;&gt;&gt; Result 
; // ForwardedEx

elem_proc OutForwarded
 Self .ForwardedEx .for&gt; .OutForward
; // OutForwarded

elem_proc OutType
 RULES
  ( Self .IsElementProxy )
   ()
  ( Self .IsUtilityPack )
   ()
  ( Self .IsInterfaces )
   ()
  ( Self .IsTarget )
   ()
  ( Self .IsOpenArray )
   ()
  ( ( Self .IsStaticObject ) AND ( Self .IsConstructorsHolder ) )
   ()
  ( Self .IsUserType )
   ()
  ( Self .IsTestClass )
   ()
  ( Self .IsVCMOperations )
   () 
  ( Self .IsConstantsButNotType )
   () 
  ( Self .IsTestUnit )
   () 
  ( Self .IsUnit )
   () 
  ( Self .IsImpl )
   () 
  ( Self .IsTestLibrary )
   () 
  ( Self .IsVCMFormZone ) 
   ()
  ( Self .IsVCMZone )
   ()
  ( Self .IsExcludeUserTypes )
   ()
  DEFAULT
   (
    if ( Self .NotInArray: g_OutedTypes ) then
    begin
     Self .AddToArray: g_OutedTypes
     Self .OutForwarded
     Self .IfDef:
     (
      Self .OutTypeKeyword
      Indented: (
       RULES
        ( Self .IsSetOf )
         ( Self .OutSetOf )
        ( Self .IsArray )
         ( Self .OutArray )
        ( Self .IsEnum )
         ( Self .OutEnum )
        ( Self .IsRange )
         ( Self .OutRange )
        ( Self .IsTypedef )
         ( Self .OutTypedef )
        ( Self .IsException )
         ( Self .OutClass )
        ( Self .IsMixIn )
         ( Self .OutClass )
        //( Self .IsTestClass )
        // ( Self .OutClass )
        ( Self .IsClass )
         ( Self .OutClass )
        ( Self .IsPureMixIn ) 
         ( Self .OutPureMixIn )
        ( Self .IsInterface )
         ( Self .OutInterface )
        ( Self .IsStaticObject )
         ( Self .OutStaticObject )
        ( Self .IsUnion )
         ( Self .OutRecord )
        ( Self .IsRecord )
         ( Self .OutRecord )
        ( Self .IsUndef )
         ( Self .OutUndef )
        ( Self .IsDefine )
         ( Self .OutDefine )
        ( Self .IsFunction )
         ( Self .OutFunction )
        DEFAULT
         ( [ '// ' Self .TypeName ] .Out )
       ; // RULES 
      ) // Indented:
      OutLn
     ) // Self .IfDef:
    end // ( Self .NotInArray: g_OutedTypes )
   ) // DEFAULT
 ; // RULES
; // OutType

BOOLEAN elem_func NeedForwarded
 RULES
  ( Self .IsType )
   true
  ( Self .IsPureMixIn )
   true
  DEFAULT
   false
 ; // RULES
 &gt;&gt;&gt; Result  
; // NeedForwarded

elem_proc OutChildrenRecPrim
  IN aValid
  IN aOut
  IN aNeedIfDef
  
  elem_proc DoOut
   if ( aNeedIfDef
       AND ( Self .NeedForwarded )
       AND ( Self aValid DO )
      ) then
   begin
    Self .OutForwarded
    Self .IfDef:
    (
     if ( Self .InheritsOrImplementsMixIn ! ) then
     begin
      if ( Self .SomeOwnChildrenInheritsOrImplementsMixIn ! ) then
      begin
       Self .ConstantsAndChildrenWithoutOwnFile
       .filter&gt; ( Self .InheritsFrom )
       .for&gt; .OutForward
      end // ( Self .SomeOwnChildrenInheritsOrImplementsMixIn ! )
     end // ( Self .InheritsOrImplementsMixIn ! )
     
     Self .ConstantsAndChildrenWithoutOwnFile
     .filter&gt; ( Self .InheritsFrom ! )
     .for&gt; call.me
     
     if ( Self aValid DO ) then
     begin
      Self aOut DO
     end // ( Self aValid DO )
     
     Self .ConstantsAndChildrenWithoutOwnFile
     .filter&gt; ( Self .InheritsFrom )
     .for&gt; call.me
     
    ) // Self .IfDef:
   end // ( Self .IsType )
   else
   begin
    Self .ConstantsAndChildrenWithoutOwnFile
    .filter&gt; ( Self .InheritsFrom ! )
    .for&gt; call.me
    if ( Self aValid DO ) then
    begin
     Self aOut DO
    end // ( Self aValid DO )
    Self .ConstantsAndChildrenWithoutOwnFile
    .filter&gt; ( Self .InheritsFrom )
    .for&gt; call.me
   end // ( Self .IsType )
  ; // DoOut
  
 Self .DoOut 
; // OutChildrenRecPrim

elem_proc OutChildrenRec
  IN aValid
  IN aOut
 Self aValid aOut false .OutChildrenRecPrim
; // OutChildrenRec  
  
elem_proc OutTypeRec
  IN aValid
  IN aOut
 Self aValid aOut true .OutChildrenRecPrim
; // OutTypeRec

elem_proc OutChildrenRec:
  ^ IN aValid
  ^ IN aOut
 Self aValid aOut .OutChildrenRec
; // OutChildrenRec:

WordAlias .ForChildren&gt; .OutChildrenRec:
  
elem_proc OutTypes
  ^ IN aValid
  
 DropWasType
 
 : DoOutType
   IN aChild
  //aChild .IfDef: 
  ( 
   aChild .OutType
  ) // aChild .IfDef:
 ; // DoOutType
 
/*{ 
 Self @ ( 
   IN aChild 
  aChild aValid DO 
  AND ( aChild .IsEnum )
 ) @ DoOutType .OutTypeRec

 Self @ ( 
   IN aChild 
  aChild aValid DO 
  AND ( aChild .IsSetOf )
 ) @ DoOutType .OutTypeRec
}*/

 Self @ ( 
   IN aChild 
  aChild aValid DO 
  AND ( aChild .UPisTrue "is default ancestor" )
 ) @ DoOutType .OutTypeRec
 
 Self @ ( 
   IN aChild 
  aChild aValid DO 
  AND ( aChild .IsPointer )
 ) @ DoOutType .OutTypeRec

 Self @ ( 
   IN aChild 
  aChild aValid DO 
  AND ( aChild .IsClassRef )
 ) @ DoOutType .OutTypeRec
 
/*{ 
 Self @ ( 
   IN aChild 
  aChild aValid DO 
  AND ( aChild .IsPureMixIn )
 ) @ DoOutType .OutTypeRec
}*/ 
 
 Self @ ( 
   IN aChild 
  aChild aValid DO 
 ) @ DoOutType .OutTypeRec
; // OutTypes

PROCEDURE OutConstKeyword
 if ( g_WasConst ! ) then
 begin
  DropWasType
  true &gt;&gt;&gt; g_WasConst
  'const' .Out
 end // ( g_WasConst ! )
; // OutConstKeyword

elem_proc OutConstants
 RULES
  ( Self .IsConstantArray )
   (
    VAR l_MainAncestor
    [ 
     Self .Name 
     ': array '
     '['
     VAR l_MainImplements
     Self .MainImplements &gt;&gt;&gt; l_MainImplements
     if ( l_MainImplements .IsNil ) then
     begin
     '0 .. ' Self .Attributes .CountIt 1 -
     end // ( l_MainImplements .IsNil )
     else
     begin
      l_MainImplements .TypeName
     end // ( l_MainImplements .IsNil )
     ']'
     ' of ' 
     Self .MainAncestor &gt;&gt;&gt; l_MainAncestor
     l_MainAncestor .TypeName
     ' = ('
    ] .Out 
     
     VAR l_WasComma
     false &gt;&gt;&gt; l_WasComma
     
     VAR l_IsPointer
     l_MainAncestor .IsPointer &gt;&gt;&gt; l_IsPointer
     
     Self .Attributes
/*{     .map&gt; ( 
      .ExtValue
      if l_IsPointer then
      begin
       '@'
       SWAP
       Cat
      end // l_IsPointer
     ) }*/
     .for&gt; (
       IN anItem
      anItem .IfDef:
      ( 
       ( 
        anItem .ExtValue 
        if l_IsPointer then
        begin
         '@'
         SWAP
         Cat
        end // l_IsPointer
       ) 
       .WithComma: l_WasComma .Out
      ) // anItem .IfDef:
     ) 
     
    [ 
     ');' 
    ] .Out
   ) // ( Self .IsConstantArray )
   ( Self .IsSetConst )
    (
     [ 
      Self .Name ' = '
      RULES 
       ( Self .Attributes .NotEmpty )
        ( 
         STRING VAR l_Prefix
         Self .MainAncestor .GetUP 'extprop:pas:ElementPrefix' &gt;&gt;&gt; l_Prefix
         VAR l_WasComma
         false &gt;&gt;&gt; l_WasComma
         '['
         Self .Attributes 
         .map&gt; .ExtValue
         .filter&gt; .IsValueValid
         .map&gt; ( l_Prefix SWAP Cat )
         .for&gt; (
          .WithComma: l_WasComma .KeepInStack
         ) // .for&gt;
         ']'
        )
       ( Self .MainAncestor .IsSetConst )
        ( 
         if ( Self .EffectiveUnitName Self .MainAncestor .EffectiveUnitName != ) then
         begin
          Self .MainAncestor .EffectiveUnitName cDot
         end // ( Self .EffectiveUnitName Self .MainAncestor .EffectiveUnitName != )
         Self .MainAncestor .Name 
        )
       DEFAULT
        (
         VAR l_MainAncestor
         Self .MainAncestor &gt;&gt;&gt; l_MainAncestor
         if ( l_MainAncestor .IsSetOf ) then
         begin
          l_MainAncestor .MainAncestor &gt;&gt;&gt; l_MainAncestor
         end // ( l_MainAncestor .IsSetOf )
         '[' 'Low(' l_MainAncestor .TypeName ')' ' .. ' 'High(' l_MainAncestor .TypeName ')' ']'
        )
      ; // RULES   
      ';' 
     ] .Out
    ) // ( Self .IsSetConst )
  DEFAULT
   (
    STRING VAR l_Prefix
    Self .GetUP 'extprop:pas:ElementPrefix' &gt;&gt;&gt; l_Prefix
    Self .Attributes .for&gt; (
      IN anItem
     anItem .IfDef: 
     ( 
      [ 
       l_Prefix anItem .Name
    
       if ( anItem .UPisTrue "is define" ! ) then
       begin
        VAR l_Type 
        anItem .Target &gt;&gt;&gt; l_Type
        l_Type .IsNotNil ? ( ': ' l_Type .TypeName )
       end // ( anItem .UPisTrue "is define" ! )
    
       BOOLEAN VAR l_NeedSuffix
       false &gt;&gt;&gt; l_NeedSuffix
       VAR l_Value
       anItem .ExtValue &gt;&gt;&gt; l_Value
       if ( l_Value .IsValueValid ! ) then
       begin
        anItem .GetUP 'Value' &gt;&gt;&gt; l_Value
        true &gt;&gt;&gt; l_NeedSuffix
       end
    
       ' = ' l_Value
    
       if l_NeedSuffix then
       begin
        VAR l_Suffix
        anItem .GetUP "suffix expr" &gt;&gt;&gt; l_Suffix
        if ( l_Suffix .IsValueValid ) then
        begin
         cSpace l_Suffix 
        end // ( l_Suffix .IsValueValid )
       end // l_NeedSuffix
    
       ';' 
      ] .Out? ? (
       anItem .OutDocumentation
      ) // ] .Out? ?
     ) // anItem .IfDef: 
    ) // Self .Attributes .for&gt;
   ) // DEFAULT 
 ; // RULES  
; // OutConstants

FUNCTION .OutConstantsList
  ARRAY IN aList
 VAR l_WasConst
 false &gt;&gt;&gt; Result
 aList .for&gt; (
   IN anItem
  RULES
   ( anItem .IsLocalConst )
    ()
   DEFAULT
    (
     anItem .IfDef: 
     (
      true &gt;&gt;&gt; Result
      OutConstKeyword
      anItem .OutDocumentation
      Indented: ( 
       anItem .OutConstants 
      ) // Indented:
     ) // anItem .IfDef:
    ) // DEFAULT
  ; // RULES 
 )
; // .OutConstantsList

INTEGER elem_func ConstantsListVisibility
 Cached:
 (
  RULES
   ( Self .IsNil )
    PrivateAccess
   ( Self .IsConstantArray )
    (
     INTEGER VAR l_Vis 
     Self .Visibility &gt;&gt;&gt; l_Vis
     RULES
      ( l_Vis PublicAccess == )
       (
        VAR l_MainImplements
        Self .MainImplements &gt;&gt;&gt; l_MainImplements
        RULES
         ( l_MainImplements .IsNotNil )
          (
           RULES
            ( Self .UnitProducer l_MainImplements .UnitProducer == )
             ProtectedAccess
            DEFAULT
             l_Vis
           ; // RULES
          ) 
         DEFAULT
          l_Vis
        ; // RULES
       ) // ( l_Vis PublicAccess == )
      DEFAULT
       l_Vis
     ; // RULES  
    ) // ( Self .IsConstantArray )
   ( Self .IsLocalConst )
    ( Self .Visibility ) 
   ( Self .IsSetConst )
    (
     INTEGER VAR l_Vis 
     Self .Visibility &gt;&gt;&gt; l_Vis
     RULES
      ( l_Vis PublicAccess == )
       ProtectedAccess
      DEFAULT
       l_Vis
     ; // RULES 
    ) // ( Self .IsSetConst ) 
   ( Self .IsConstants )
    (
     INTEGER VAR l_Vis 
     Self .Visibility &gt;&gt;&gt; l_Vis
     RULES
      ( l_Vis PublicAccess == )
       (
        BOOLEAN VAR l_Protected
        Self .Attributes
        .mapToTarget&gt;
        .filterNil&gt;
        .filter&gt; (
         .UnitProducer Self .UnitProducer .IsSameModelElement
        )
        .NotEmpty
        &gt;&gt;&gt; l_Protected
        
        if ( l_Protected ! ) then
        begin
         Self .Attributes
         .map&gt; .ValueType
         .filterNil&gt;
         .filter&gt; (
          .UnitProducer Self .UnitProducer .IsSameModelElement
         )
         .NotEmpty
         &gt;&gt;&gt; l_Protected
        end // ( l_Protected ! )
        
        RULES
         l_Protected
          ProtectedAccess
         DEFAULT
          l_Vis
        ; // RULES   
       ) // ( l_Vis PublicAccess == )
      DEFAULT 
       l_Vis
     ; // RULES  
    ) // ( Self .IsConstants )   
   DEFAULT
    ( Self .Visibility )
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // ConstantsListVisibility

elem_proc OutDefinitionsSection:
  ^ IN aValid
  
 : .Suitable aValid DO ; 
  
 VAR l_WasConst
 
 false &gt;&gt;&gt; l_WasConst
 Self .ForChildren&gt; .Suitable (
  .ConstantsEx .filter&gt; ( .ConstantsListVisibility PublicAccess == ) if .OutConstantsList ( true &gt;&gt;&gt; l_WasConst )
 )
 if l_WasConst then
  OutLn

 Self .OutTypes .Suitable
 
 false &gt;&gt;&gt; l_WasConst
 Self .ForChildren&gt; .Suitable (
  .ConstantsEx .filter&gt; ( .ConstantsListVisibility ProtectedAccess == ) if .OutConstantsList ( true &gt;&gt;&gt; l_WasConst )
 )
 if l_WasConst then
  OutLn

; // OutDefinitionsSection:

elem_iterator GlobalOperationsForOverload
 RULES
  ( ( Self .IsStaticObject ) AND ( Self .IsConstructorsHolder ) )
   ( ( Self .MainAncestor .GlobalOperations ) .join&gt; ( Self .GlobalOperations ) )
  DEFAULT
   ( Self .GlobalOperations )
 ; // RULES
 &gt;&gt;&gt; Result
; // GlobalOperationsForOverload

elem_proc OutVar
 Self .IfDef:
 (
  [
   'var '
   
   RULES
    ( Self .IsGlobalVar )
     'g_'
    ( Self .IsLocalVar )
     'l_'
   ; // RULES 
    
   Self .Name
   ': '
   if ( Self .Target .IsMethod ) then
   begin
    Self .Target .MainAncestor .TypeName
    ' = ' Self .Target .MethodName
   end // ( Self .Target .IsMethod )
   else
   begin
    Self .Target .TypeName
    
    if ( Self .UPisTrue "IsResult" ) then
    begin
     ' absolute Result'
    end // ( Self .UPisTrue "IsResult" )
    
    VAR l_Value
    Self .ExtValue &gt;&gt;&gt; l_Value
    if ( l_Value .IsValueValid ) then
    begin
     ' = ' l_Value
    end // ( l_Value .IsValueValid )
   end // ( Self .Target .IsMethod )
   
   ';'
  ] .Out
  Self .OutDocumentation
 ) // Self .IfDef:
; // OutVar

elem_proc OutInterfaceSection
 Self .OutDefinitionsSection: .IsForInterface
 
 VAR l_WasOut
 false &gt;&gt;&gt; l_WasOut
 Self .ForChildren&gt; .IsForInterface (
   IN anItem
  VAR l_GlobalOperations
  anItem .GlobalOperations &gt;&gt;&gt; l_GlobalOperations
  VAR l_GlobalOperationsForOverload
  anItem .GlobalOperationsForOverload &gt;&gt;&gt; l_GlobalOperationsForOverload
  l_GlobalOperations 
  .filter&gt; ( .Visibility PrivateAccess != )
  .for&gt; .MethodInterfaceForEx: l_GlobalOperationsForOverload ( IN aMethod true &gt;&gt;&gt; l_WasOut )
 )
 
 l_WasOut ? OutLn
 
 false &gt;&gt;&gt; l_WasOut
 Self .ForChildren&gt; .IsForInterface (
  .GlobalVars 
  .filter&gt; ( .Visibility PrivateAccess != ) 
  .for&gt; ( .OutVar true &gt;&gt;&gt; l_WasOut )
 ) 
 
 l_WasOut ? OutLn
; // OutInterfaceSection

elem_iterator LocalMethods
 Self .OperationsEx
 .filter&gt; .IsLocalMethod
 &gt;&gt;&gt; Result
; // LocalMethods

elem_iterator LocalVars
 Self .Attributes
 .filter&gt; .IsLocalVar
 .filter&gt; ( .IsGlobalVar ! )
 &gt;&gt;&gt; Result
; // LocalVars

elem_proc MethodBody
 if ( Self .UPisTrue 'extprop:isAsm' ) then
 begin
  'asm' .Out
  ' jmp l3LocalStub' .Out
 end // ( Self .UPisTrue 'extprop:isAsm' )
 else 
 begin
  if ( Self .IsControlPrim ! ) then
  begin
   if ( Self .IsIteratorF ! ) then
   begin
    TF g_MethodParentPrefix (
     '' &gt;&gt;&gt; g_MethodParentPrefix
     
     Self .LocalVars .for&gt; .OutVar
      
     Indented:
     (
      elem_proc OutLocalMethod:
        ^ IN aLambda
       OutLn 
       Self .MethodInterfaceForEx: nil ( aLambda DO )
      ; // OutLocalMethod:
      
      Self .LocalMethods 
      .filter&gt; ( .MethodVisibility PrivateAccess == )
      .for&gt; .OutLocalMethod: ( call.me )
      Self .LocalMethods 
      .filter&gt; ( .MethodVisibility ProtectedAccess == )
      .for&gt; .OutLocalMethod: ( call.me )
      Self .LocalMethods 
      .filter&gt; ( .MethodVisibility PublicAccess == )
      .for&gt; .OutLocalMethod: ( call.me )
     ) // Indented:
    ) // TF g_MethodParentPrefix
   end // ( Self .IsIteratorF ! )
   
   if ( Self .IsFormSetFactory ) then
   begin
    if ( Self .UPisTrue "NO_FACTORY_BRACKECTS" ! ) then
    begin
     'var' .Out
     ' __WasEnter : Boolean;' .Out
    end // ( Self .UPisTrue "NO_FACTORY_BRACKECTS" ! )
   end // ( Self .IsFormSetFactory )
    
   Self .UserCode: cVarUserCodeSuffix ()
  end // ( Self .IsControlPrim ! )
  
  'begin' .Out
  
  if ( Self .IsFormSetFactory ) then
  begin
   if ( Self .UPisTrue "NO_FACTORY_BRACKECTS" ! ) then
   begin
    ' __WasEnter := vcmEnterFactory;' .Out
    ' try' .Out
   end // ( Self .UPisTrue "NO_FACTORY_BRACKECTS" ! )
  end // ( Self .IsFormSetFactory )
  
  VAR l_WasOut
  false &gt;&gt;&gt; l_WasOut
  
  RULES
   ( Self .IsControlPrim )
    begin
     Indented:
     (
      [ 'if (' Self .FieldName ' = nil) then' ] .Out
      [ ' ' Self .FieldName ' := FindComponent('  cQuote Self .Name cQuote ') As ' Self .AttrType .TypeName ';' ] .Out
      [ 'Result := ' Self .FieldName ';' ] .Out
     ) // Indented:
     true &gt;&gt;&gt; l_WasOut
    end // ( Self .IsControlPrim )
   ( Self .IsIteratorF ! )
    begin
     Indented:
     (
      Self .Dependencies
      .filter&gt; ( .IsStereotype st_call::Dependency )
      .filter&gt; ( .Target .IsIterator )
      .for&gt; (
        IN aDep
       Self .UserCode: 'iter' () 
       
       VAR l_Target
       aDep .Target &gt;&gt;&gt; l_Target
       
       VAR l_NeedsParams
       aDep .UPisTrue "iterator needs params" &gt;&gt;&gt; l_NeedsParams
       
       if l_NeedsParams then
       begin
        if ( l_Target .MethodParameters .filter&gt; .IsInParam .IsEmpty ) then
        begin
         false &gt;&gt;&gt; l_NeedsParams
        end // ( l_Target .MethodParameters .filter&gt; .IsInParam .IsEmpty )
       end // l_NeedsParams
       
       VAR l_NeedsAfter
       aDep .UPisTrue "needs after iterator UC" &gt;&gt;&gt; l_NeedsAfter
       [
        if ( l_Target .IsServiceIterator ) then
        begin
         l_Target .Parent .TypeName '.Instance.'
        end // ( l_Target .IsServiceIterator )
        
        VAR l_Name 
        l_Target .MethodName &gt;&gt;&gt; l_Name
        l_Name
        
        if ( 'F' l_Name EndsStr ! ) then
         'F'
         
        '('
        l_Target .IteratorStub .MethodName
        '('
        '@'
        
        VAR l_IteratorFuncName
        aDep .GetUP "iterator func name" &gt;&gt;&gt; l_IteratorFuncName
        if ( l_IteratorFuncName .IsNil ) then
        begin
         'DoIt' &gt;&gt;&gt; l_IteratorFuncName
        end // ( l_IteratorFuncName .IsNil )
        
        l_IteratorFuncName
        ')' 
        
        if ( l_NeedsParams ! ) then
        begin
         ')'
         if ( l_NeedsAfter ! ) then
          ';' 
        end // ( l_NeedsParams ! )
       ] .Out
       
       if l_NeedsParams then
       begin
        Self .UserCode: 'iterparam' ()
        [ 
         ')' 
         if ( l_NeedsAfter ! ) then
          ';' 
        ] .Out
       end // l_NeedsParams
       
       if l_NeedsAfter then
       begin
        Self .UserCode: 'afteriter' ()
       end // l_NeedsAfter
       
       true &gt;&gt;&gt; l_WasOut
      ) // .for&gt;
     ) // Indented:
    end // ( Self .IsIteratorF ! )
  ; // RULES 
  
  if ( l_WasOut ! ) then
  begin
   Self .UserCode: cImplementationUserCodeSuffix cNeedsToBeImplemented
  end // ( l_WasOut ! )
 
  if ( Self .IsFormSetFactory ) then
  begin
   if ( Self .UPisTrue "NO_FACTORY_BRACKECTS" ! ) then
   begin
    ' finally' .Out
    '  if __WasEnter then' .Out
    '   vcmLeaveFactory;' .Out
    ' end;//try..finally' .Out
   end // ( Self .UPisTrue "NO_FACTORY_BRACKECTS" ! )
  end // ( Self .IsFormSetFactory )
 end // ( Self .UPisTrue 'extprop:isAsm' )
  
 [ 'end;//' g_MethodParentPrefix Self .MethodNamePrefix Self .MethodName ] .Out
 OutLn
; // MethodBody

BOOLEAN elem_func NeedsInstanceR
 Cached:
 (
  RULES
   ( Self .UPisTrue "needs InstanceR" )
    true
   ( Self .InheritsEx .filter&gt; call.me .NotEmpty )
    true 
   ( Self .ImplementsEx .filter&gt; call.me .NotEmpty )
    true 
   DEFAULT
    false
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // NeedsInstanceR

elem_proc OutClassImplementation

 if ( Self .IsVCMCustomForm ) then
 begin
  if ( Self .Abstraction at_final == ) then
  begin
   [ '{$R *.DFM}' \n ] .Out
  end // ( Self .Abstraction at_final == )
 end // ( Self .IsVCMCustomForm )
 
 Self .IfDef:
 (
  Self .DefineImplementedMixInValues
  
  if ( Self .ImplementsMixIn ) then
  begin
   if ( Self .AllInlinedOperations .NotEmpty ) then
   begin
    Self .OutOtherMixinValues
   end // ( Self .AllInlinedOperations .NotEmpty )
  end // ( Self .ImplementsMixIn )
  
  TF g_Implementor (
   Self &gt;&gt;&gt; g_Implementor
   BOOLEAN VAR l_WasFirst
   false &gt;&gt;&gt; l_WasFirst
   TF g_EnableAutoEOL (
    false &gt;&gt;&gt; g_EnableAutoEOL
    TF g_EnableMethodDocumentation (
     false &gt;&gt;&gt; g_EnableMethodDocumentation
     Self .AllInlinedOperations 
     .filter&gt; (
       IN aMethod
      if l_WasFirst then
       true
      else
      begin
       true &gt;&gt;&gt; l_WasFirst
       false
      end
     ) // .filter&gt;
     .for&gt; .MethodInterfaceForEx: nil (
       IN aMethod
      ' forward;' .Out
      OutLn
      OutLn
     ) // .for&gt; .MethodInterfaceForEx: nil
    ) // TF g_EnableMethodDocumentation
   ) // TF g_EnableAutoEOL 
   Self .AllInlinedOperations .for&gt; .MethodInterfaceForEx: nil .MethodBody
  ) // TF g_Implementor
  
  VAR l_WasInstanceR
  Self .IsMixIn &gt;&gt;&gt; l_WasInstanceR
  
  Self .InheritsEx
  .join&gt; ( Self .ImplementsEx )
  .filter&gt; .IsMixIn 
  .for&gt; ( 
    IN aG
    
   if ( l_WasInstanceR ! ) then
   begin
    if ( aG .NeedsInstanceR ) then
    begin
     true &gt;&gt;&gt; l_WasInstanceR
     [ 'type _Instance_R_ = ' Self .TypeName ';' ] .Out
     OutLn
    end // ( aG .NeedsInstanceR )
   end // ( l_WasInstanceR ! )
   
   aG .OutMixInInclude
   OutLn
  ) // .for&gt;
  
  TF g_Implementor (
   Self &gt;&gt;&gt; g_Implementor
   TF g_MethodParentPrefix (
    Self .TypeName &gt;&gt;&gt; g_MethodParentPrefix
    g_MethodParentPrefix cDot Cat &gt;&gt;&gt; g_MethodParentPrefix
    TF g_EnableMethodDirectives (
     false &gt;&gt;&gt; g_EnableMethodDirectives
     Self .AllOperationsForDefine 
     .filter&gt; ( .MethodAbstraction at_abstract != )
     .for&gt; .MethodInterfaceForEx: nil .MethodBody
    ) // TF g_EnableMethodDirectives
   ) // TF g_MethodParentPrefix
  ) // TF g_Implementor 
  
  if ( Self .UPisTrue "need UC" ) then
  begin
   Self .UserCode: 'impl' ()
   OutLn
  end // ( Self .UPisTrue "need UC" ) 
 
  Self .UndefineImplementedMixInValues
 ) // Self .IfDef:

; // OutClassImplementation

elem_proc OutTestClassImplementation

 elem_proc MethodBody
  Self .UserCode: cVarUserCodeSuffix ()
  'begin' .Out
  ' with Self do' .Out
  ' begin' .Out
   Self .UserCode: cImplementationUserCodeSuffix cNeedsToBeImplemented
  ' end;//with Self' .Out 
  [ 'end;//' g_MethodParentPrefix Self .MethodNamePrefix Self .MethodName ] .Out
  OutLn
 ; // MethodBody
 
 elem_iterator ParamsOrKeys
  if ( Self .IsProperty ) then
   ( Self .PropertyKeys )
  else 
   ( Self .MethodParameters )
  .filter&gt; ( 'Self' .HasName ! ) 
  &gt;&gt;&gt; Result 
 ; // ParamsOrKeys
 
 elem_iterator OperationsAndProperties
  Self .OperationsEx
  .join&gt; ( Self .Properties )
  &gt;&gt;&gt; Result
 ; // OperationsAndProperties
 
 TF g_MethodParentPrefix (
  Self .TypeName &gt;&gt;&gt; g_MethodParentPrefix
  g_MethodParentPrefix cUnderline Cat &gt;&gt;&gt; g_MethodParentPrefix
  
  Self .OperationsAndProperties .for&gt; .MethodInterfaceForEx: nil .MethodBody

  [ 5 6 ] .for&gt; (
    IN aNum
   
   STRING elem_func ToVariant
    RULES
     ( Self .IsSimpleClass )
      ( [ 'tc' aNum IntToStr 'PublicInfo.VarFromObject' ] strings:Cat )
     DEFAULT
      ''
    ; // RULES
    &gt;&gt;&gt; Result   
   ; // ToVariant
   
   STRING elem_func FromVariant
    RULES
     ( Self .Name 'String' == )
      '__coerce_String'
     ( Self .Name 'AnsiString' == )
      '__coerce_String'
     DEFAULT
      'OleVariant'
    ; // RULES
    &gt;&gt;&gt; Result   
   ; // ToVariant
   
   Self .OperationsAndProperties .for&gt; (
     IN aMethod
    if ( aMethod .IsWriteonlyProperty ! ) then
    begin 
     VAR l_MethodName
     [ 
      g_MethodParentPrefix 
      
      if ( aMethod .IsProperty ) then
       'Get_'
      
      aMethod .Name 
     ] strings:Cat &gt;&gt;&gt; l_MethodName
     
     [ 'procedure ' l_MethodName '_Pub' aNum '(Instance: TObject; Args: PVariantArgList; out Value: OleVariant; Cookie: Cardinal); stdcall;' ] .Out
     'begin' .Out
     [ ' Assert(Instance is ' Self .MainAncestor .TypeName ');' ] .Out
     ' try' .Out
     [ '  ' 
      if ( aMethod .MethodType .IsNotNil ) then
      begin
       'Value := ' aMethod .MethodType .ToVariant '('
      end // ( aMethod .MethodType .IsNotNil )
      l_MethodName 
      '(' 
      Self .EffectiveType .TypeName '(' 'Instance' ')' 
      
      VAR l_Index
      0 &gt;&gt;&gt; l_Index
      aMethod .ParamsOrKeys .for&gt; ( 
        IN aParam
       ', ' 
       aParam .Target .FromVariant
       '('
       'Args^['
       l_Index
       ']'
       ')'
       INC l_Index
      ) // aMethod .ParamsOrKeys .for&gt;
      ')' 
      if ( aMethod .MethodType .IsNotNil ) then
       ')'
      ';' 
     ] .Out
     ' except' .Out
     '  // - гасим исключения' .Out
     if ( aMethod .MethodType .IsNotNil ) then
     begin
      '  Value := Unassigned;' .Out
     end // ( aMethod .MethodType .IsNotNil )
     ' end;//try..except' .Out
     'end;' .Out
     OutLn
    end // ( aMethod .IsWriteonlyProperty ! ) 
    
    if ( aMethod .IsProperty ) then
    if ( aMethod .IsReadonlyProperty ! ) then
    begin 
     VAR l_MethodName
     [ 
      g_MethodParentPrefix 
      
       'Set_'
      
      aMethod .Name 
     ] strings:Cat &gt;&gt;&gt; l_MethodName
     
     [ 'procedure ' l_MethodName '_Pub' aNum '(Instance: TObject; Args: PVariantArgList; out Value: OleVariant; Cookie: Cardinal); stdcall;' ] .Out
     'begin' .Out
     [ ' Assert(Instance is ' Self .MainAncestor .TypeName ');' ] .Out
     ' try' .Out
     [ '  ' 
      l_MethodName 
      '(' 
      Self .EffectiveType .TypeName '(' 'Instance' ')' 
      
      ', ' 
      aMethod .Target .FromVariant
      '('
      'Args^['
      0
      ']'
      ')'
      
      ')' 
      ';' 
     ] .Out
     ' except' .Out
     '  // - гасим исключения' .Out
     ' end;//try..except' .Out
     'end;' .Out
     OutLn
    end // ( aMethod .IsReadonlyProperty ! )
    
   ) // Self .OperationsAndProperties .for&gt;
   
   [ 'procedure _RegisterPublicInformation' aNum ';' ] .Out
   'begin' .Out
    Self .OperationsAndProperties .for&gt; (
      IN aMethod
     if ( aMethod .IsWriteonlyProperty ! ) then
     begin 
      VAR l_MethodName
      [ 
       g_MethodParentPrefix 
       
       if ( aMethod .IsProperty ) then
        'Get_'
       
       aMethod .Name 
       '_Pub'
       aNum IntToStr
      ] strings:Cat &gt;&gt;&gt; l_MethodName
      [ 
       ' ' 'tc' aNum 'PublicInfo._RegisterMethod' 
       '(' 
       Self .MainAncestor .TypeName
       ', '
       'tc' aNum 'OpenAppClasses' cDot 
       
       if ( aMethod .IsProperty ) then
        'mtGet'
       else
        'mtInvoke'
       
       ', '
       cQuote aMethod .Name cQuote
       
       ', '
       if ( aMethod .MethodType .IsNil ) then
        'nil'
       else
       begin
        'TypeInfo(' aMethod .MethodType .TypeName ')'
       end 
       
       ', '
       '['
       (
        VAR l_WasComma
        false &gt;&gt;&gt; l_WasComma
        aMethod .ParamsOrKeys .map&gt; ( .Target .TypeName 'TypeInfo(' SWAP Cat ')' Cat ) .for&gt; (
         .WithComma: l_WasComma .KeepInStack
        )
       )
       ']'
       
       ', '
       '['
       (
        VAR l_WasComma
        false &gt;&gt;&gt; l_WasComma
        aMethod .ParamsOrKeys .map&gt; ( .Name cQuote SWAP Cat cQuote Cat ) .for&gt; (
         .WithComma: l_WasComma .KeepInStack
        )
       )
       ']'
       
       ', '
       l_MethodName
       
       ')' ';' 
      ] .Out 
     end // ( aMethod .IsWriteonlyProperty ! )
     
     if ( aMethod .IsProperty ) then
     if ( aMethod .IsReadonlyProperty ! ) then
     begin 
      VAR l_MethodName
      [ 
       g_MethodParentPrefix 
       
       'Set_'
       
       aMethod .Name 
       '_Pub'
       aNum IntToStr
      ] strings:Cat &gt;&gt;&gt; l_MethodName
      [ 
       ' ' 'tc' aNum 'PublicInfo._RegisterMethod' 
       '(' 
       Self .MainAncestor .TypeName
       ', '
       'tc' aNum 'OpenAppClasses' cDot 
       
       'mtPut'
       
       ', '
       cQuote aMethod .Name cQuote
       
       ', '
       'nil'
       
       ', '
       '['
       ']'
       
       ', '
       '['
       ']'
       
       ', '
       l_MethodName
       
       ')' ';' 
      ] .Out 
     end // ( aMethod .IsReadonlyProperty ! )
    ) // Self .OperationsAndProperties .for&gt;
   'end;' .Out
   OutLn
   
  ) // [ 5 6 ] .for&gt;
 ) // TF g_MethodParentPrefix
; // OutTestClassImplementation

elem_proc OutImplementation
 RULES
  ( Self .IsClassOrMixIn )
   ( Self .OutClassImplementation )
  ( Self .IsStaticObject )
   ( Self .OutClassImplementation )
  ( Self .IsException )
   ( Self .OutClassImplementation )
  ( Self .IsTestClass )
   ( Self .OutTestClassImplementation )
 ; // RULES
; // OutImplementation

elem_proc OutIniOrFini
 Self .IfDef:
 (
  Self .UserCode: cEmptyStr ()
  Self .OutDocumentation
 ) // Self .IfDef:
; // OutIniOrFini

INTERFACE elem_func RegisterTestCaseMethod
 (
  'RegisterTestCase' MakeIniProcedure: (
    IN aMade
   aMade -&gt;^ cUserCodePrefix ^:= [ 
   ' TestFramework.RegisterTest(' Self .TypeName '.Suite);'
   ]
  ) // MakeIniProcedure:
 )
 &gt;&gt;&gt; Result
; // RegisterTestCaseMethod

INTERFACE elem_func RegisterTestClassMethod
 (
  'RegisterTestClass' MakeIniProcedure: (
    IN aMade
   aMade -&gt;^ cUserCodePrefix ^:= [ 
   ' _RegisterPublicInformation5;' \n ' _RegisterPublicInformation6;'
   ]
  ) // MakeIniProcedure:
 )
 &gt;&gt;&gt; Result
; // RegisterTestClassMethod

INTERFACE elem_func RegisterTagTableMethod
 (
  'RegisterTagTable' MakeIniProcedure: (
    IN aMade
   aMade -&gt;^ cUserCodePrefix ^:= [ 
   cSpace Self .TypeName '.SetAsDefault;'
   ]
  ) // MakeIniProcedure:
 )
 &gt;&gt;&gt; Result
; // RegisterTagTableMethod

INTERFACE elem_func RegisterServiceImplementationMethod
 (
  'bind' MakeIniProcedure: (
    IN aMade
   aMade -&gt; %SUM := ( 'Регистрация ' Self .TypeName Cat )
   aMade .AddMethodWithParams: cUserCodePrefix Self .BindServiceImplementationUC
  ) // MakeIniProcedure:
 )
 &gt;&gt;&gt; Result
; // RegisterServiceImplementationMethod

INTERFACE elem_func MakeIniStr
  STRING IN aName
  ModelElement IN aSpeller
  STRING IN aPrefix
  ModelElement IN aParent
 (
  aName MakeIniProcedure: (
    IN aMade
   aMade -&gt; %SUM := ( [ 'Инициализация ' aPrefix Self .Name ] strings:Cat )
   aMade -&gt; Parent := ( aParent .WeakRef )
   aMade -&gt; "ifdef" := ( Self .IfDefStr )
   aMade -&gt; "ifndef" := ( Self .IfNDefStr )
   aMade .AddMethodWithParams: cUserCodePrefix ( Self aSpeller ) .InitStrUCPrim
  ) // MakeIniProcedure:
 )
 &gt;&gt;&gt; Result
; // MakeIniStr

elem_iterator IniOperationsPrim
 Self .OperationsEx
 .filter&gt; .IsIni
 &gt;&gt;&gt; Result
; // IniOperationsPrim

INTERFACE elem_func RegTypeMethod
 Cached:
 (
  VAR l_TypeName
  Self .TypeName &gt;&gt;&gt; l_TypeName
  VAR l_Name 
  'Reg_Type_' l_TypeName Cat &gt;&gt;&gt; l_Name
  l_Name MakeIniProcedure: (
    IN aMade
   aMade -&gt; "ifndef" := 'NoScripts'
   aMade -&gt; %SUM := ( 'Регистрация типа ' l_TypeName Cat ) 
   aMade -&gt;^ cUserCodePrefix ^:= [ 
    ' ' 
    'TtfwTypeRegistrator.RegisterType('
    Self .TypeInfo
    ');'
   ] // aMade -&gt;^ cUserCodePrefix
  ) // MakeIniProcedure:
 )
 &gt;&gt;&gt; Result
; // RegTypeMethod

elem_iterator IniOperations
 Cached:
 (
  VAR l_IniOperations
  Self .IniOperationsPrim &gt;&gt;&gt; l_IniOperations
  l_IniOperations
  RULES
   ( Self .IsConstants )
    begin 
     VAR l_Speller
     Self .Speller &gt;&gt;&gt; l_Speller
     RULES
      ( l_Speller .IsNotNil )
       begin
        VAR l_Parent
        Self .ElementOrParentThatCanHaveIniOperations &gt;&gt;&gt; l_Parent
        VAR l_Prefix
        Self .GetUP 'extprop:pas:ElementPrefix' &gt;&gt;&gt; l_Prefix
        Self .Attributes
        .for&gt;
        (
          IN aConst
          VAR l_Name
          [ 'Init_Str_' aConst .Name ] strings:Cat &gt;&gt;&gt; l_Name
          RULES
           (
            l_Parent call.me
            .filter&gt; ( .Name l_Name == )
            .IsEmpty
           ) 
            ( 
             .join&gt; ToArray: ( aConst l_Name aConst .Speller l_Prefix Self .MakeIniStr )
            ) 
         ; // RULES
        ) // .for&gt;
       end // ( l_Speller .IsNotNil )
     ; // RULES
    end // ( Self .IsConstants )
   (
    ( Self .IsTestCase )
    AND ( Self .Abstraction at_abstract != )
    AND ( Self .IsMixIn ! )
   ) 
    ( .join&gt; ToArray: ( Self .RegisterTestCaseMethod ) )
   ( Self .IsTestClass )
    ( .join&gt; ToArray: ( Self .RegisterTestClassMethod ) )
   ( Self .IsTagTable )
    ( .join&gt; ToArray: ( Self .RegisterTagTableMethod ) )
   ( 
    ( Self .IsServiceImplementation ) 
    AND ( l_IniOperations 'bind' .HasModelElementWithName ! )
   ) 
    ( .join&gt; ToArray: ( Self .RegisterServiceImplementationMethod ) )
   ( Self .IsClassOrMixIn )
    (
     VAR l_WasRegisterInEngine
     false &gt;&gt;&gt; l_WasRegisterInEngine
     
     if ( Self .IsMixIn ! ) then
     begin
      if ( Self .Abstraction at_abstract != ) then
      begin
       if ( Self GarantModel::TtfwRegisterableWord .InheritsFromOrSomeAncestorImplements ) then
       begin
        true &gt;&gt;&gt; l_WasRegisterInEngine
        if ( l_IniOperations 'Ini_Reg' .HasModelElementWithName ! ) then
        begin     
         .join&gt; ToArray: ( 
           'Ini_Reg' MakeIniProcedure: (
             IN aMade
            VAR l_TypeName
            Self .TypeName &gt;&gt;&gt; l_TypeName
            aMade -&gt; Parent := ( Self .WeakRef )
            aMade -&gt; "ifndef" := 'NoScripts'
            aMade -&gt; %SUM := ( 'Регистрация ' Self .Name Cat ) 
            aMade -&gt;^ cUserCodePrefix ^:= [ cSpace l_TypeName '.RegisterInEngine;' ]
           ) // MakeIniProcedure:
          ) // .join&gt;
        end // ( l_IniOperations GarantModel::l3UnknownPrim.ClearFields .HasModelElement )
       end // ( l_IniOperations 'Ini_Reg' .HasModelElementWithName ! )
      end // ( Self .Abstraction at_abstract != )
     end // ( Self .IsMixIn ! )
     
     if ( l_WasRegisterInEngine ! ) then
     begin
      if ( Self .NeedRegisterInScripts ) then
      begin
       if ( l_IniOperations 'Ini_Reg_Class' .HasModelElementWithName ! ) then
       begin     
        .join&gt; ToArray: ( 
          'Ini_Reg_Class' MakeIniProcedure: (
            IN aMade
           VAR l_TypeName
           Self .TypeName &gt;&gt;&gt; l_TypeName
           aMade -&gt; Parent := ( Self .WeakRef )
           aMade -&gt; "ifndef" := 'NoScripts'
           aMade -&gt; %SUM := ( 'Регистрация ' Self .Name Cat ) 
           aMade -&gt;^ cUserCodePrefix ^:= [ 
            if ( Self GarantModel::TtfwWord .InheritsFrom ) then
            begin
             ' ' Self .TypeName '.RegisterClass;'
            end
            else
            begin
             ' TtfwClassRef.Register(' Self .TypeName ');' 
            end 
           ] // aMade -&gt;^ cUserCodePrefix
          ) // MakeIniProcedure:
         ) // .join&gt;
       end // ( l_IniOperations 'Ini_Reg_Class' .HasModelElementWithName ! )
      end // ( Self .NeedRegisterInScripts )
     end // ( l_WasRegisterInEngine ! )
     
    ) // ( Self .IsClassOrMixIn )
    
   ( Self .IsEnum ) 
    begin
     if ( Self .NeedRegisterInScripts ) then
     begin
      .join&gt; ToArray: ( Self .RegTypeMethod )
     end // ( Self .NeedRegisterInScripts )
    end // ( Self .IsEnum )
    
   ( Self .IsException ) 
    begin
     if ( Self .NeedRegisterInScripts ) then
     begin
      .join&gt; ToArray: ( Self .RegTypeMethod )
     end // ( Self .NeedRegisterInScripts )
    end // ( Self .IsException )
    
   ( Self .IsInterface ) 
    begin
     if ( Self .NeedRegisterInScripts ) then
     begin
      .join&gt; ToArray: ( Self .RegTypeMethod )
     end // ( Self .NeedRegisterInScripts )
    end // ( Self .IsInterface )
    
   ( Self .IsScriptKeywordsPack )
    begin
     Self .InheritsEx 
     .join&gt; ( Self .ImplementsEx )
     
     .join&gt; ( 
      Self .OperationsEx
      .filter&gt; .IsSomeKeyWord
      .mapToTarget&gt;
     ) // .join&gt;
     
     .joinWithLambded&gt; 
     ( Self .OperationsEx ) ( .Parameters .mapToTarget&gt; )
     
     .filter&gt; .IsAcceptableForScripts
     .map&gt; .RegTypeMethod
     .filter&gt; ( l_IniOperations SWAP .Name .HasModelElementWithName ! )
     .for&gt; (
       IN aMethod
      .join&gt; ToArray: aMethod 
      array:Copy &gt;&gt;&gt; l_IniOperations
      // - перекопируем массив, чтобы убрать дубликаты
      l_IniOperations
      // - кладём его обратно на стек
     ) // .for&gt;
    end // ( Self .IsScriptKeywordsPack )

    ( Self .IsVCMControls )
     begin
      .join&gt; ToArray: (
       'RegisterOperations'
       MakeIniProcedure: (
         IN aMade
        aMade -&gt; Parent := ( Self .WeakRef )
        aMade .AddMethodWithParams: cUserCodePrefix Self (
          IN Self
         [
          Self .ChildrenEx
          .filter&gt; .IsVCMOperations
          .for&gt; (
            IN anEntity
           anEntity .OperationsEx
           .filter&gt; .IsVCMOperation
           .for&gt; (
             IN anOperation
            HookOut: (
             Indented: (
              [
               'with '
               'TvcmOperationsForRegister.AddOperation('
               'TvcmOperationForRegister_C('
               'en_' anEntity .Name ', '
               'op_' anOperation .Name ', '
               'en_cap' anEntity .Name ', '
               'op_cap' anOperation .Name ', '
               anOperation .IsInternalOperation ', '
               anOperation .UPisTrue "no prefix" ', '
               [ 'opcode_' anEntity .Name '_' anOperation .Name ]
               ')'
               ')'
               ' do' \n
               'begin' \n
               if ( anOperation .GetUP "ImageIndex" .IsIntEx ) then
               begin
                ' SetImageIndex(' anOperation .GetUP "ImageIndex" ')' ';' \n
               end // ( anOperation .GetUP "ImageIndex" .IsIntEx )

               anOperation .ChildrenEx
               .filter&gt; .IsVCMOperationState
               .for&gt; (
                 IN aState
                HookOut: (
                 aState .IfDef: (
                  [
                   'with '
                   'AddState('
                   'TvcmOperationStateForRegister_C('
                   cQuote aState .Name cQuote ', '
                   [ 'st_user_' anEntity .Name '_' anOperation .Name '_' aState .Name ]
                   ')'
                   ')'
                   '^'
                   ' do' \n
                   'begin' \n
                     if ( aState .Documentation .NotIsNil ) then
                     begin
                      ' rCaption := ' cQuote aState .Documentation cQuote ';' \n
                     end // ( aState .Documentation .NotIsNil )
                     if ( aState .GetUP "Hint" .NotIsNil ) then
                     begin
                      ' rHint := ' cQuote aState .GetUP "Hint" cQuote ';' \n
                     end // ( aState .GetUP "Hint" .NotIsNil )
                     if ( aState .GetUP "ImageIndex" .IsIntEx ) then
                     begin
                      ' rImageIndex := ' aState .GetUP "ImageIndex" ';' \n
                     end // ( aState .GetUP "ImageIndex" .IsIntEx )
                     if ( aState .GetUP "Enabled" IsBool ) then
                     begin
                      ' rEnabled := ' 'vcm_osf' aState .GetUP "Enabled" ';' \n
                     end // ( aState .GetUP "Enabled" IsBool )
                     if ( aState .GetUP "Visible" IsBool ) then
                     begin
                      ' rVisible := ' 'vcm_osf' aState .GetUP "Visible" ';' \n
                     end // ( aState .GetUP "Visible" IsBool )
                     if ( aState .GetUP "Checked" IsBool ) then
                     begin
                      ' rChecked := ' 'vcm_osf' aState .GetUP "Checked" ';' \n
                     end // ( aState .GetUP "Checked" IsBool )
                   'end'
                   ';'
                  ] .Out
                 ) // aState .IfDef:
                ) // HookOut:
               ) // .for&gt;

               'end'
               ';'
              ] .Out
             ) // Indented:
            ) // HookOut:
           ) // .for&gt;
          ) // .for&gt;
         ]
        ) // aMade .AddMethodWithParams: cUserCodePrefix Self
       ) // MakeIniProcedure:
      ) // .join&gt; ToArray:
     end // ( Self .IsVCMControls )
  ; // RULES

  RULES
   ( Self .IsVCMFormsPack )
    begin
     if ( Self .Abstraction at_final == ) then
     begin
      .join&gt; ToArray: (
       'RegisterModule'
       MakeIniProcedure: (
         IN aMade
        aMade -&gt; Parent := ( Self .WeakRef )
        aMade .AddMethodWithParams: cUserCodePrefix Self (
          IN Self
         [
          VAR l_ModuleTypeName
          Self .TypeName &gt;&gt;&gt; l_ModuleTypeName
          VAR l_ModuleName
          Self .Name &gt;&gt;&gt; l_ModuleName

          ' '
          'TvcmModulesForRegister.AddModule('
          'TvcmModuleForRegister_C('
          l_ModuleTypeName ', '
          cQuote Self .Documentation cQuote
          ')'
          ')'
          ';'

          elem: RegisterModuleOperations
           Self .OperationsEx
           .filter&gt; .IsModuleOperationPrim
           .for&gt; (
             IN anOp
            \n
            ' ' 
            'TvcmModuleOperationsForRegister.AddOperation('
            'TvcmModuleOperationForRegister_C('
            l_ModuleTypeName ', '
            cQuote anOp .Name cQuote  ', '
            cQuote anOp .Documentation cQuote ', '
            anOp .UPisTrue "no prefix" ', '
            'g_module_opcode_' l_ModuleName '_' anOp .Name
            ')'
            ')'
            ';'
           ) // .for&gt;
           Self .InheritsEx .for&gt; call.me
          ; // RegisterModuleOperations

          Self .RegisterModuleOperations
         ]
        ) // aMade .AddMethodWithParams: cUserCodePrefix Self
       ) // MakeIniProcedure:
      ) // .join&gt; ToArray:
     end // ( Self .Abstraction at_final == )
    end // ( Self .IsVCMFormsPack )
  ; // RULES
  
  if ( Self .IsClassOrMixIn ) then
  begin
   Self .InheritsEx
   .join&gt; ( Self .ImplementsEx )
   .filter&gt; .IsMixIn 
   .for&gt; (
     IN aMixIn
    VAR l_HasIni
    false &gt;&gt;&gt; l_HasIni
    //aMixIn call.me .NotEmpty &gt;&gt;&gt; l_HasIni
    if ( l_HasIni ! ) then
    begin
     aMixIn .ForChildren&gt; .All ( 
       IN aChild
      if ( aChild call.me .NotEmpty ) then
      begin
       true &gt;&gt;&gt; l_HasIni
      end // ( aChild call.me .NotEmpty )
     ) // aMixIn .ForChildren&gt; .All
    end // ( l_HasIni ! )
    if l_HasIni then
    begin
     .join&gt; ToArray: ( 
      aMixIn .Name '_Include' Cat MakeIniProcedure: (
        IN aMade
       aMade .AddMethodWithParams: cUserCodePrefix aMixIn (
         IN aMixIn
        [ 
          HookOut: ( 
           aMixIn .OutMixInInclude 
          ) // HookOut:
        ]
       ) // aMade .AddMethodWithParams: cUserCodePrefix aMixIn
      ) // aMixIn .Name 'Include' Cat MakeIniProcedure:
     ) // .join&gt; ToArray:
    end // l_HasIni
   ) // .for&gt;
  end // ( Self .IsClassOrMixIn )
 ) 
 &gt;&gt;&gt; Result
; // IniOperations

elem_iterator FiniOperations
 Self .OperationsEx
 .filter&gt; .IsFini
 &gt;&gt;&gt; Result
; // FiniOperations

ARRAY CompileTime-VAR g_DeferredInitialization nil

elem_proc OutIniFiniSection

 : OutInitialization
  if ( g_DeferredInitialization .IsNil ) then
  begin
   'initialization' .Out
  end // ( g_DeferredInitialization .IsNil )
  else
  begin
   g_DeferredInitialization .Out
   nil &gt;&gt;&gt; g_DeferredInitialization
  end // ( g_DeferredInitialization .IsNil )
 ; // OutInitialization
 
 VAR l_WasOut
 false &gt;&gt;&gt; l_WasOut
 VAR l_WasInitialization
 false &gt;&gt;&gt; l_WasInitialization
 Self .ForChildren&gt; .All (
  .IniOperations .for&gt; (
    IN anIni
   if ( l_WasOut ! ) then
   begin
    true &gt;&gt;&gt; l_WasOut
    true &gt;&gt;&gt; l_WasInitialization
    OutInitialization
   end // ( l_WasOut ! )
   Self .IfDef: ( 
    anIni .OutIniOrFini
   ) // Self .IfDef:
  ) // .IniOperations .for&gt;
 ) // Self .ForChildren&gt; .All
 l_WasOut ? OutLn
 
 false &gt;&gt;&gt; l_WasOut
 Self .ForChildren&gt; .All (
  .FiniOperations .for&gt; (
   if ( l_WasOut ! ) then
   begin
    true &gt;&gt;&gt; l_WasOut
    if ( l_WasInitialization ! ) then
    begin
     true &gt;&gt;&gt; l_WasInitialization
     OutInitialization
     OutLn
    end // ( l_WasInitialization ! )
    'finalization' .Out
   end // ( l_WasOut ! )
   .OutIniOrFini
  ) // .FiniOperations .for&gt;
 ) // Self .ForChildren&gt; .All
 l_WasOut ? OutLn
; // OutIniFiniSection

elem_proc OutImplementationSection
 Self .OutDefinitionsSection: .IsForImplementation
 
 VAR l_WasOut
 false &gt;&gt;&gt; l_WasOut
 Self .ForChildren&gt; .IsForImplementation (
  .GlobalVars 
  .filter&gt; ( .Visibility PrivateAccess != ) 
  .for&gt; ( .OutVar true &gt;&gt;&gt; l_WasOut )
 ) 
 Self .ForChildren&gt; .All (
  .GlobalVars 
  .filter&gt; ( .Visibility PrivateAccess == ) 
  .for&gt; ( .OutVar true &gt;&gt;&gt; l_WasOut )
 ) 
 
 l_WasOut ? OutLn
 
 VAR l_WasConst
 
 false &gt;&gt;&gt; l_WasConst
 Self .ForChildren&gt; .All (
  .ConstantsEx .filter&gt; ( .ConstantsListVisibility PrivateAccess == ) if .OutConstantsList ( true &gt;&gt;&gt; l_WasConst )
 )
 if l_WasConst then
  OutLn
  
 Self .ForChildren&gt; .IsForImplementation (
   IN anItem
  VAR l_GlobalOperations
  anItem .GlobalOperations &gt;&gt;&gt; l_GlobalOperations
  VAR l_GlobalOperationsForOverload
  anItem .GlobalOperationsForOverload &gt;&gt;&gt; l_GlobalOperationsForOverload
  l_GlobalOperations 
  .for&gt; .MethodInterfaceForEx: l_GlobalOperationsForOverload .MethodBody
 )
 
 TF g_EnableMethodDirectives (
  false &gt;&gt;&gt; g_EnableMethodDirectives
  Self .ForChildren&gt; .IsForInterface (
    IN anItem
   VAR l_GlobalOperations
   anItem .GlobalOperations &gt;&gt;&gt; l_GlobalOperations
   VAR l_GlobalOperationsForOverload
   anItem .GlobalOperationsForOverload &gt;&gt;&gt; l_GlobalOperationsForOverload
   
   l_GlobalOperations 
   .filter&gt; ( .Visibility PrivateAccess == )
   .for&gt; .MethodInterfaceForEx: l_GlobalOperationsForOverload .MethodBody
   
   l_GlobalOperations 
   .filter&gt; ( .Visibility PrivateAccess != )
   .for&gt; .MethodInterfaceForEx: nil .MethodBody
  )
 ) // TF g_EnableMethodDirectives
 
 Self .ForChildren&gt; .All .OutImplementation
 
 Self .OutIniFiniSection
 
; // OutImplementationSection

STRING elem_func Defines
 Self .GetUP "defines" &gt;&gt;&gt; Result
 if ( Result .IsNil ) then
 begin
  VAR l_Parent
  Self .Parent &gt;&gt;&gt; l_Parent
  if ( l_Parent .IsNotNil ) then
  begin
   l_Parent call.me &gt;&gt;&gt; Result
  end // ( l_Parent .IsNotNil )
 end // ( Result .IsNil )
 else
 begin
  Self .PathOnly Result Cat &gt;&gt;&gt; Result
 end // ( Result .IsNil )
; // Defines

elem_proc OutUnitHeader
 [ '// Модуль: "' Self .FinalFileName '"' ] .Out
 [ '// Стереотип: "' Self .Stereotype .Name '"' ] .Out
 if ( Self .Name .IsNotNil ) then
 begin
  [ 
   '// Элемент модели: "' Self .Name '"' 
   if ( Self .UID .IsNotNil ) then
   begin
    ' MUID: (' Self .UID ')'
   end // ( Self .UID .IsNotNil )
  ] .Out
  if ( Self .TypeName .IsNotNil ) then
  begin
   if ( Self .Name Self .TypeName ?!= ) then
   begin
    [ '// Имя типа: "' Self .TypeName '"' ] .Out
   end // ( Self .Name Self .TypeName ?!= )
  end // ( Self .TypeName .IsNotNil ) 
 end // ( Self .Name .IsNotNil )
 OutLn
; // OutUnitHeader

PROCEDURE DoOutUnit
 ^ IN aLambda
 TF g_Implementor (
  nil &gt;&gt;&gt; g_Implementor
  TF g_WasTypeOpener (
   nil &gt;&gt;&gt; g_WasTypeOpener
   TF g_WasConst (
    false &gt;&gt;&gt; g_WasConst
    TF g_WasForwarded (
     false &gt;&gt;&gt; g_WasForwarded
     TF g_WasType (
      DropWasType
      TF g_MixInValues (
       [] &gt;&gt;&gt; g_MixInValues
       TF g_OutedTypes (
        [] &gt;&gt;&gt; g_OutedTypes
        TF g_ForwardedTypes (
         [] &gt;&gt;&gt; g_ForwardedTypes
         aLambda DO
        ) // TF g_ForwardedTypes
       ) // TF g_OutedTypes 
      ) // TF g_MixInValues
     ) // TF g_WasType
    ) // TF g_WasForwarded
   ) // TF g_WasConst
  ) // TF g_WasTypeOpener
 ) // TF g_Implementor
; // DoOutUnit

elem_proc OutApplicationBody
 RULES
  ( Self .IsTestTarget )
   begin
    [
     ' {$IfDef nsTest}' \n
     ' g_CVSPath := ' 
     cQuote 
     Self .FinalFileName sysutils:ExtractFilePath '\' .CutSuffix
     cQuote ';' \n
     ' {$EndIf nsTest}'
    ] .Out
    Indented: ( Self .UserCode: 'CVSPath' () )
    
    RULES
     ( Self .UPisTrue "need UC in project" )
      begin
       Indented: ( Self .UserCode: 'manualcode' () )
      end // ( Self .UPisTrue "need UC in project" )
     ( Self .IsVCMTestTarget )
      begin
       RULES
        (
         Self .DependsVCMGUI
         .filter&gt; ( .GetUP "F1Like" false ?== )
         .IsEmpty
        )
         ( ' TF1AutoTestSuite.Register;' .Out )
        DEFAULT
         ( ' TAutoTestsSuite.Register;' .Out )
       ; // RULES 
       
       Self .DependsVCMGUI
       .for&gt; (
         IN anItem
        anItem call.me 
       ) // .for&gt;
      end // ( Self .IsVCMTestTarget )
     DEFAULT
      begin
       if ( Self .UPisTrue "no scripts" ! ) then
       begin
        ' TAutoTestsSuite.Register;' .Out
       end // ( Self .UPisTrue "no scripts" ! )

       ' try' .Out
       [
       '  if KTestRunner.NeedKTestRunner(['
       
       VAR l_WasComma
       false &gt;&gt;&gt; l_WasComma
       
       Self .ChildrenEx
       .filter&gt; .IsTestResults
       .map&gt; .TypeName
       .for&gt; ( .WithComma: l_WasComma .KeepInStack )
       
       ']) then'
       ] .Out
       '   KTestRunner.RunRegisteredTests' .Out
       '  else' .Out
       '  if System.IsConsole then' .Out
       '   TextTestRunner.RunRegisteredTests' .Out
       '  else' .Out
       '   GUITestRunner.RunRegisteredTests;' .Out
       ' except' .Out
       '  on E: Exception do' .Out
       '  begin' .Out
       '   {$If defined(MTDORB) AND defined(NoKPageTool)}' .Out
       '   if TKBridge.Exists then' .Out
       '    TKBridge.Instance.Logout;' .Out
       '   {$IfEnd}' .Out
       '   l3System.Exception2Log(E);' .Out
       '   Halt(2);' .Out
       '  end;//Exception' .Out
       ' end;//try..except' .Out
       ' if (TestsExitCode &lt;&gt; 0) then' .Out
       '  Halt(TestsExitCode);' .Out
      end // DEFAULT
    ; // RULES  
    
   end // ( Self .IsTestTarget )
  ( Self .IsVCMGUI )
   begin
    [
     ' ' 'StdRes.TvcmApplicationRunner.Run(str_' Self .Name 'Title' ',' ' ' 
     cQuote Self .GetUP "HelpFile" '.chm' cQuote 
     ');'
    ] .Out 
   end // ( Self .IsVCMGUI )
  DEFAULT
   begin
    Indented: ( Self .UserCode: 'manualcode' () )
   end // DEFAULT
 ; // RULES
; // OutApplicationBody

STRING elem_func ProjectUnitPath
 Cached:
 (
  VAR l_Path
  RULES
   ( Self IsString )
    RULES
     ( Self GarantModel::StdRes .Name == )
      ( GarantModel::StdRes .Name '.pas' Cat )
     DEFAULT
      '' 
    ; // RULES
   ( Self .Name GarantModel::StdRes .Name == )
    ( GarantModel::StdRes .Name '.pas' Cat )
   ( Self .InTie )
    // - тут надо брать путь для адаптера
    ( 
     VAR l_pasPath
     Self .GetUP 'pas:Path' &gt;&gt;&gt; l_pasPath
     RULES
      ( l_pasPath .IsNil )
       ''
      DEFAULT 
       ( [ cRoot l_pasPath ] cPathSep strings:CatSep )
     ; // RULES  
    )   
   ( Self .UnitName 'GblAdapter' == )
    ''  
   DEFAULT
    ( Self .FinalFileName )
  ; // RULES
  &gt;&gt;&gt; l_Path
  
  if ( l_Path .IsNotNil ) then
  begin
   if ( l_Path 'NotFinished\Borland\Delphi\Rtl\Sys' string:Pos -1 != ) then
   begin
    '' &gt;&gt;&gt; l_Path
   end // ( l_Path 'NotFinished\Borland\Delphi\Rtl\Sys' string:Pos -1 != )
  end // ( l_Path .IsNotNil )
  
  if ( l_Path .IsNotNil ) then
  begin
   l_Path cNotFinished '' string:Replace &gt;&gt;&gt; l_Path
   l_Path cNotCompleted '' string:Replace &gt;&gt;&gt; l_Path
   l_Path 'NotFinished\' '' string:Replace &gt;&gt;&gt; l_Path
  end // ( l_Path .IsNotNil )
  l_Path 
 ) 
 &gt;&gt;&gt; Result
; // ProjectUnitPath

STRING elem_func ProjectUnitName
 Self .UnitName
 
 VAR l_Path
 Self .ProjectUnitPath &gt;&gt;&gt; l_Path
 
 if ( l_Path .IsNotNil ) then
 begin
  [ ' in ' cQuote l_Path cQuote ] strings:Cat Cat
 end // ( l_Path .IsNotNil )
 
 &gt;&gt;&gt; Result
; // ProjectUnitName

elem_proc OutUnit
 DoOutUnit (
  TF g_DefaultInterfaceAncestor (
  
   Self .ChildrenEx .filter&gt; ( .UPisTrue "is default ancestor" ) .FirstElement &gt;&gt;&gt; g_DefaultInterfaceAncestor
   
   [ 
    RULES
     ( Self .IsDLL )
      'library'
     ( Self .IsExe )
      'program'
     DEFAULT
      'unit' 
    ; // RULES  
    cSpace
    Self .UnitNamePrim ';' 
   ] .Out
   Self .OutDocumentation
   OutLn
   
   Self .OutUnitHeader
   
   VAR l_Defines
   Self .Defines &gt;&gt;&gt; l_Defines
   if ( l_Defines .IsNotNil ) then
   begin
    [ cOpenComment '$Include ' l_Defines cCloseComment ] .Out
    OutLn
   end // ( l_Defines .IsNotNil )
   
   if ( Self .IsExe ) then
   begin
    if ( Self .UPisTrue "console" ) then
    begin
     '{$APPTYPE CONSOLE}' .Out
     OutLn
    end // ( Self .UPisTrue "console" )
   end // ( Self .IsExe )
   
   if ( Self .IsTarget ! ) then
   begin
    'interface' .Out
    OutLn
   end // ( Self .IsTarget ! )
   
   ARRAY VAR l_Used
   [] &gt;&gt;&gt; l_Used
   
   Self .IfDef: ( 
    if ( Self .IsTarget ) then
    begin
     Self 'intf_uses' .OutUses: l_Used ( Self .ProjectUses ) .ProjectUnitName
    end // ( Self .IsTarget )
    else
    begin
     Self 'intf_uses' .OutUses: l_Used ( Self .IntfUses ) .UnitName
    end // ( Self .IsTarget )
   
    Self .OutInterfaceSection
    
    if ( Self .IsElementProxy ) then
    begin
     Self .UserCode: 'intf_code' ()
     OutLn
    end // ( Self .IsElementProxy )
   ) // Self .IfDef:
   
   if ( Self .IsTarget ! ) then
   begin
    'implementation' .Out
    OutLn
   end // ( Self .IsTarget ! )
   
   Self .IfDef: ( 
    if ( Self .IsTarget ! ) then
    begin
     Self 'impl_uses' .OutUses: l_Used ( Self .ImplUses ) .UnitName
    end // ( Self .IsTarget ! )
    
    RULES
     ( Self .IsTestClass )
      ( 
       Self .MainAncestor .IfDef: 
       ( 
        Self .OutImplementationSection 
       ) // Self .MainAncestor .IfDef:
      ) // ( Self .IsTestClass )
     ( Self .IsSimpleClass )
      ( 
       //Self .MainAncestor .IfDef:
       Self .MainAncestorThatNotMixIn .IfDef:
       (
        Self .OutImplementationSection 
       ) // Self .MainAncestor .IfDef:
      ) // ( Self .IsSimpleClass )
     DEFAULT
      ( Self .OutImplementationSection )
    ; // RULES   
    
    RULES
     ( Self .IsElementProxy )
      (
       Self .UserCode: 'impl_code' ()
       OutLn
      )
     ( Self .IsDLL )
      (
       'exports' .Out
       Self .UserCode: 'exports' ( )
       ';' .Out
       OutLn
      )
    ; // RULES
   ) // Self .IfDef:
   
   RULES
    ( Self .IsExe )
     (
      if ( Self .UPisTrue "console" ! ) then
      begin
       [ '{$R ' Self .UnitName '.res' '}' ] .Out
       if ( Self .UPisTrue "needs second icon" ) then
       begin
        [ '{$R main_icon2.res}' ' // вторая иконка приложения' ] .Out
       end // ( Self .UPisTrue "needs second icon" )
       OutLn
      end // ( Self .UPisTrue "console" ! )
      
      if ( Self .UPisTrue "need UC in project" ) then
      begin
       Self .UserCode: 'manualres' ()
       OutLn
      end // ( Self .UPisTrue "need UC in project" )
      
      'begin' .Out
      Self .OutApplicationBody
     ) // ( Self .IsExe )
    ( Self .IsDLL ) 
     (
      [ '{$R ' Self .UnitName '.res' '}' ] .Out
      OutLn
      'begin' .Out
     ) // ( Self .IsDLL )
   ; // RULES
   
   'end.' .Out
  ) // TF g_DefaultInterfaceAncestor 
 ) // DoOutUnit
; // OutUnit

STRING elem_func DefineName
 Cached:
 (
  Self .UnitName cDot cUnderline string:Replace
 ) 
 &gt;&gt;&gt; Result
; // DefineName

elem_proc OutMixIn
 DoOutUnit (
  VAR l_DefineName
  Self .DefineName &gt;&gt;&gt; l_DefineName
  
  [ cOpenComment '$IfNDef ' l_DefineName cCloseComment \n ] .Out
  
  Self .OutUnitHeader
  
  [ cOpenComment '$Define ' l_DefineName cCloseComment \n ] .Out
  
  Self .IfDefElse: 
  ( 
   Self .OutInterfaceSection
  ) 
  (
   VAR l_Parent
   Self .CalcParentAndInclude &gt;&gt;&gt; l_Parent
   [ Self .TypeName ' = ' l_Parent .TypeName ';' \n ] .Out
  )
  // Self .IfDefElse:
  
  [ cOpenComment '$Else ' l_DefineName cCloseComment \n ] .Out
  
  VAR l_DefineNameImpl
  [ l_DefineName '_impl' ] &gt;&gt;&gt; l_DefineNameImpl
  
  [ cOpenComment '$IfNDef ' l_DefineNameImpl cCloseComment \n ] .Out
  
  [ cOpenComment '$Define ' l_DefineNameImpl cCloseComment \n ] .Out
  
  TF g_DeferredInitialization (
   [ cOpenComment '$Else ' l_DefineNameImpl cCloseComment \n ] &gt;&gt;&gt; g_DeferredInitialization
   
   Self .IfDef: ( 
    Self .OutImplementationSection
   ) // Self .IfDef:
  )
  
  [ cOpenComment '$EndIf ' l_DefineNameImpl cCloseComment \n ] .Out
  
  [ cOpenComment '$EndIf ' l_DefineName cCloseComment \n ] .Out
 ) // DoOutUnit
; // OutMixIn

STRING elem_func PasFinalFileName
 Self .GetUP 'intf.pas:Path' &gt;&gt;&gt; Result
 if ( Result .IsNil ) then
 begin
  RULES
   ( Self .IsTestLibrary )
    begin
     Self .PasPathOnly &gt;&gt;&gt; Result
     if ( Result .IsNotNil ) then
     begin
      [ 
       Result 
       [ Self .Name cSpace cUnderline string:Replace '_TestLibrary' '.pas' ] strings:Cat 
      ] cPathSep strings:CatSep &gt;&gt;&gt; Result
     end // ( Result .IsNotNil )
    end // ( Self .IsTestLibrary )
   ( Self .IsTestUnit )
    begin
     Self .PasPathOnly &gt;&gt;&gt; Result
     if ( Result .IsNotNil ) then
     begin
      [ Result 
       [ 
        [ Self .Parent .Name cUnderline Self .Name ] strings:Cat
        cSpace cUnderline string:Replace
        cDot cUnderline string:Replace
        '_TestUnit' '.pas' 
       ] strings:Cat 
      ] cPathSep strings:CatSep &gt;&gt;&gt; Result
     end // ( Result .IsNotNil )
    end // ( Self .IsTestUnit )
   ( Self .IsElementProxy )
    begin
     Self .PasPathOnly &gt;&gt;&gt; Result
     if ( Result .IsNotNil ) then
     begin
      [ 
       Result 
       [ Self .Name cProxy '.pas' ] strings:Cat 
      ] cPathSep strings:CatSep &gt;&gt;&gt; Result
     end // ( Result .IsNotNil )
    end // ( Self .IsElementProxy )
   ( Self .IsScriptKeywordsPack ) 
    begin
     Self .PasPathOnly &gt;&gt;&gt; Result
     if ( Result .IsNotNil ) then
     begin
      [ 
       Result
       [ Self .Name '.pas' ] strings:Cat
      ] cPathSep strings:CatSep &gt;&gt;&gt; Result
     end // ( Result .IsNotNil )
    end // ( Self .IsScriptKeywordsPack )
  ; // RULES
 end // ( Result .IsNil )
; // PasFinalFileName

elem_generator pas
 
 CONST Ext '.pas'

 BOOLEAN elem_func CanCopyToFinalFile
  RULES
   ( Self .UseNewGen )
    true
   DEFAULT
    false 
  ; // RULES
  &gt;&gt;&gt; Result
 ; // CanCopyToFinalFile
 
 STRING elem_func FinalFileNamePrim
  Self .PasFinalFileName &gt;&gt;&gt; Result 
 ; // FinalFileNamePrim
 
 RULES
  ( Self .IsMixIn )
   ( Self .OutMixIn )
  ( Self .IsUserType ) 
   ( Self .OutUnit )
  ( Self .IsInterfaces )
   ( Self .OutUnit )
  ( Self .IsEvdSchemaElement )
   ( Self .OutUnit )
  ( Self .IsSimpleClass )
   ( Self .OutUnit )
  ( Self .IsElementProxy )
   ( Self .OutUnit )
  ( Self .IsUtilityPack )
   ( Self .OutUnit )
  ( Self .IsTestClass ) 
   ( Self .OutUnit )
  ( Self .IsTarget ) 
   ( Self .OutUnit )
  ( Self .IsTagTable ) 
   ( Self .OutUnit )
  ( Self .IsTestLibrary ) 
   ( Self .OutUnit )
  ( Self .IsTestUnit ) 
   ( Self .OutUnit )
  DEFAULT
   ( Self .Name .Out )
 ; // RULES
; // pas

elem_generator pas_dependent
 
 Inherits .pas
 
 STRING elem_func FinalFileNamePrim
  Self .PasFinalFileName &gt;&gt;&gt; Result 
  if ( Result .IsNotNil ) then
  begin
   Result .? Ext sysutils:ChangeFileExt &gt;&gt;&gt; Result
  end // ( Result .IsNotNil )
 ; // FinalFileNamePrim
 
; // pas_dependent

ARRAY CompileTime-VAR g_FormControls nil

elem_proc ToDFM
//	&lt;%C#f_ToDFM()&gt;\
//	&lt;%G#f_ToDFM()&gt;\
//      &lt;%R#f_ToDFM()&gt;

//	[{%S%f_NeedPutToDFM()=true}\
//	[{%f_exists_in_list(FORM_CONTROLS,"%S%f_pas_AttrName()")=false}\
//	%f_add_to_list(FORM_CONTROLS,"%S%f_pas_AttrName()")\
//	\n# object %S%f_pas_AttrName(): %S%f_pas_ResultTypeName()\
//	[{"%SD"!=""&%S{need Caption}!=false}\n#  Caption = '%SD']\
//	&lt;%C#f_ToDFM()&gt;\
//	[{%S%f_IsOverride()=true}\
//	&lt;{}{}{r}%g&lt;%C#f_ToDFM()&gt;&gt;\
//	]
//	# end\
//	]\
//      ]

 RULES
  ( Self .IsVCMCustomForm )
   (
    Self .Attributes .for&gt; call.me
    Self .InheritsEx .for&gt; call.me
    Self .ImplementsEx .for&gt; call.me
   )
  ( Self .IsControlPrim )
   (
    if ( Self .NeedPutToDFM ) then
    begin
     if ( Self .AttrName .TextNotInArray: g_FormControls ) then
     begin
      Self .AttrName .AddToArray: g_FormControls
      Indented: (
       [ ' object ' Self .AttrName ': ' Self .AttrType .TypeName ] .Out
       Self .Attributes .for&gt; call.me
       
       if ( Self .IsOverride ) then
       begin
        Self .InheritsEx .for&gt; ( .Attributes .for&gt; call.me )
       end // ( Self .IsOverride )
       
       [ ' end' ] .Out
      ) // Indented:
     end // ( Self .AttrName .TextNotInArray: g_FormControls )
    end // ( Self .NeedPutToDFM )
   ) 
 ; // RULES

; // ToDFM

elem_proc BeforeDFMControls
 RULES
  ( Self .IsVCMForm )
   (
    [ '  Caption = ' cQuote Self .Documentation cQuote ] .Out
    [ '  Color = $00F9F8FA' ] .Out
    
    VAR l_ZoneType
    Self .GetUP "ZoneType" &gt;&gt;&gt; l_ZoneType
    if ( l_ZoneType .IsNotNil ) then
     if ( l_ZoneType 'Any' != ) then
     begin
      [ '  ZoneType = vcm_zt' l_ZoneType ] .Out
     end // ( l_ZoneType 'Any' != )
     
    [ '  PixelsPerInch = 96' ] .Out
    [ '  TextHeight = 13' ] .Out
    [ '  object Entities: TvcmEntities' ] .Out
    [ '    Left = 24' ] .Out
    [ '    Top = 24' ] .Out
    [ '  end' ] .Out
   )
 ; // RULES  
; // BeforeDFMControls

elem_generator dfm
 
 Inherits .pas_dependent

 CONST Ext '.dfm'

 BOOLEAN elem_func NeedOwnFilePrim
  Self .IsVCMCustomForm
  AND ( Self .Abstraction at_final == )
  &gt;&gt;&gt; Result 
 ; // NeedOwnFilePrim
 
 BOOLEAN elem_func CanCopyToFinalFile
  Self .GetUP "finished dfm" false ?!= &gt;&gt;&gt; Result
 ; // CanCopyToFinalFile
 
 TF g_FormControls (
  [] &gt;&gt;&gt; g_FormControls
  [ 'object ' Self .TypeName .CutT ': ' Self .TypeName ] .Out
  [ '  Left = 204' ] .Out
  [ '  Top = 118' ] .Out
  [ '  Width = 320' ] .Out
  [ '  Height = 240' ] .Out
  Self .BeforeDFMControls
  Self .ToDFM
  [ 'end' ] .Out
 ) // TF g_FormControls
 
; // dfm
 
elem_generator res.cmd
 
 Inherits .pas_dependent

 CONST Ext '.res.cmd'
 
 BOOLEAN elem_func NeedOwnFilePrim
  Self .NeedsScript &gt;&gt;&gt; Result 
 ; // NeedOwnFilePrim
  
 BOOLEAN elem_func CanCopyToFinalFile
  true &gt;&gt;&gt; Result
 ; // CanCopyToFinalFile
 
 VAR l_Name
 WithGen: .pas ( Self .EffectiveUnitName &gt;&gt;&gt; l_Name )
 [ 'MakeCo ' l_Name '.rc.script' ] .Out
 [ 'brcc32 ' l_Name '.rc' ] .Out
 //call.inherited
; // res.cmd

BOOLEAN elem_func NeedsWordsAliases
 Cached:
 (
  RULES
   ( Self .IsScriptKeywordsPack ! )
    false
   ( Self .UPisTrue "no class name" )
    true
   ( Self .UPisTrue "no_pop" ) 
    true
   DEFAULT
    false 
  ; // RULES
 ) 
 &gt;&gt;&gt; Result
; // NeedsWordsAliases

elem_generator rc.script
 
 Inherits .res.cmd

 CONST Ext '.rc.script'

 BOOLEAN elem_func CanCopyToFinalFile
  /*{
  RULES
   ( Self .NeedsWordsAliases ! )
    true
   DEFAULT
    false
  ; // RULES
  }*/
  true &gt;&gt;&gt; Result
 ; // CanCopyToFinalFile
 
 Self .OutUnitHeader
 
 VAR l_WasManUses
 false &gt;&gt;&gt; l_WasManUses
 
 : OutManUses
  l_WasManUses ! ? (
   true &gt;&gt;&gt; l_WasManUses
   OutLn
   Self .UserCode: 'man_uses' () 
   OutLn
  ) // l_WasManUses ! ? 
 ; // OutManUses
 
 Self .NeedsWordsAliases ?
  OutManUses
  
 : OutScriptFrameWorkAliases
 
  : OutWordAlias
    IN aG
    
   if ( 
       ( Self .UPisTrue "no class name" ! ) 
       AND ( aG .SelfName 'SV' != )
      ) then
   begin
    'USES' .Out
    [ cSpace 'axiom:' aG .SelfName ] .Out
    ';' .Out
    OutLn
   end // ( Self .UPisTrue "no class name" ! )
   
   [ '// Класс ' aG .Name ' - ' aG .SelfName ] .Out 
   
   Self .OperationsEx
   .filter&gt; .IsKeyWord
   .for&gt; (
     IN anOp
    VAR l_NameForScript 
    anOp .NameForScript &gt;&gt;&gt; l_NameForScript
    [ 
      '//  Операция ' anOp .Name 
      if ( l_NameForScript .IsNotNil ) then
      begin
       ' - ' l_NameForScript
      end // ( l_NameForScript .IsNotNil )
    ] .Out
    
    if ( anOp .Speller .NotIsNil ) then
    begin
     anOp .Speller .NameForScript &gt;&gt;&gt; l_NameForScript
     [
      '//  Класс реализующий операцию '
      anOp .Speller .Name
      ' - '
      l_NameForScript
     ] .Out
     
     if ( anOp .IsCreator ! ) then
     begin
      VAR l_CanonicName
      [ 
       'pop:' 
       aG .SelfName
       ':' 
       anOp .Name 
        'pop_' .CutPrefix
        [ aG .SelfName string:Lower cUnderline ] strings:Cat .CutPrefix
        cUnderline ':' string:Replace
      ] strings:Cat &gt;&gt;&gt; l_CanonicName
      
      if ( l_CanonicName l_NameForScript != ) then
      begin
       [ 'WordAlias ' l_CanonicName cSpace l_NameForScript ] .Out
      end // ( l_CanonicName l_NameForScript != )
     end // ( anOp .IsCreator ! )
    end // ( anOp .Speller .NotIsNil )
    
   ) // Self .OperationsEx
   
   OutLn
   
  ; // OutWordAlias
  
  if ( Self .NeedsWordsAliases ) then
  begin
   Self .InheritsEx
   .join&gt; ( Self .ImplementsEx )
   .filter&gt; .IsAcceptableForScripts
   //.filter&gt; ( DROP Self .NeedsWordsAliases /* Тут надо ещё проверку на SV */ )
   .for&gt; OutWordAlias
  end // ( Self .NeedsWordsAliases )
  
 ; // OutScriptFrameWorkAliases 
  
 Self .IsScriptKeywordsPack ?
  OutScriptFrameWorkAliases
 
 Self .UserCode: 'impl' ()
 OutLn
 'EXPORTS' .Out
 Self .UserCode: 'exports' ( ' *' )
 OutLn
; // rc.script
 
elem_generator rc
 
 Inherits .res.cmd

 CONST Ext '.rc'
 
 Self .OutUnitHeader
 
 VAR l_Name
 WithGen: .pas ( Self .EffectiveUnitName &gt;&gt;&gt; l_Name )
 [ l_Name ' RCDATA LOADONCALL MOVEABLE DISCARDABLE ' l_Name '.rc.script.co' ] .Out
 //call.inherited
; // rc

ARRAY CompileTime-VAR g_GeneratedElements []
%REMARK 'Ранее сгенерированные элементы'

elem_proc GenerateWithChildren
 Sequence IN aGenerators
 
 if ( Self .NotInArray: g_GeneratedElements ) then
 begin
  Self .AddToArray: g_GeneratedElements
  aGenerators CodeIterator .for&gt; (
  // - цикл по генераторам для Self
   TtfwWord IN aGenerator
   TF g_CurrentGenerator (
    aGenerator &gt;&gt;&gt; g_CurrentGenerator
    if ( Self .NeedOwnFile ) then
    begin
     VAR l_Name
     Self .Name &gt;&gt;&gt; l_Name
     [ l_Name ' ' g_CurrentGenerator .WordName ] strings:Cat &gt;&gt;&gt; l_Name
     Log: [ l_Name ' generation start' ]
     VAR l_Time
     StartTimer
     TRY
      ( Self .GenerateWordToFileWith: .CurrentGenerator )
     FINALLY
      l_Name StopTimerNoLog &gt;&gt;&gt; l_Time
     END // TRY..FINALLY 
     l_Time 1000 DIV &gt;&gt;&gt; l_Time
     if ( l_Time &gt; 3 ) then
     begin
      Log: [ l_Name ' generation end ' l_Time ' seconds' ]
     end // ( l_Time &gt; 3 )
    end // ( Self .NeedOwnFile )
    else
     ( Self .DeleteWordFile ) 
   ) // TF g_CurrentGenerator
  ) // aGenerators CodeIterator .for&gt;
  
  Self .ChildrenEx .for&gt; ( aGenerators call.me )
  // - тут генерируем детей  
 end // Self .NotInArray: g_GeneratedElements
; // GenerateWithChildren

elem_proc call.generators.in.list
 Sequence ^ IN aGenerators
 Self aGenerators .GenerateWithChildren
; // call.generators.in.list

elem_proc TransformWord
 //Self .Name Msg
; // TransformWord

elem_proc DoTransformWord
 RULES
  ( Self .MDAClass class_Dependency == )
   ()
  ( Self .MDAClass class_Parameter == )
   ()
  ( Self %% 'WasTransformed' NotValid )
   begin
    Self -&gt; WasTransformed := true
    Self .TransformWord
   end // ( Self %% '#Transformed' NotValid )
 ; // RULES 
; // DoTransformWord

elem_proc Generate
 g_GeneratedFiles .IsNil ?FAIL 'Массив g_GeneratedFiles не инициализирован'
 g_GeneratedElements .IsNil ?FAIL 'Массив g_GeneratedElements не инициализирован'
 
 TF g_TransformWord (
  @ .DoTransformWord &gt;&gt;&gt; g_TransformWord
  Self .DoTransformWord
  Self .call.generators.in.list ( .pas .res.cmd .rc .rc.script .dfm )
 ) // TF g_TransformWord
; // Generate