UNIT Generation.ms.dict

USES
 params.ms.dict
;

USES
 axiom_push.ms.dict
;

USES
 core.ms.dict
;

USES
 Log.ms.dict
;

USES
 WordsRTTI.ms.dict
;

USES 
 ElementsRTTI.ms.dict
;

USES
 CompileTimeVar.ms.dict
;

USES
 SaveVarAndDo.ms.dict
;

CONST cPathSep '\'

FILE CompileTime-VAR g_OutFile nil
%REMARK 'Текущий файл'

STRING CompileTime-VAR g_Indent ''
%REMARK 'Текущий отступ'

CONST cIndentChar ' '

STRING FUNCTION IndentStr
 g_Indent &gt;&gt;&gt; Result
; // IndentStr

OBJECT STRING INTEGER ARRAY BOOLEAN TYPE OUTABLE

CONST \n #13#10
CONST cQuote ''''
CONST cOpenComment '{'
CONST cCloseComment '}'
CONST cSpace ' '
CONST cUnderline '_'
CONST cDot '.'
CONST cEmptyStr ''

BOOLEAN CompileTime-VAR g_EnableAutoEOL true
BOOLEAN CompileTime-VAR g_NeedOutLn false

PROCEDURE OutLnToFile
 \n g_OutFile File:WriteStr
; // OutLnToFile

BOOLEAN FUNCTION .Out?

  OUTABLE IN aValue
  
 : .OutToFile
  if g_NeedOutLn then
  begin
   false &gt;&gt;&gt; g_NeedOutLn
   OutLnToFile
  end // g_NeedOutLn
  g_OutFile File:WriteStr  
 ; // .OutToFile 
  
 VAR l_WasOut
 VAR l_NeedIndent

 PROCEDURE .OutValue
   OUTABLE IN aValue
  RULES 
   ( aValue .IsValueValid ! )
    ()
   ( aValue IsArray )
    begin
     aValue .for&gt; call.me
    end // aValue IsArray
   DEFAULT 
    begin
     STRING VAR l_Value 
     aValue ToPrintable &gt;&gt;&gt; l_Value
     if ( l_WasOut ! ) then
     begin
      true &gt;&gt;&gt; l_WasOut
      IndentStr .OutToFile
      false &gt;&gt;&gt; l_NeedIndent
     end // l_WasOut !
     
     if ( l_NeedIndent ) then
     begin
      false &gt;&gt;&gt; l_NeedIndent
      IndentStr .OutToFile
     end // l_NeedIndent
  
     if ( l_Value \n == ) then
     begin
      l_Value .OutToFile
      true &gt;&gt;&gt; l_NeedIndent
     end // ( l_Value \n == )
     else
     begin
      l_Value .OutToFile
     end // ( l_Value \n == )
    end // DEFAULT
  ; // RULES  
 ; // .OutValue
 
 false &gt;&gt;&gt; l_WasOut
 false &gt;&gt;&gt; l_NeedIndent
 aValue .OutValue
 
 if l_WasOut then
  if g_EnableAutoEOL then
   OutLnToFile
  
 l_WasOut &gt;&gt;&gt; Result
; // .Out?

: .Out
 .Out? DROP
; // .Out

PROCEDURE Indented:
  ^ IN aLambda
  
 TF g_Indent (
  g_Indent cIndentChar Cat &gt;&gt;&gt; g_Indent
  aLambda DO
 ) 
; // Indented:

USES
 axiom:SysUtils
;

USES
 arrays.ms.dict
;

USES
 IsNil.ms.dict
;

TtfwWord FUNCTION .FindMemberRecur
  STRING IN aName
  TtfwWord IN aGen

 TtfwKeyWord VAR l_Member
 aName aGen pop:Word:FindMember &gt;&gt;&gt; l_Member

 if ( l_Member .IsNil ) then
  ( nil &gt;&gt;&gt; Result )
 else
  ( l_Member pop:KeyWord:Word &gt;&gt;&gt; Result )

 if ( Result .IsNil ) then
  ( 
   aGen .Inherited.Words .for&gt; ( 
    IN anItem 
    VAR l_Found 
    aName anItem call.me &gt;&gt;&gt; l_Found
    ( Result .IsNil ) 
    OR ( l_Found .IsNil ) 
    OR ( Result = l_Found ) 
     ?ASSURE [ 'Multiply inheritance. Word: ' aName ' generator ' aGen .WordName ' parent generator ' anItem .WordName ]
    l_Found &gt;&gt;&gt; Result
   ) 
  )

; // .FindMemberRecur

ARRAY CompileTime-VAR g_GeneratedFiles []
%REMARK 'Ранее сгенерированные файлы'

TtfwWord VAR g_CurrentGenerator
%REMARK 'Текущий генератор'

: WithGen:
  ^ IN aGen
  ^ IN aLambda
 TF g_CurrentGenerator (
  aGen &gt;&gt;&gt; g_CurrentGenerator
  aLambda DO
 ) // TF g_CurrentGenerator
; // WithGen:

WordAlias .All .True
%REMARK 'Функтор определяющий, что все значения подходят.'

WordAlias GenCached: CacheMethod
%REMARK 'Кеширует значение учитывая текущий генератор. Пока определено как Cached:'

: .?
  ^ IN aWord

 VAR l_Word

 aWord |N g_CurrentGenerator .FindMemberRecur &gt;&gt;&gt; l_Word

 if ( l_Word .IsNil ) then
  ( aWord DO )
 else
  ( l_Word DO )
; // .?

STRING FUNCTION Ext
 '.dump' &gt;&gt;&gt; Result
; // Ext

PROCEDURE ForceDirectories
  STRING IN aPath
 aPath sysutils:ForceDirectories ?ASSURE [ 'Не удалось создать директорию ' aPath ]  
; // ForceDirectories

FILE FUNCTION TryOpen:
  STRING IN aFileName
  ^ IN aOpenLambda
 %SUMMARY 
  'Открывает файл aFileName методом aOpenLambda обрабатывая ошибки открытия.' 
  'Пытается открыть файл повторно несколько раз.'
 ;
 VAR l_TryCount
 20 &gt;&gt;&gt; l_TryCount
 
 while ( l_TryCount &gt; 0 )
 begin
  TRY
   aFileName aOpenLambda DO &gt;&gt;&gt; Result 
   0 &gt;&gt;&gt; l_TryCount
  EXCEPT
   Dec l_TryCount
   nil &gt;&gt;&gt; Result
   if ( l_TryCount 0 == ) then
    RAISE
   else
   begin
    [ 'Файл ' aFileName ' был занят. Ожидаем его освобождения. Попытка номер: ' l_TryCount IntToStr ] strings:Cat &gt;&gt;std::out
    500 SLEEP
   end // ( l_TryCount 0 == )
  END // TRY..EXCEPT
 end // ( l_TryCount &gt; 0 )
; // TryOpen: 

FILE FUNCTION MakePathAndOpenWrite
  STRING IN aFileName
 %SUMMARY 
  'Открывает файл aFileName на запись.' 
  'Если надо - создаёт полный путь на файловой системе.'
 ;
 aFileName sysutils:ExtractFilePath ForceDirectories
 aFileName TryOpen: File:OpenWrite &gt;&gt;&gt; Result
; // MakePathAndOpenWrite

CONST cRoot 'w:'

PROCEDURE BackupFile
  STRING IN aFileName
  VAR l_To
 aFileName &gt;&gt;&gt; l_To
 l_To cRoot 'W:' string:Replace &gt;&gt;&gt; l_To
 l_To 'W:' 'C:\Temp\GenBackup' string:Replace &gt;&gt;&gt; l_To
 if ( aFileName sysutils:FileExists ) then
 begin
  $20 l_To aFileName CopyFile
 end // ( aFileName sysutils:FileExists )
 else
 begin
  FILE VAR l_In
  l_To MakePathAndOpenWrite &gt;&gt;&gt; l_In
  // - делаем пустышку
  TRY
  FINALLY
   nil &gt;&gt;&gt; l_In
  END // TRY..FINALLY
 end // ( aFileName sysutils:FileExists )
; // BackupFile

PROCEDURE CopyChangedFile
  STRING IN aTo
  STRING IN aFrom
  BOOLEAN IN aNeedBackup
 if (
     ( aTo sysutils:FileExists ! )
     OR ( cEmptyStr aTo aFrom CompareFiles ! ) 
    ) then
 begin
  if aNeedBackup then
  begin
   aTo BackupFile
  end // aNeedBackup
  $20 aTo aFrom CopyFile
 end 
; // CopyChangedFile

STRING elem_func FinalFileNamePrim
 cEmptyStr &gt;&gt;&gt; Result 
; // FinalFileNamePrim

STRING FUNCTION .CutSuffix
  STRING IN aString
  STRING IN aSuffix
 RULES
  ( aString .IsNil )
   ''
  ( aSuffix .IsNil )
   aString
  DEFAULT
  begin   
   aString &gt;&gt;&gt; Result 
   if ( aSuffix Result EndsStr ) then
   begin
    Result string:Len aSuffix string:Len - 
    0
    Result
    string:Substring &gt;&gt;&gt; Result
   end // ( aSuffix Result EndsStr )
   Result
  end // DEFAULT
 ; // RULES
 &gt;&gt;&gt; Result 
; // .CutSuffix

STRING FUNCTION .CutPrefix
  STRING IN aString
  STRING IN aPrefix
 RULES
  ( aString .IsNil )
   ''
  ( aPrefix .IsNil )
   aString
  DEFAULT
  begin   
   aString &gt;&gt;&gt; Result 
   if ( aPrefix Result StartsStr ) then
   begin
    Result string:Len aPrefix string:Len - 
    aPrefix string:Len
    Result
    string:Substring &gt;&gt;&gt; Result
   end // ( aPrefix Result StartsStr )
   Result
  end // DEFAULT
 ; // RULES
 &gt;&gt;&gt; Result 
; // .CutPrefix

USES
 CountIt.ms.dict
;

STRING elem_func LUID
 VAR l_UID
 Self .UID &gt;&gt;&gt; l_UID
 RULES
  DEFAULT
   l_UID
 ; // RULES
 &gt;&gt;&gt; Result
; // LUID

BOOLEAN elem_func IsSameModelElement
  ModelElement IN anOther
 RULES
  ( Self anOther ?== )
   true
  ( Self .LUID anOther .LUID == )
   true
  DEFAULT
   false 
 ; // RULES  
 &gt;&gt;&gt; Result 
; // IsSameModelElement

BOOLEAN elem_func IsArray
 Self .IsStereotype st_Vector &gt;&gt;&gt; Result
; // IsArray

BOOLEAN elem_func IsOpenArray
 Self .IsArray
 AND ( Self .GetUP "array type" 'open' == )
 &gt;&gt;&gt; Result
; // IsOpenArray

: .FirstElement
  ARRAY IN anArray
 ModelElement VAR l_Found
 nil &gt;&gt;&gt; l_Found
 anArray .trunc&gt; ( DROP l_Found .IsNil ) .for&gt; ( &gt;&gt;&gt; l_Found )
 l_Found
; // .FirstElement

ModelElement elem_func FirstAttribute
 Cached:
 (
  Self .Attributes .FirstElement
 )
 &gt;&gt;&gt; Result
; // FirstAttribute

BOOLEAN elem_func IsMixInParamType
 Self .IsStereotype st_ImpurityParamType 
 &gt;&gt;&gt; Result
; // IsMixInParamType

: g_MixInParamTypes
 @SELF
; // g_MixInParamTypes
  
BOOLEAN elem_func IsIterator
 Self .IsStereotype st_Iterator &gt;&gt;&gt; Result
; // IsIterator

FORWARD .IteratorAction

STRING elem_func TypeName
 Cached:
 (
  RULES
   ( Self .IsNil )
    ''
   ( Self IsString )
    Self
   ( Self .IsOpenArray )
    ( [ 'array of ' Self .FirstAttribute .Target call.me ] strings:Cat )
   ( Self .IsIterator )
    ( Self .IteratorAction call.me )
   DEFAULT  
    (
     STRING VAR l_ExtName
     Self .GetUP 'extprop:pas:TypeName' &gt;&gt;&gt; l_ExtName
     RULES
      ( l_ExtName .IsNotNil )
       l_ExtName
      DEFAULT
       ( Self .Name )
     ; // RULES
    )
  ; // RULES  
 )
 &gt;&gt;&gt; Result
 if ( Self .IsMixInParamType ) then
 begin
  VAR l_Field
  @ g_MixInParamTypes %% ( Self .Name ) &gt;&gt;&gt; l_Field
  if ( l_Field .IsNotNil ) then
  begin
   l_Field DO &gt;&gt;&gt; l_Field
   if ( l_Field .IsNotNil ) then
   begin
    l_Field call.me &gt;&gt;&gt; Result
   end // ( l_Field .IsNotNil )
  end // ( l_Field .IsNotNil )
 end // ( Self .IsMixInParamType )
; // TypeName

BOOLEAN elem_func IsSameType
  ModelElement IN anOther
 RULES
  ( Self anOther .IsSameModelElement )
   true
  ( Self IsString )
   RULES
    ( anOther IsString )
     false
    DEFAULT 
     ( Self anOther .TypeName == )
   ; // RULES
  ( anOther IsString )
   RULES
    ( Self IsString )
     false
    DEFAULT 
     ( Self .TypeName anOther == )
   ; // RULES
  ( Self .TypeName anOther .TypeName == )
   true
  DEFAULT
   false 
 ; // RULES  
 &gt;&gt;&gt; Result 
; // IsSameType

USES
 GarantModel.ms.dict
;

BOOLEAN elem_func IsScriptKeyword
 Self .IsStereotype st_ScriptKeyword 
 &gt;&gt;&gt; Result
; // IsScriptKeyword

WordAlias [[ [
%REMARK 'Начинает определение константного массива. Пока просто мапируется на неконстантный.'
WordAlias ]] ]
%REMARK 'Заканчивает определение константного массива. Пока просто мапируется на неконстантный.'

USES
 axiom:WordBox
;

ModelElement elem_func WeakRef
 %SUMMARY 
  'Возвращает СЛАБУЮ ссылку на элемент.'
 ;
 RULES
  ( Self IsIntf )
   ( Self pop:WordBox:Boxed )
  DEFAULT
   Self 
 ; // RULES
 &gt;&gt;&gt; Result
; // WeakRef

ARRAY elem_func ElementToArray
 RULES
  ( Self .IsNil )
   [empty]
  DEFAULT
   begin
    Cached:
    (
     [[ Self .WeakRef ]]
    ) 
   end // DEFAULT
 ; // RULES
 &gt;&gt;&gt; Result 
; // ElementToArray

WordAlias .ToArray .ElementToArray

ARRAY elem_func ElementToArray:
  ^ IN aLambda
 Self aLambda DO .ElementToArray
 &gt;&gt;&gt; Result 
; // ElementToArray:

WordAlias .ToArray: .ElementToArray:

ARRAY FUNCTION ToArray:
  ^ IN Self
 VAR l_Value 
 Self DO &gt;&gt;&gt; l_Value 
 RULES
  ( l_Value IsIntf )
   [[ l_Value ]]
  DEFAULT
   ( l_Value .ToArray )
 ; // RULES  
 &gt;&gt;&gt; Result 
; // ToArray:

elem_iterator InheritsEx
 Cached:
 (
  VAR l_Inherits
  Self .Inherits &gt;&gt;&gt; l_Inherits
  RULES
   ( l_Inherits .IsEmpty )
    RULES
     ( Self .IsScriptKeyword )
      ( ToArray: GarantModel::TtfwRegisterableWord )
     DEFAULT
      [empty]
    ; // RULES 
   DEFAULT
    l_Inherits
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // InheritsEx

BOOLEAN elem_func InheritsFrom
  ModelElement IN anAncestor
 anAncestor :Cached:
 ( 
  RULES
   ( Self .IsNil )
    false
   ( Self anAncestor .IsSameType )
    true
   (
    Self .InheritsEx
    .filter&gt; ( anAncestor call.me )
    .NotEmpty
   )
    true
   DEFAULT
    false 
  ; // RULES
 ) 
 &gt;&gt;&gt; Result
; // InheritsFrom

USES
 UseNewGenExcluded.ms.dict
;

BOOLEAN elem_func IsControllerInterfaces
 ( Self .IsStereotype st_ControllerInterfaces )
 &gt;&gt;&gt; Result
; // IsControllerInterfaces

USES
 ForceUseNewGen.ms.dict
;

BOOLEAN elem_func IsScriptKeywordsPack
 Self .IsStereotype st_ScriptKeywordsPack 
 &gt;&gt;&gt; Result
; // IsScriptKeywordsPack

BOOLEAN elem_func IsUtilityPack
 Cached:
 (
  RULES
   ( Self .IsStereotype st_UtilityPack )
    true
   ( Self .IsScriptKeywordsPack ) 
    true
   DEFAULT
    false
  ; // RULES 
 ) 
 &gt;&gt;&gt; Result
; // IsUtilityPack

BOOLEAN elem_func UseNewGenExcluded
 RULES
  ( Self .IsControllerInterfaces )
   true
  ( Self GarantModel::vcmData .InheritsFrom )
   true
  ( 
   ( Self .IsUtilityPack ! )
   AND ( Self GarantModel::Tl3Tag .InheritsFrom )
   //( Self GarantModel::Tl3Variant .InheritsFrom )
   //AND ( Self GarantModel::Tl3TagImpl .InheritsFrom ! )
   AND ( Self GarantModel::TtfwKeyWordPrim .InheritsFrom ! )
  ) 
   true
  ( Self GarantModel::TddComboBoxConfigItem .InheritsFrom )
   true
  ( Self GarantModel::Tl3ProtoObjectForTie ?== )
   false
  ( Self GarantModel::Tl3ProtoObjectForTie .InheritsFrom )
   true
  ( Self GarantModel::evdTagHolder .InheritsFrom )
   true
  DEFAULT
  begin
   if ( g_UseNewGenExcluded .IsNil ) then
    Init_g_UseNewGenExcluded
    
   g_UseNewGenExcluded .IsNil ?FAIL 'Не инициализирован g_UseNewGenExcluded'
   
   g_UseNewGenExcluded
   .filter&gt; ( Self .LUID == )
   .NotEmpty
  end // DEFAULT 
 ; // RULES  
 &gt;&gt;&gt; Result
; // UseNewGenExcluded

CONST cNotFinished 'NOT_FINISHED_'
CONST cNotCompleted 'NOT_COMPLETED_'

STRING FUNCTION .CutFinished
  STRING IN Self
 Self
 cNotFinished .CutPrefix
 cNotCompleted .CutPrefix
 &gt;&gt;&gt; Result
; // .CutFinished

STRING elem_func CustomFinalFileName
  BOOLEAN IN aForCopy
 Self .? .FinalFileNamePrim &gt;&gt;&gt; Result
 if ( Result .IsNotNil ) then
 begin
  Result '\' .CutPrefix &gt;&gt;&gt; Result
  [ cRoot 
  // - это потому, что в пути нету диска, а для ExtractFileName он нужен
  Result ] cPathSep strings:CatSep &gt;&gt;&gt; Result
 end // ( Result .IsNotNil )
 if ( Result .IsNotNil ) then
 begin
  if aForCopy then
   if ( Self .UseNewGenExcluded ) then
   begin
    VAR l_Path
    VAR l_Name
    Result sysutils:ExtractFilePath &gt;&gt;&gt; l_Path
    Result sysutils:ExtractFileName &gt;&gt;&gt; l_Name
    
    l_Name .CutFinished
    &gt;&gt;&gt; l_Name
    cNotCompleted l_Name Cat
    &gt;&gt;&gt; l_Name
    
    l_Path l_Name Cat &gt;&gt;&gt; Result
   end // (Self .UseNewGenExcluded )
 end // ( Result .IsNotNil )  
; // CustomFinalFileName

STRING elem_func FinalFileName
 Self true .CustomFinalFileName
 &gt;&gt;&gt; Result
; // FinalFileName

STRING CompileTime-VAR g_TempFileName ''
STRING CompileTime-VAR g_RealFileName ''
STRING CompileTime-VAR g_FinalFileName ''
STRING CompileTime-VAR g_FinalFileNameForUC ''
BOOLEAN CompileTime-VAR g_UCRead false
ModelElement CompileTime-VAR g_CurrentGeneratedElement nil

CONST cGenScriptsFolder 'W:\common\GenScripts\'

BOOLEAN elem_func CanCopyToFinalFile
 false &gt;&gt;&gt; Result
; // CanCopyToFinalFile

PROCEDURE DoDeleteFile
  STRING IN aFileName
  BOOLEAN IN aNeedBackup
 if aNeedBackup then
 begin
  aFileName BackupFile
 end // aNeedBackup
 aFileName DeleteFile DROP
; // DoDeleteFile

elem_proc GenerateWordToFileWith:
 ^ IN aLambda
 
 TF g_Indent (
  '' &gt;&gt;&gt; g_Indent
  STRING VAR l_FileName 
  [ Self .WordName .? Ext ] strings:Cat &gt;&gt;&gt; l_FileName
 
  STRING VAR l_TempPath
  'C:\Temp\GenScripts\' &gt;&gt;&gt; l_TempPath
  l_TempPath ForceDirectories
  
  STRING VAR l_RealPath
  cGenScriptsFolder &gt;&gt;&gt; l_RealPath
  l_RealPath ForceDirectories
  
  TF g_TempFileName (
   [ l_TempPath l_FileName ] cPathSep strings:CatSep &gt;&gt;&gt; g_TempFileName
   
   TF g_RealFileName (
    [ l_RealPath l_FileName ] cPathSep strings:CatSep &gt;&gt;&gt; g_RealFileName
    
    if ( g_TempFileName .TextNotInArray: g_GeneratedFiles ) then
    begin
     g_TempFileName .AddToArray: g_GeneratedFiles
     TF g_FinalFileName (
      TF g_FinalFileNameForUC (
       Self .FinalFileName &gt;&gt;&gt; g_FinalFileName
       Self false .CustomFinalFileName &gt;&gt;&gt; g_FinalFileNameForUC
       TF g_OutFile (
        g_TempFileName MakePathAndOpenWrite &gt;&gt;&gt; g_OutFile
        TF g_UCRead (
         TF g_NeedOutLn (
          TF g_CurrentGeneratedElement (
           Self &gt;&gt;&gt; g_CurrentGeneratedElement
           Self aLambda DO
          )
         ) // TF g_NeedOutLn
        ) // TF g_UCRead
       ) // TF g_OutFile
       g_RealFileName g_TempFileName false CopyChangedFile
       if ( g_FinalFileName .IsNotNil ) then
       begin
        if ( Self .? .CanCopyToFinalFile ) then
        begin
         g_FinalFileName g_TempFileName true CopyChangedFile
         
         VAR l_Path
         VAR l_Name
         
         g_FinalFileName sysutils:ExtractFilePath &gt;&gt;&gt; l_Path
         g_FinalFileName sysutils:ExtractFileName &gt;&gt;&gt; l_Name
         
         VAR l_NameToDelete
         VAR l_FileToDelete
         
         if ( cNotCompleted l_Name StartsStr ! ) then
         begin
          l_Name cNotFinished .CutPrefix &gt;&gt;&gt; l_NameToDelete
          [ l_Path cNotCompleted l_NameToDelete ] strings:Cat &gt;&gt;&gt; l_FileToDelete
          if ( l_FileToDelete g_FinalFileName SameText ! ) then
          begin
           if ( l_FileToDelete sysutils:FileExists ) then
           begin
            l_FileToDelete true DoDeleteFile
           end // ( l_FileToDelete sysutils:FileExists )
          end // ( l_FileToDelete g_FinalFileName SameText ! )
         end // ( cNotCompleted l_Name StartsStr ! )
         
         if ( cNotFinished l_Name StartsStr ! ) then
         begin
          l_Name cNotCompleted .CutPrefix &gt;&gt;&gt; l_NameToDelete
          [ l_Path cNotFinished l_NameToDelete ] strings:Cat &gt;&gt;&gt; l_FileToDelete
          if ( l_FileToDelete g_FinalFileName SameText ! ) then
          begin
           if ( l_FileToDelete sysutils:FileExists ) then
           begin
            l_FileToDelete true DoDeleteFile
           end // ( l_FileToDelete sysutils:FileExists )
          end // ( l_FileToDelete g_FinalFileName SameText ! )
         end // ( cNotFinished l_Name StartsStr ! )
         
        end // ( Self .? .CanCopyToFinalFile )
       end // ( g_FinalFileName .IsNotNil )
      ) // TF g_FinalFileNameForUC
     ) // TF g_FinalFileName
    end // g_TempFileName .TextNotInArray: g_GeneratedFiles
   ) // TF g_RealFileName
  ) // TF g_TempFileName
 ) // TF g_Indent 
; // GenerateWordToFileWith:

elem_proc DeleteWordFile
 
  STRING VAR l_FileName 
  [ Self .WordName .? Ext ] strings:Cat &gt;&gt;&gt; l_FileName
  
  STRING VAR l_RealPath
  cGenScriptsFolder &gt;&gt;&gt; l_RealPath
  
  TF g_RealFileName (
   [ l_RealPath l_FileName ] cPathSep strings:CatSep &gt;&gt;&gt; g_RealFileName
   
   if ( g_RealFileName sysutils:FileExists ) then
   begin
    g_RealFileName true DoDeleteFile
   end // ( g_RealFileName sysutils:FileExists )
  ) // TF g_RealFileName 
; // DeleteWordFile

BOOLEAN elem_func IsServiceImplementation
 Self .IsStereotype st_ServiceImplementation 
 &gt;&gt;&gt; Result
; // IsServiceImplementation

BOOLEAN elem_func IsService
 Self .IsStereotype st_Service 
 &gt;&gt;&gt; Result
; // IsService

BOOLEAN elem_func IsTestCase
 Self .IsStereotype st_TestCase 
 &gt;&gt;&gt; Result
; // IsTestCase

BOOLEAN elem_func IsTestLibrary
 Self .IsStereotype st_TestLibrary
 &gt;&gt;&gt; Result
; // IsTestLibrary

BOOLEAN elem_func IsTestUnit
 Self .IsStereotype st_TestUnit
 &gt;&gt;&gt; Result
; // IsTestUnit

BOOLEAN elem_func IsUnit
 Self .IsStereotype st_Unit
 &gt;&gt;&gt; Result
; // IsUnit

BOOLEAN elem_func IsImpl
 Self .IsStereotype st_Impl
 &gt;&gt;&gt; Result
; // IsImpl

BOOLEAN elem_func IsLibrary
 Self .IsStereotype st_Library
 &gt;&gt;&gt; Result
; // IsLibrary

BOOLEAN elem_func IsVCMModule
 Self .IsStereotype st_VCMModule
 &gt;&gt;&gt; Result
; // IsVCMModule

BOOLEAN elem_func IsVCMCustomForm
 Self .IsStereotype st_VCMCustomForm 
 &gt;&gt;&gt; Result
; // IsVCMCustomForm

BOOLEAN elem_func IsVCMDataModule
 Self .IsStereotype st_VCMDataModule
 &gt;&gt;&gt; Result
; // IsVCMDataModule

BOOLEAN elem_func IsVCMForm
 Self .IsStereotype st_VCMForm 
 &gt;&gt;&gt; Result
; // IsVCMForm

BOOLEAN elem_func IsVCMContainer
 Self .IsStereotype st_VCMContainer
 &gt;&gt;&gt; Result
; // IsVCMContainer

BOOLEAN elem_func IsVCMMainForm
 Self .IsStereotype st_VCMMainForm
 &gt;&gt;&gt; Result
; // IsVCMMainForm

BOOLEAN elem_func IsGuiControl
 Self .IsStereotype st_GuiControl
 &gt;&gt;&gt; Result
; //IsGuiControl

BOOLEAN elem_func IsUseCaseController
 Self .IsStereotype st_UseCaseController 
 &gt;&gt;&gt; Result
; // IsUseCaseController

BOOLEAN elem_func IsViewAreaController
 Self .IsStereotype st_ViewAreaController 
 &gt;&gt;&gt; Result
; // IsViewAreaController

BOOLEAN elem_func IsUseCaseControllerImp
 Self .IsStereotype st_UseCaseControllerImp 
 &gt;&gt;&gt; Result
; // IsUseCaseControllerImp

BOOLEAN elem_func IsViewAreaControllerImp
 Self .IsStereotype st_ViewAreaControllerImp 
 &gt;&gt;&gt; Result
; // IsViewAreaControllerImp

BOOLEAN elem_func IsSimpleClass
 Cached:
 (
  RULES
   ( Self .IsUseCaseControllerImp )
    ( Self .Abstraction at_abstract != )
   ( Self .IsViewAreaControllerImp )
    ( Self .Abstraction at_abstract != )
   ( Self .IsStereotype st_SimpleClass ) 
    true
   ( Self .IsStereotype st_ObjStub ) 
    true
   ( Self .IsService ) 
    true
   ( Self .IsServiceImplementation ) 
    true
   ( Self .IsScriptKeyword ) 
    true
   ( Self .IsTestCase ) 
    true
   ( Self .IsGuiControl ) 
    true
   ( Self .IsVCMForm ) 
    true
   ( Self .IsStereotype st_VCMFinalForm ) 
    true
   ( Self .IsVCMContainer ) 
    true
   ( Self .IsStereotype st_VCMFinalContainer ) 
    true
   DEFAULT
    false 
  ; // RULES
 )  
 &gt;&gt;&gt; Result
; // IsSimpleClass
 
BOOLEAN elem_func IsInternalInterfaces
 Self .IsStereotype st_InternalInterfaces
 &gt;&gt;&gt; Result
; // IsInternalInterfaces

BOOLEAN elem_func IsInterfaces
 Cached:
 (
  RULES
   ( Self .IsStereotype st_Interfaces ) 
    true
   ( Self .IsInternalInterfaces )
    true
   DEFAULT
    false
  ; // RULES 
 )
 &gt;&gt;&gt; Result
; // IsInterfaces

: .SecondElement
  ARRAY IN anArray
 ModelElement VAR l_Found
 nil &gt;&gt;&gt; l_Found
 INTEGER VAR l_Index
 0 &gt;&gt;&gt; l_Index
 anArray .trunc&gt; ( DROP l_Index &lt; 2 ) .for&gt; (
   IN anItem
  ( l_Index 1 == ) ? 
   ( anItem &gt;&gt;&gt; l_Found ) 
  INC l_Index 
 ) // anArray .trunc&gt; ( DROP l_Index &lt; 2 ) .for&gt;
 l_Found
; // .SecondElement

ModelElement CompileTime-VAR g_DefaultInterfaceAncestor nil

BOOLEAN elem_func IsTypedef
 Self .IsStereotype st_Typedef 
 &gt;&gt;&gt; Result
; // IsTypedef

BOOLEAN elem_func IsPointer
 Self .UPisTrue "isPointer"
 &gt;&gt;&gt; Result
; // IsPointer

ModelElement elem_func MainAncestorPrim
 Self .InheritsEx .FirstElement 
 &gt;&gt;&gt; Result
; // MainAncestorPrim

BOOLEAN elem_func IsInterface
 Cached:
 (
  RULES
   ( Self .IsStereotype st_ObjStub ) 
    false
   ( Self .IsStereotype st_Facet )
    true
   ( Self .IsStereotype st_Interface )
    true
   ( Self .Name 'object' == )
    true
   ( Self .IsTypedef )
    RULES
     ( Self .IsPointer )
      false
     DEFAULT
      ( Self .MainAncestorPrim call.me )
    ; // RULES  
   DEFAULT
    false 
  ; // RULES 
 )  
 &gt;&gt;&gt; Result
; // IsInterface

BOOLEAN elem_func IsPureMixIn
 Self .IsStereotype st_PureMixIn 
 &gt;&gt;&gt; Result
; // IsPureMixIn

BOOLEAN elem_func IsTestCaseMixIn
 Self .IsStereotype st_TestCaseMixIn
 &gt;&gt;&gt; Result
; // IsTestCaseMixIn

BOOLEAN elem_func IsMixIn
 Cached:
 (
  RULES
   ( Self .IsStereotype st_Impurity )
    true
   ( Self .IsTestCaseMixIn )
    true
   ( Self .IsVCMCustomForm )
    RULES
     ( Self .Abstraction at_abstract == )
      RULES
       ( Self .MainAncestorPrim .IsNil )
        true
       ( Self .MainAncestorPrim call.me )
        true
       DEFAULT
        false
      ; // RULES
     DEFAULT
      false
    ; // RULES
/*{   ( Self .IsUseCaseController )
    ( Self .Abstraction at_abstract == )
   ( Self .IsViewAreaController )
    ( Self .Abstraction at_abstract == )}*/
   ( Self .IsUseCaseControllerImp )
    ( Self .Abstraction at_abstract == )
   ( Self .IsViewAreaControllerImp )
    ( Self .Abstraction at_abstract == )
   DEFAULT
    false 
  ; // RULES 
 )
 &gt;&gt;&gt; Result
; // IsMixIn

BOOLEAN elem_func IsVCMFormSetFactory
 Self .IsStereotype st_VCMFormSetFactory 
 &gt;&gt;&gt; Result
; // IsVCMFormSetFactory

BOOLEAN elem_func IsVCMFormsPack
 Self .IsStereotype st_VCMFormsPack 
 &gt;&gt;&gt; Result
; // IsVCMFormsPack

ModelElement elem_func DefaultAncestor
 Cached:
 (
  RULES
   ( Self .IsMixIn )
    nil
   ( Self .IsVCMFormSetFactory )
    GarantModel::TvcmFormSetFactory
   ( Self .IsVCMFormsPack )
    GarantModel::TvcmModule 
   ( Self .IsVCMContainer )
    GarantModel::TvcmContainerForm
   ( Self .IsVCMMainForm )
    GarantModel::TvcmMainForm
   ( Self .IsVCMDataModule )
    GarantModel::TDataModule
   ( Self .IsVCMCustomForm )
    GarantModel::TvcmEntityForm
   ( Self .Abstraction at_abstract == )
    nil
   ( Self .IsViewAreaController )
    GarantModel::IvcmViewAreaController
   ( Self .IsUseCaseController )
    GarantModel::IvcmUseCaseController
   DEFAULT
    nil
  ; // RULES
 ) 
 &gt;&gt;&gt; Result
; // DefaultAncestor

ModelElement elem_func MainAncestor
 Cached:
 (
  RULES
   ( Self .IsPointer )
    ( Self .MainAncestorPrim )
   ( Self .IsTypedef )
    ( Self .MainAncestorPrim )
   ( Self .IsPureMixIn )
    ( Self .MainAncestorPrim )
   ( Self .IsInterface )
    (
     RULES
      (
       ( g_DefaultInterfaceAncestor .IsNotNil )
       AND ( g_DefaultInterfaceAncestor Self != )
       AND ( Self .MainAncestorPrim .IsNil )
      )
       g_DefaultInterfaceAncestor
      DEFAULT
       ( Self .MainAncestorPrim )
     ; // RULES 
    ) 
   DEFAULT
    ( Self .MainAncestorPrim )
  ; // RULES
   
  &gt;&gt;&gt; Result
  
  RULES
   ( Result .IsNil )
    ( Self .DefaultAncestor )
   DEFAULT
    Result 
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // MainAncestor

BOOLEAN elem_func IsRange
 Self .IsStereotype st_Range 
 &gt;&gt;&gt; Result
; // IsRange

BOOLEAN elem_func IsEnum
 Self .IsStereotype st_Enum 
 &gt;&gt;&gt; Result
; // IsEnum

BOOLEAN elem_func IsFunction
 Self .IsStereotype st_Function 
 &gt;&gt;&gt; Result
; // IsFunction

BOOLEAN elem_func IsRecord
 RULES
  ( Self .IsStereotype st_Struct )
   true
  ( Self .IsTypedef )
   RULES
    ( Self .IsPointer )
     false
    DEFAULT
     ( Self .MainAncestor call.me )
   ; // RULES  
  DEFAULT
   false 
 ; // RULES 
 &gt;&gt;&gt; Result
; // IsRecord

BOOLEAN elem_func IsDefine
 Self .IsStereotype st_Define 
 &gt;&gt;&gt; Result
; // IsDefine

BOOLEAN elem_func IsUndef
 Self .IsStereotype st_Undef 
 &gt;&gt;&gt; Result
; // IsUndef

BOOLEAN elem_func IsUnion
 Self .IsStereotype st_Union 
 &gt;&gt;&gt; Result
; // IsUnion

BOOLEAN elem_func IsRecordOrUnion
 RULES
  ( Self .IsRecord )
   true
  ( Self .IsUnion )
   true
  DEFAULT
   false
 ; // RULES
 &gt;&gt;&gt; Result
; // IsRecordOrUnion

BOOLEAN elem_func IsStaticObject
 Self .IsStereotype st_StaticObject 
 &gt;&gt;&gt; Result
; // IsStaticObject

BOOLEAN elem_func IsRecordOrUnionOrStaticObject
 RULES
  ( Self .IsRecordOrUnion )
   true
  ( Self .IsStaticObject )
   true
  DEFAULT
   false 
 ; // RULES
 &gt;&gt;&gt; Result
; // IsRecordOrUnionOrStaticObject

BOOLEAN elem_func CannotFinalizeProperty
 RULES
  ( Self .IsRecordOrUnionOrStaticObject )
   true
  ( Self .IsMixInParamType )
   true
  ( Self .IsOpenArray )
   false
  ( Self .IsArray )
   true  
  DEFAULT
   false 
 ; // RULES
 &gt;&gt;&gt; Result
; // CannotFinalizeProperty

BOOLEAN elem_func IsElementProxy
 Self .IsStereotype st_ElementProxy 
 &gt;&gt;&gt; Result
; // IsElementProxy

BOOLEAN elem_func IsSetOf
 Self .IsStereotype st_SetOf 
 &gt;&gt;&gt; Result
; // IsSetOf

BOOLEAN elem_func IsException
 Self .IsStereotype st_Exception 
 &gt;&gt;&gt; Result
; // IsException

BOOLEAN elem_func IsTagTable
 Self .IsStereotype st_TagTable 
 &gt;&gt;&gt; Result
; // IsTagTable

BOOLEAN elem_func IsVCMGUI
 Self .IsStereotype st_VCMGUI 
 &gt;&gt;&gt; Result
; // IsVCMGUI

BOOLEAN elem_func IsTestTarget
 Self .IsStereotype st_TestTarget 
 &gt;&gt;&gt; Result
; // IsTestTarget

BOOLEAN elem_func IsVCMUseCaseRealization
 Self .IsStereotype st_VCMUseCaseRealization
 &gt;&gt;&gt; Result
; // IsVCMUseCaseRealization

BOOLEAN elem_func IsVCMUseCase
 Self .IsStereotype st_VCMUseCase
 &gt;&gt;&gt; Result
; // IsVCMUseCase

BOOLEAN elem_func IsVCMTestTarget
 Self .IsStereotype st_VCMTestTarget 
 &gt;&gt;&gt; Result
; // IsVCMTestTarget

BOOLEAN elem_func IsExeTarget
 Self .IsStereotype st_ExeTarget 
 &gt;&gt;&gt; Result
; // IsExeTarget

BOOLEAN elem_func IsExe
 RULES
  ( Self .IsExeTarget )
   true
  ( Self .IsTestTarget )
   true 
  ( Self .IsVCMGUI )
   true 
  DEFAULT
   false
 ; // RULES 
 &gt;&gt;&gt; Result
; // IsExe

BOOLEAN elem_func IsAdapterTarget
 Self .IsStereotype st_AdapterTarget &gt;&gt;&gt; Result
; // IsAdapterTarget

BOOLEAN elem_func IsDLL
 Self .IsAdapterTarget &gt;&gt;&gt; Result
; // IsDLL

BOOLEAN elem_func IsTarget
 Cached:
 (
  RULES
   ( Self .IsVCMGUI ) 
    true
   ( Self .IsExe ) 
    true
   ( Self .IsDLL ) 
    true
   DEFAULT
    false
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // IsTarget

BOOLEAN elem_func IsAtom
 Self .IsStereotype st_Atom
 &gt;&gt;&gt; Result
; // IsAtom

BOOLEAN elem_func IsTag
 Self .IsStereotype st_Tag
 &gt;&gt;&gt; Result
; // IsTag

BOOLEAN elem_func IsEvdSchemaElement
 Self .IsAtom
 &gt;&gt;&gt; Result
; // IsEvdSchemaElement

BOOLEAN elem_func IsClassOrMixIn
 Cached:
 (
  RULES
   ( Self .IsSimpleClass )
    true
   ( Self .IsMixIn )
    true
   DEFAULT
    false
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // IsClassOrMixIn

BOOLEAN elem_func IsTestClass
 Self .IsStereotype st_TestClass &gt;&gt;&gt; Result
; // IsTestClass

BOOLEAN elem_func IsUserType
 Self .IsStereotype st_UserType &gt;&gt;&gt; Result
; // IsUserType

BOOLEAN elem_func IsScriptKeywords
 Self .IsStereotype st_ScriptKeywords &gt;&gt;&gt; Result
; // IsScriptKeywords

BOOLEAN elem_func IsTestResults
 Self .IsStereotype st_TestResults &gt;&gt;&gt; Result
; // IsTestResults

BOOLEAN elem_func NeedOwnFilePrim
 Cached:
 (
  RULES
   ( Self .IsNil )
    false
    
   ( Self .IsScriptKeywords ) 
    false 
    
   ( Self .IsUserType ) 
    true
    
   ( Self .IsTestClass ) 
    true
    
   ( Self .IsEvdSchemaElement ) 
    true
    
   ( Self .IsTarget ) 
    true
    
   ( Self .IsTestResults ) 
    true
    
   ( Self .IsTagTable ) 
    true
    
   ( Self .IsInterfaces )
    true
   
   ( Self .IsUtilityPack )
    true
   
   ( Self .IsMixIn )
    true
   
   ( Self .IsElementProxy )
    true
    
   ( Self .IsVCMFormSetFactory )
    true
    
   ( Self .IsVCMCustomForm )
    true
   
   ( Self .IsTestLibrary )
    RULES
     ( Self .FinalFileName .IsNil )
      false
     DEFAULT
      true
    ; // RULES
    
   ( Self .IsTestUnit )
    true  
   
   ( Self .IsUnit )
    false  
   
   ( Self .IsImpl )
    false  
   
   ( Self .IsLibrary )
    false
   
   ( Self .IsSimpleClass )
   begin
    RULES
     ( Self .Visibility ProtectedAccess == )
      false
     ( Self .Visibility PrivateAccess == )
      RULES
       ( Self .IsScriptKeyword )
        RULES
         ( Self .Parent .IsVCMModule )
          true
         DEFAULT
          false
        ; // RULES
       DEFAULT
        false
      ; // RULES  
     DEFAULT
      ( 
       ModelElement VAR l_Parent
       Self .Parent &gt;&gt;&gt; l_Parent
       RULES
        ( 
         l_Parent .IsScriptKeywordsPack 
         AND ( Self .IsScriptKeyword )
        ) 
         true
        ( l_Parent .IsClassOrMixIn ) 
         false
        ( l_Parent .IsUtilityPack )
         false
        ( l_Parent .IsInterfaces )
         false
        DEFAULT 
         true
       ; // RULES  
      )
    ; // RULES
   end // ( Self .IsSimpleClass )
   
   DEFAULT
    false
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // NeedOwnFilePrim

elem_proc CurrentGenerator
 Self g_CurrentGenerator DO
; // CurrentGenerator

USES
 CallInherited.ms.dict
;

USES
 classRelations.ms.dict
;

BOOLEAN elem_func NeedOwnFile
 Self .? .NeedOwnFilePrim &gt;&gt;&gt; Result
; // NeedOwnFile

PROCEDURE OutLn
 if g_NeedOutLn then
  OutLnToFile
 true &gt;&gt;&gt; g_NeedOutLn
; // OutLn

elem: WithDelim
  STRING IN aDelim
  TtfwWord IN aVar
  TtfwWord IN aLambda
 [ 
  if ( aVar DO ! ) then
  begin
   true aVar pop:Word:SetValue
  end
  else
  begin
   aDelim
  end
  Self 
 ] aLambda DO
; // WithDelim

elem: WithComma:
  ^ IN aVar
  ^ IN aLambda
 Self ', ' aVar aLambda .WithDelim
; // WithComma:

STRING FUNCTION .CutT
  STRING IN aName
 aName 'T' .CutPrefix &gt;&gt;&gt; Result
; // .CutT

CONST cProxy '_Proxy'

STRING elem_func UnitNamePrim
 GenCached:
 (
  STRING VAR l_Path
  Self .FinalFileName &gt;&gt;&gt; l_Path
  RULES
   ( l_Path .IsNotNil )
    ( l_Path sysutils:ExtractFileName cEmptyStr sysutils:ChangeFileExt )
   ( Self .IsNil )
     cEmptyStr
   ( Self .IsElementProxy )
    ( Self .Name cProxy Cat )
   ( Self .IsTagTable )
    ( Self .Name '_Schema' Cat )
   ( Self .IsScriptKeyword )
    ( Self .Name .CutT )
   ( Self .IsSimpleClass )
    ( Self .Name .CutT )
   DEFAULT
    ( Self .Name )
  ; // RULES
  &gt;&gt;&gt; Result
  
  if ( Self .UseNewGenExcluded ) then
  begin
   Result
   .CutFinished
   &gt;&gt;&gt; Result
   cNotCompleted Result Cat
   &gt;&gt;&gt; Result
  end // ( Self .UseNewGenExcluded )
  
  Result
 )
 &gt;&gt;&gt; Result
; // UnitNamePrim

STRING elem_func UnitName
 GenCached:
 (
  Self .UnitNamePrim .CutFinished
 )
 &gt;&gt;&gt; Result
; // UnitName

ModelElement elem_func UnitProducer
 GenCached:
 (
  RULES
   ( Self .IsNil )
    nil
   ( Self IsString )
    Self
   ( Self .NeedOwnFile )
    Self
   DEFAULT 
    ( Self .Parent call.me )
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // UnitProducer

STRING elem_func EffectiveUnitName
 GenCached:
 (
  Self .UnitProducer .UnitName
 )
 &gt;&gt;&gt; Result
; // EffectiveUnitName

ARRAY FUNCTION .filterNil&gt;
  ARRAY IN anArray
 anArray
 .filter&gt; .IsNotNil
 &gt;&gt;&gt; Result
; // .filterNil&gt;

ARRAY FUNCTION .filterMixIns&gt;
  ARRAY IN anArray
 anArray
 .filter&gt; ( .IsMixIn ! ) 
 // .filter&gt; ( .IsPureMixIn ! )
 &gt;&gt;&gt; Result
; // .filterMixIns&gt;

BOOLEAN elem_func IsMethod
 Self .IsStereotype st_method &gt;&gt;&gt; Result
; // IsMethod

BOOLEAN elem_func IsMessageOperation
 Self .IsStereotype st_message::Operation &gt;&gt;&gt; Result
; // IsMessageOperation

BOOLEAN elem_func IsMessage
 Self .IsStereotype st_Message &gt;&gt;&gt; Result
; // IsMessage

BOOLEAN elem_func IsLocalMethod
 Self .IsStereotype st_localmethod &gt;&gt;&gt; Result
; // IsLocalMethod

ModelElement elem_func KeywordOperation
 Self .SpelledFor
 &gt;&gt;&gt; Result
; // KeywordOperation

ModelElement elem_func KeywordImplementationMethod
 Self .Stub
 &gt;&gt;&gt; Result
; // KeywordImplementationMethod

ModelElement elem_func KeywordObjectToOperate
 Self .Speller
 &gt;&gt;&gt; Result
; // KeywordObjectToOperate

BOOLEAN elem_func IsKeyWord
 Self .IsStereotype st_keyword::Operation 
 &gt;&gt;&gt; Result
; // IsKeyWord

BOOLEAN elem_func IsGlobalKeyWord
 Self .IsStereotype st_globalkeyword::Operation 
 &gt;&gt;&gt; Result
; // IsGlobalKeyWord

BOOLEAN elem_func IsSomeKeyWord
 RULES
  ( Self .IsKeyWord )
   true
  ( Self .IsGlobalKeyWord )
   true
  DEFAULT
   false 
 ; // RULES
 &gt;&gt;&gt; Result
; // IsSomeKeyWord

USES
 axiom:CompiledProcedure
 axiom:KeyValues
;

: KeyValuesCreateAndDo:
  ^ IN aLambda
 VAR l_Param 
 KeyValues:Create &gt;&gt;&gt; l_Param
 TRY 
  l_Param aLambda DO
 FINALLY
  l_Param pop:Word:DecRef 
 END // TRY..FINALLY
; // KeyValuesCreateAndDo:

elem: DecorateMethodAndDo:
  ^ IN aLambda
 KeyValuesCreateAndDo: ( 
   IN aMethod
  aMethod -&gt; Original := ( Self .WeakRef )
  aMethod aLambda DO
 ) // KeyValuesCreateAndDo:
; // DecorateMethodAndDo:

INTERFACE elem_func DecorateMethod:
  ^ IN aLambda
 Self .DecorateMethodAndDo: (
   IN aMethod
  aMethod pop:Word:Box &gt;&gt;&gt; Result
  aMethod aLambda DO
 ) // Self .DecorateMethodAndDo:
; // DecorateMethod:

INTERFACE FUNCTION MakeParam:
  STRING IN aName
  ModelElement IN aType
  ^ IN aLambda
 
 KeyValuesCreateAndDo: ( 
   IN l_Param
  
  l_Param pop:Word:Box &gt;&gt;&gt; Result
  
  l_Param -&gt; Name := aName
  if ( aType .IsNotNil ) then
  begin
   l_Param -&gt; Target := aType
  end // ( aType .IsNotNil )
  
  l_Param aLambda DO
 ) // KeyValuesCreateAndDo:
 
; // MakeParam:

INTERFACE FUNCTION MakeParam
  STRING IN aName
  ModelElement IN aType
 
 aName aType MakeParam: DROP
 &gt;&gt;&gt; Result
; // MakeParam

WordAlias MakeFunction MakeParam
WordAlias MakeFunction: MakeParam:

WordAlias MakeField MakeParam
WordAlias MakeField: MakeParam:

WordAlias MakeProperty MakeParam
WordAlias MakeProperty: MakeParam:

: MakeProcedure
 nil MakeFunction
; // MakeProcedure

MACRO MakeProcedure:
 'nil' Ctx:Parser:PushSymbol
 'MakeFunction:' Ctx:Parser:PushSymbol
; // MakeProcedure:

STRING elem_func SelfName
 Self .GetUP 'extprop:rc:SelfName' &gt;&gt;&gt; Result
 if ( Result .IsNil ) then
 begin
  Self .TypeName &gt;&gt;&gt; Result
 end 
; // SelfName

INTERFACE elem_func ValueParam
 Cached:
 (
  'aValue' Self MakeParam
 ) &gt;&gt;&gt; Result
; // ValueParam

BOOLEAN FUNCTION .HasSomeOf:
  ARRAY IN anArray
  ^ IN aCompareFunc
 anArray 
 .filter&gt; ( aCompareFunc DO )
 .NotEmpty
 &gt;&gt;&gt; Result
; // .HasSomeOf:

BOOLEAN elem_func HasName
  STRING IN aName
 Self .Name aName == 
 &gt;&gt;&gt; Result
; // HasName

BOOLEAN FUNCTION .HasModelElementWithName
  ARRAY IN anArray
  STRING IN aName
 anArray .HasSomeOf: ( aName .HasName )
 &gt;&gt;&gt; Result
; // .HasModelElementWithName

ModelElement elem_func OpSelfParam
 Cached:
 (
  'a' Self .SelfName Cat Self MakeParam
 )
 &gt;&gt;&gt; Result
; // OpSelfParam

ModelElement elem_func CtxParam
 Cached:
 (
  'aCtx' Self MakeParam
 )
 &gt;&gt;&gt; Result
; // CtxParam

BOOLEAN elem_func IsCreator
 Self .IsStereotype st_creator::Operation 
 &gt;&gt;&gt; Result
; // IsCreator

BOOLEAN elem_func IsVarWorker
 RULES
  ( Self .IsStereotype st_varworker::Operation )
   true
  ( Self .IsStereotype st_globalvarworker::Operation )
   true
  DEFAULT
   false 
 ; // RULES
 &gt;&gt;&gt; Result
; // IsVarWorker

BOOLEAN elem_func IsWordWorker
 RULES
  ( Self .IsStereotype st_wordworker::Operation )
   true
  ( Self .IsStereotype st_globalwordworker::Operation )
   true
  DEFAULT
   false 
 ; // RULES
 &gt;&gt;&gt; Result
; // IsWordWorker

STRING elem_func NameForScript
 Self .GetUP "NameForScript" ToPrintable
 &gt;&gt;&gt; Result
; // NameForScript

elem_iterator OperationsEx
 Cached:
 (
  VAR l_Operations
  Self .Operations &gt;&gt;&gt; l_Operations
  l_Operations
  
  RULES
   ( Self .IsScriptKeyword )
    begin
     VAR l_Op
     Self .KeywordOperation &gt;&gt;&gt; l_Op
     if (
         ( l_Op .IsNotNil ) 
         AND ( l_Op .IsSomeKeyWord )
        ) then
     begin
      if ( 
          ( l_Op .GetUP 'extprop:prop_stereo' .IsValueValid )
          OR ( l_Op .UPisTrue "lvalue" )
         ) then
      begin
       if (
           ( l_Op .UPisTrue "mapped" ! )
           AND ( l_Op .GetUP 'extprop:prop_stereo' 'readonly' ?!= )
          ) then
       begin
        if ( l_Operations 'DoSetValue' .HasModelElementWithName ! ) then
        begin
         .join&gt; ToArray: (
          'DoSetValue' MakeProcedure: (
            IN aMade
           VAR l_Self
           Self .KeywordObjectToOperate &gt;&gt;&gt; l_Self
           aMade -&gt; UID := ( Self .LUID '_DoSetValue' Cat ) 
           aMade -&gt; %SUM := ( 'Метод установки значения свойства ' l_Op .Name Cat )
           aMade -&gt; Stereotype := st_static::Operation
           aMade -&gt; Visibility := ProtectedAccess
           aMade -&gt; Abstraction := at_final
           aMade -&gt; Parameters := ( 
            ToArray: ( l_Self .OpSelfParam )
            .join&gt; ( l_Op .Parameters )
            .join&gt; ToArray: ( l_Op .Target .ValueParam )
           ) // aMade -&gt; Parameters
          ) // MakeProcedure:
         ) // .join&gt; ToArray:
        end // ( l_Operations 'DoSetValue' .HasModelElementWithName ! )
       end // ( l_Op .UPisTrue "mapped" ! )
      end // ( l_Op .GetUP 'extprop:prop_stereo' .IsValueValid )
      
      VAR l_Self
      Self .KeywordObjectToOperate &gt;&gt;&gt; l_Self
      if (
          ( l_Op .UPisTrue "mapped" )
          OR ( l_Self .NotIsNil )
          OR ( l_Op .Parameters .NotEmpty )
          OR ( l_Op .Target .NotIsNil )
          OR ( l_Op .IsVarWorker )
         ) then
      begin
       VAR l_Name
       l_Op .Name &gt;&gt;&gt; l_Name
       if ( l_Operations l_Name .HasModelElementWithName ! ) then
       begin
        .join&gt; ToArray: (
         l_Name 
         if ( l_Op .IsCreator ) then
         begin
          l_Self
         end // ( l_Op .IsCreator )
         else
         begin
          l_Op .Target
         end // ( l_Op .IsCreator )
         MakeFunction: (
           IN aMade
          aMade -&gt; UID := ( l_Op .LUID ) 
          // - пусть лучше мапируется на порождащую операцию, чтобы при переносе класса - не переделывать
          aMade -&gt; %SUM := ( 'Реализация слова скрипта ' Self .NameForScript Cat )
          aMade -&gt; Visibility := PrivateAccess
          aMade -&gt; Abstraction := at_final
          aMade -&gt; IsSummoned := true
          // - это можно убрать, если перенести сюда вот что:
/*{
   (
    ( Self .OpKind opkind_Normal == ) // - метод новый, а не перекрытый
    AND ( l_Op .IsNotNil )
    AND ( l_Self .IsNotNil )
    AND ( l_Implementor .IsSummoned )
    AND ( l_Op .UPisTrue "mapped" )
   )
     Code:
       ( 
        [ 
         ' '
         if ( Self .Target .IsNotNil ) then
         begin
          'Result := ' 
         end
         'a' l_Self .SelfName cDot l_Op .Name l_Op .ParametersList ';' 
        ] .Out 
       )
    
}*/          
          aMade -&gt; SpelledFor := l_Op
          aMade -&gt; Parameters := (
           ToArray: ( GarantModel::TtfwContext .CtxParam )
           if ( l_Op .IsVarWorker ) then
           begin
            .join&gt; [ 
             if ( l_Op .IsWordWorker ) then
              'aWord'
             else
              'aVar' 
             GarantModel::TtfwWord MakeParam 
            ] // .join&gt;
           end // ( l_Op .IsVarWorker )
           if ( l_Op .IsCreator ! ) then
           begin
            if ( l_Self .NotIsNil ) then
            begin
             .join&gt; ToArray: ( l_Self .OpSelfParam )
            end // ( l_Self .NotIsNil )
           end // ( l_Op .IsCreator ! )
           .join&gt; ( l_Op .Parameters )
          ) // aMade -&gt; Parameters
          VAR l_Ref
          Self .WeakRef &gt;&gt;&gt; l_Ref
          l_Ref -&gt; Stub := aMade
          // - обратная ссылка для l_Call
          // %{Class_Inst}%f_set_var(Stub,{Op_Instance})\
         ) // MakeFunction:
        ) // .join&gt; ToArray:
       end // ( l_Operations l_Name .HasModelElementWithName ! )
      end // ( l_Op .UPisTrue "mapped" )
      
     end // ( l_Op .IsNotNil )
    end // ( Self .IsScriptKeyword )
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // OperationsEx

ModelElement elem_func FirstOperation
 Cached:
 (
  Self .OperationsEx
  .filter&gt; ( .IsLocalMethod ! ) 
  .FirstElement
 )
 &gt;&gt;&gt; Result
; // FirstOperation

BOOLEAN elem_func IsFacetIterator
 Self .IsStereotype st_facetiterator 
 &gt;&gt;&gt; Result
; // IsFacetIterator

BOOLEAN elem_func IsMixInMirror
 Self .IsStereotype st_MixInMirror
 &gt;&gt;&gt; Result
; // IsMixInMirror

BOOLEAN elem_func IsVCMOperations
 Self .IsStereotype st_VCMOperations 
 &gt;&gt;&gt; Result
; // IsVCMOperations

BOOLEAN elem_func IsClassImplementable
 Cached:
 (
  RULES
   ( Self .IsPureMixIn )
    false
   ( Self .IsMixIn )
    false
   ( Self .IsSimpleClass )
    false
   ( Self .IsEvdSchemaElement )
    false 
   ( Self .IsMixInMirror )
    false 
   ( Self .IsStereotype st_UseCase )
    false 
   ( Self .IsVCMOperations )
    false 
   ( Self .IsInterface )
    true
   ( Self .IsTypedef )
    RULES
     ( Self .IsPointer )
      false
     DEFAULT
      ( Self .MainAncestor call.me )
    ; // RULES  
   DEFAULT
    true
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // IsClassImplementable

BOOLEAN elem_func IsImplements
 Self .IsStereotype st_implements::Dependency 
 &gt;&gt;&gt; Result
; // IsImplements

ARRAY FUNCTION .mapToTarget&gt;
  ARRAY IN anArray
 anArray .map&gt; .Target 
 &gt;&gt;&gt; Result
; // .mapToTarget&gt;

WordAlias .KeepInStack NOP

ARRAY FUNCTION array:Copy
  IN anArray
 RULES
  ( anArray .IsNil )
   [nil]
  DEFAULT 
   (
    VAR l_Empty
    true &gt;&gt;&gt; l_Empty
    [ 
     anArray .for&gt; ( 
      // .KeepInStack
      // - это теперь не нужно, непустой функтор и так есть
      false &gt;&gt;&gt; l_Empty
     ) // anArray .for&gt;
    ] 
    RULES
     l_Empty
      ( DROP [nil] )
    ; // RULES
   ) 
 ; // RULES 
 &gt;&gt;&gt; Result
; // array:Copy

ARRAY FUNCTION array:CopyNotNil
  IN anArray
 [ anArray .for&gt; .KeepInStack ] 
 &gt;&gt;&gt; Result
; // array:CopyNotNil

elem_iterator ImplementsInDependencies
 Cached:
 (
  Self .Dependencies 
  .filter&gt; .IsImplements
  .mapToTarget&gt;
  array:Copy
 ) 
 &gt;&gt;&gt; Result
; // ImplementsInDependencies

elem_iterator ImplementsEx
 Self .Implements
 &gt;&gt;&gt; Result
; // ImplementsEx

elem_iterator ForClassImplements
 Self .ImplementsEx
 .filter&gt; .IsClassImplementable
 &gt;&gt;&gt; Result
; // ForClassImplements

elem_iterator ClassImplementsPrim
 Self .ForClassImplements 
 &gt;&gt;&gt; Result
; // ClassImplementsPrim

BOOLEAN elem_func InTie
 Cached:
 (
  RULES
   ( Self .IsNil )
    false
   ( Self .GetUP "gui" 'tie' ?== )
    true
   ( Self .Parent call.me )
    true 
   DEFAULT
    false
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // InTie

elem_iterator InterfaceForClassImplements
 Self .ForClassImplements 
 .filter&gt; ( .InTie ! )
 &gt;&gt;&gt; Result
; // InterfaceForClassImplements

ARRAY FUNCTION .joinWithLambded&gt;
  ARRAY IN anArrayToJoin
  ^ IN anArrayToIterate
  ^ IN aLambda
  
 anArrayToJoin 
 anArrayToIterate DO .for&gt; ( 
  IN aChild 
  VAR l_Other
  ( aChild aLambda DO ) &gt;&gt;&gt; l_Other
  if ( l_Other .IsNotNil ) then
  begin
   .join&gt; l_Other
  end // ( l_Other .IsNotNil )
 )
 &gt;&gt;&gt; Result
; // .joinWithLambded&gt;

BOOLEAN elem_func IsMixInOrMixInMirror
 RULES
  ( Self .IsMixIn )
   true
  ( Self .IsMixInMirror )
   true
  DEFAULT
   false
 ; // RULES   
 &gt;&gt;&gt; Result
; // IsMixInOrMixInMirror

BOOLEAN elem_func SomeAncestorImplements
  ModelElement IN anIntf
  
 BOOLEAN elem_func ImplementsLoc
  Self .ImplementsEx
  .filter&gt; ( anIntf .IsSameType ) 
  .NotEmpty &gt;&gt;&gt; Result
 ; // ImplementsLoc
 
 anIntf :Cached:
 (
  RULES
   ( Self .IsTypedef )
     RULES
      ( Self .IsPointer )
       false
      DEFAULT
       ( Self .MainAncestorPrim anIntf call.me )
     ; // RULES
   ( Self .InheritsEx .filter&gt; ( anIntf .IsSameType ) .NotEmpty )
    true 
   ( Self .InheritsEx .filter&gt; .ImplementsLoc .NotEmpty )
    true 
   ( Self .InheritsEx .filter&gt; ( anIntf call.me ) .NotEmpty )
    true 
   ( Self .ImplementsEx .filter&gt; .IsMixInOrMixInMirror .filter&gt; .ImplementsLoc .NotEmpty )
    true 
   ( Self .ImplementsEx .filter&gt; .IsMixInOrMixInMirror .filter&gt; ( anIntf call.me ) .NotEmpty )
    true 
   DEFAULT
    false  
  ; // RULES 
 )
 &gt;&gt;&gt; Result 
; // SomeAncestorImplements

elem_iterator ClassImplements
 (
  Self .ClassImplementsPrim
  .joinWithLambded&gt; ( Self .ClassImplementsPrim ) .InterfaceForClassImplements
 ) 
 .filter&gt; ( Self SWAP .SomeAncestorImplements ! )
 array:Copy
 &gt;&gt;&gt; Result
; // ClassImplements

INTERFACE elem_func OverrideMethod
 Cached:
 (
  Self .DecorateMethod:
  (
    IN aMethod
   aMethod -&gt; OpKind := opkind_Overridden
  ) // Self .DecorateMethod:
 )
 &gt;&gt;&gt; Result
; // OverrideMethod

INTERFACE elem_func ImplementMethod
 Cached:
 (
  Self .DecorateMethod:
  (
    IN aMethod
   aMethod -&gt; OpKind := opkind_Implemented
  ) // Self .DecorateMethod:
 )
 &gt;&gt;&gt; Result
; // ImplementMethod

INTERFACE elem_func DecorateType
 Cached:
 (
  Self .DecorateMethod:
  (
    IN aMethod
   aMethod -&gt; OpKind := opkind_DecoratedType
  ) // Self .DecorateMethod:
 )
 &gt;&gt;&gt; Result
; // DecorateType

INTERFACE FUNCTION MakeInOutParam
  STRING IN aName
  ModelElement IN aType
 aName aType MakeParam: ( 
   IN aMade
  aMade -&gt; Stereotype := st_inout
 ) 
 &gt;&gt;&gt; Result
; // MakeInOutParam

INTERFACE FUNCTION MakeClass:
  STRING IN aName
  ModelElement IN anAncestor
  ^ IN aLambda
 
 KeyValuesCreateAndDo: ( IN l_Param
  l_Param pop:Word:Box &gt;&gt;&gt; Result
  
  l_Param -&gt; Name := aName
  if ( anAncestor .IsNotNil ) then
  begin
   l_Param -&gt; Inherits := [ anAncestor ]
  end // ( anAncestor .IsNotNil )
  
  l_Param aLambda DO
 )
; // MakeClass:

INTERFACE FUNCTION MakeClass
  STRING IN aName
  ModelElement IN anAncestor
  
 aName anAncestor MakeClass: DROP 
 &gt;&gt;&gt; Result
; // MakeClass

CONST cImplementationUserCodeSuffix '_impl'
CONST cVarUserCodeSuffix '_var'
CONST cEmptyUserCode #1

CONST cUserCodePrefix 'uc:'

STRING FUNCTION cImplementationUserCodeName
 cUserCodePrefix cImplementationUserCodeSuffix Cat &gt;&gt;&gt; Result
; // cImplementationUserCodeName

STRING FUNCTION cVarUserCodeName
 cUserCodePrefix cVarUserCodeSuffix Cat &gt;&gt;&gt; Result
; // cVarUserCodeName

INTERFACE elem_func CastMethod
 Cached:
 (
  VAR l_TypeName
  Self .TypeName &gt;&gt;&gt; l_TypeName
  'As_' l_TypeName Cat Self MakeFunction: ( 
    IN aMade
   aMade -&gt; %SUM := ( 'Метод приведения нашего интерфейса к ' l_TypeName Cat )
   aMade -&gt; Visibility := ProtectedAccess
   aMade -&gt;^ cVarUserCodeName ^:= cEmptyUserCode
   aMade -&gt;^ cImplementationUserCodeName ^:= ' Result := Self;'
  ) 
 )
 &gt;&gt;&gt; Result
; // CastMethod

BOOLEAN elem_func IsStaticOp
 Self .IsStereotype st_static::Operation
 &gt;&gt;&gt; Result
; // IsStaticOp

BOOLEAN elem_func IsStaticMethod
 RULES
  ( Self .IsStaticOp )
   true
  ( Self .UPisTrue "is static" ) 
   true
  DEFAULT
   false 
 ; // RULES 
 &gt;&gt;&gt; Result
; // IsStaticMethod

elem_iterator InterfaceOwnOperations
 Self .OperationsEx
 .filter&gt; ( .IsStaticMethod ! )
 .joinWithLambded&gt; ( Self .InterfaceForClassImplements ) .ToArray: .CastMethod
 &gt;&gt;&gt; Result
; // InterfaceOwnOperations

elem_iterator InterfaceOperationsTotal
 Cached:
 (
  Self .InterfaceOwnOperations
  .joinWithLambded&gt; ( Self .ImplementsEx .filter&gt; .IsPureMixIn ) (
    IN anItem
   anItem call.me
   .joinWithLambded&gt; ( anItem .InheritsEx .filter&gt; .IsPureMixIn ) .InterfaceOwnOperations
  ) 
 ) 
 &gt;&gt;&gt; Result
; // InterfaceOperationsTotal

ModelElement elem_func MainImplements
 Cached:
 (
  Self .ImplementsEx
  .FirstElement
 )
 &gt;&gt;&gt; Result
; // MainImplements

BOOLEAN elem_func ImplementsIterator
 Cached:
 (
  RULES
   ( Self .MainImplements .IsNil )
    false
   ( Self .MainImplements .IsIterator )
    true 
   DEFAULT
    false
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // ImplementsIterator

BOOLEAN elem_func IsMethodAndImplementsIterator
 RULES
  ( Self .IsMethod ! )
   false
  ( Self .ImplementsIterator )
   true 
  DEFAULT
   false
 ; // RULES
 &gt;&gt;&gt; Result
; // IsMethodAndImplementsIterator

BOOLEAN elem_func SomeMethodImplementsThisIterator
  ModelElement IN anIterator
 RULES
  (
   Self .OperationsEx
   .filter&gt; .IsMethodAndImplementsIterator
   .map&gt; .MainImplements
   .filter&gt; ( anIterator .IsSameModelElement )
   .NotEmpty
  )
   true
  DEFAULT
   false
 ; // RULES
 &gt;&gt;&gt; Result 
; // SomeMethodImplementsThisIterator

elem_iterator InterfaceOperationsTotalDeep
 Self .InterfaceOperationsTotal
 
 .joinWithLambded&gt; ( Self .InheritsEx .filter&gt; .IsClassImplementable ) call.me
 
 &gt;&gt;&gt; Result
; // InterfaceOperationsTotalDeep

elem_iterator ImplementedEx
 Cached:
 (
  Self .Implemented
  
  if ( Self .IsClassOrMixIn ) then
  begin
   VAR l_OutedIterators
   [] &gt;&gt;&gt; l_OutedIterators
   
   .joinWithLambded&gt; ( Self .ClassImplements ) ( 
    .InterfaceOperationsTotalDeep 
    .filter&gt; ( .IsFacetIterator ! )
    .filter&gt; ( .IsIterator )
    .filter&gt; ( Self SWAP .SomeMethodImplementsThisIterator ! )
    .filter&gt; ( 
      IN anItem
     if ( anItem .NotInArray: l_OutedIterators ) then
     begin
      anItem .AddToArray: l_OutedIterators
      true
     end
     else
      false 
    ) // .filter&gt;
    .filter&gt; ( 
      IN anItem 
     Self .MainAncestor call.me .filter&gt; ( anItem .IsSameModelElement ) .IsEmpty
    ) // .filter&gt;
    .map&gt; .ImplementMethod 
    array:Copy
   )
  end // ( Self .IsClassOrMixIn )
 )
 &gt;&gt;&gt; Result
; // ImplementedEx

BOOLEAN elem_func IsFactoryAcceptable
 RULES
  ( Self .IsInterface )
   true
  ( Self .IsMixInParamType )
   true
  ( Self .IsArray )
   true 
  DEFAULT
   false 
 ; // RULES  
 &gt;&gt;&gt; Result
; // IsFactoryAcceptable

ModelElement elem_func MainImplementsInterface
 Cached:
 (
  Self .ImplementsEx
  .filter&gt; .IsFactoryAcceptable
  .FirstElement
 )
 &gt;&gt;&gt; Result
; // MainImplementsInterface

STRING elem_func UIDforUserCode
 RULES
  ( Self .IsIterator )
   RULES
    (
     ( Self .MainAncestor .IsNotNil )
     AND ( Self .MainAncestor .IsIterator )
    ) 
     ( Self .MainAncestor .LUID )
    DEFAULT
     ( Self .LUID )
   ; // RULES
  ( Self .IsMethodAndImplementsIterator )
   ( Self .MainImplements .LUID )
  DEFAULT
   ( Self .LUID )
 ; // RULES
 &gt;&gt;&gt; Result
; // UIDforUserCode

BOOLEAN elem_func IsResultType
 Self .IsStereotype st_result_type::Attribute
 &gt;&gt;&gt; Result
; // IsResultType

BOOLEAN elem_func IsElementType
 Self .IsStereotype st_element_type::Attribute
 &gt;&gt;&gt; Result
; // IsElementType

BOOLEAN elem_func IsIndexType
 Self .IsStereotype st_index_type::Attribute
 &gt;&gt;&gt; Result
; // IsIndexType

BOOLEAN elem_func IsServiceIterator
 Self .IsStereotype st_serviceiterator &gt;&gt;&gt; Result
; // IsServiceIterator

INTERFACE elem_func ItemParam
 Cached:
 (
  'anItem' Self MakeParam
 ) &gt;&gt;&gt; Result
; // ItemParam

INTERFACE elem_func IndexParam
 Cached:
 (
  'anIndex' Self MakeParam
 ) &gt;&gt;&gt; Result
; // IndexParam

BOOLEAN elem_func IsControlOverride
 Self .IsStereotype st_ControlOverride &gt;&gt;&gt; Result
; // IsControlOverride

BOOLEAN elem_func IsOverride
 RULES
  ( Self .IsControlOverride )
   true
  ( Self .IsIterator )
   RULES
    ( Self .MainAncestor .IsNil )
     false
    DEFAULT
     true 
   ; // RULES 
  DEFAULT
   false 
 ; // RULES
 &gt;&gt;&gt; Result
; // IsOverride

ModelElement elem_func IteratorAction
 Cached:
 (
  VAR l_Action
  Self .Action &gt;&gt;&gt; l_Action
  RULES
   ( l_Action .IsNotNil )
    l_Action
   ( Self .IsOverride )
    ( Self .MainAncestor call.me )
   DEFAULT
    begin
     [ Self .Parent .Name cUnderline Self .Name '_Action' ] strings:Cat 
     nil
     MakeFunction: (
       IN aMade
      aMade -&gt; UID := ( Self .LUID '_Action' Cat )  
      aMade -&gt; Parent := ( Self .Parent .WeakRef ) 
      aMade -&gt; Stereotype := st_Function
      aMade -&gt; %SUM := ( [ 
       'Тип подитеративной функции для ' Self .Parent .Name '.' Self .Name
       ] strings:Cat 
      )
      //aMade -&gt; Parameters := [ GarantModel::Pointer .ActionParamPrim ]
      aMade -&gt; Visibility := PublicAccess
      aMade -&gt; Operations := [
       'DoIt' GarantModel::Boolean MakeFunction: (
         IN aMadeOp
        aMadeOp -&gt; Parameters := [ 
         Self .Attributes
         .filter&gt; .IsElementType
         .mapToTarget&gt;
         .FirstElement
         .ItemParam
         
         if ( Self .UPisTrue "needs index" ) then
         begin
          VAR l_IndexType
          Self .Attributes
          .filter&gt; .IsIndexType
          .mapToTarget&gt;
          .FirstElement &gt;&gt;&gt; l_IndexType
          
          if ( l_IndexType .IsNil ) then
          begin
           GarantModel::Integer &gt;&gt;&gt; l_IndexType
          end // ( l_IndexType .IsNil )
          
          l_IndexType .IndexParam
         end // ( Self .UPisTrue "needs index" )
        ] // aMadeOp -&gt; Parameters
       ) // 'DoIt' GarantModel::Boolean MakeFunction: 
      ] // aMade -&gt; Operations
     ) // MakeFunction: 
    end // DEFAULT
  ; // RULES  
 ) &gt;&gt;&gt; Result
; // IteratorAction

INTERFACE elem_func ActionParamPrim
 Cached:
 (
  'anAction' Self MakeParam
 ) &gt;&gt;&gt; Result
; // ActionParamPrim

INTERFACE elem_func ActionParam
 Cached:
 (
  Self .IteratorAction .ActionParamPrim
 ) &gt;&gt;&gt; Result
; // ActionParam

ModelElement elem_func IteratorStub
 Cached:
 (
  VAR l_Stub
  Self .Stub &gt;&gt;&gt; l_Stub
  RULES
   ( l_Stub .IsNotNil )
    l_Stub
   ( Self .IsServiceIterator )
    begin
     VAR l_MixIn
     Self .Parent .MixIn &gt;&gt;&gt; l_MixIn
     l_MixIn .OperationsEx
     .filter&gt; .IsIterator
     .filter&gt; ( .IsServiceIterator ! )
     .filter&gt; ( .Name Self .Name 'F' Cat ?== )
     .FirstElement 
     call.me
    end // ( Self .IsServiceIterator )
   ( Self .IsOverride )
    ( Self .MainAncestor call.me )
   DEFAULT
    begin
     [ 'L2_' Self .Parent .Name cUnderline Self .Name '_Action' ] strings:Cat Self .IteratorAction MakeFunction: (
       IN aMade
      aMade -&gt; UID := ( Self .LUID '_Stub' Cat )  
      aMade -&gt; Parent := ( Self .Parent .WeakRef ) 
      aMade -&gt; Stereotype := st_static::Operation
      aMade -&gt; %SUM := ( [ 
       'Функция формирования заглушки для ЛОКАЛЬНОЙ подитеративной функции для ' Self .Parent .Name '.' Self .Name
       ] strings:Cat 
      )
      aMade -&gt; Parameters := [ GarantModel::Pointer .ActionParamPrim ]
      aMade -&gt; Visibility := PublicAccess
      aMade -&gt; 'extprop:isGlobal' := true
      aMade -&gt; 'extprop:isAsm' := true
     ) // MakeFunction: 
    end // DEFAULT
  ; // RULES  
 ) &gt;&gt;&gt; Result
; // IteratorStub

BOOLEAN elem_func IsInParam
 Self .IsStereotype st_in::Attribute &gt;&gt;&gt; Result
; // IsInParam

BOOLEAN elem_func IsControlPrim
 Self .IsStereotype st_ControlPrim &gt;&gt;&gt; Result
; // IsControlPrim

BOOLEAN elem_func IsContract
 Self .IsStereotype st_Contract &gt;&gt;&gt; Result
; // IsContract

USES
 string.ms.dict
;

STRING FUNCTION RemoveDuplicatedIfDef
  STRING IN aValue
 cEmptyStr &gt;&gt;&gt; Result 
 ARRAY VAR l_Outed
 [] &gt;&gt;&gt; l_Outed
 aValue ',' string:Split:for&gt; (
   IN aSubstr
  aSubstr string:Trim &gt;&gt;&gt; aSubstr
  if ( aSubstr .IsNotNil ) 
   if ( aSubstr .TextNotInArray: l_Outed ) then
   begin
    aSubstr .AddToArray: l_Outed
    if ( Result .IsNil ) then
     ( aSubstr &gt;&gt;&gt; Result )
    else
     ( Result ',' aSubstr Cat Cat &gt;&gt;&gt; Result )
   end // ( aSubstr .TextNotInArray: l_Outed )
 ) // aValue ',' string:Split:for&gt;
; // RemoveDuplicatedIfDef

ModelElement CompileTime-VAR g_Implementor nil

FORWARD .MainAncestorThatNotMixIn

STRING elem_func IfDefStr
 Cached:
 (
  Self .GetUP "ifdef" &gt;&gt;&gt; Result
  
  VAR l_Parent
  Self .Parent &gt;&gt;&gt; l_Parent
  if ( l_Parent .IsNotNil ) then
  begin
   VAR l_ParentIfDefStr
   l_Parent call.me &gt;&gt;&gt; l_ParentIfDefStr
   if ( l_ParentIfDefStr .IsNotNil ) then
   begin
    if ( Result .IsNil ) then
    begin
     l_ParentIfDefStr &gt;&gt;&gt; Result
    end // ( Result .IsNil )
    else
    begin
     l_ParentIfDefStr ',' Result Cat Cat &gt;&gt;&gt; Result
    end // ( Result .IsNil )
   end // ( l_ParentIfDefStr .IsNotNil )
  end // ( l_Parent .IsNotNil )
  Result RemoveDuplicatedIfDef
 )
 &gt;&gt;&gt; Result 
; // IfDefStr

STRING elem_func IfNDefStr
 Cached:
 (
  Self .GetUP "ifndef" &gt;&gt;&gt; Result
  
  VAR l_Parent
  Self .Parent &gt;&gt;&gt; l_Parent
  if ( l_Parent .IsNotNil ) then
  begin
   VAR l_ParentIfDefStr
   l_Parent call.me &gt;&gt;&gt; l_ParentIfDefStr
   if ( l_ParentIfDefStr .IsNotNil ) then
   begin
    if ( Result .IsNil ) then
    begin
     l_ParentIfDefStr &gt;&gt;&gt; Result
    end // ( Result .IsNil )
    else
    begin
     l_ParentIfDefStr ',' Result Cat Cat &gt;&gt;&gt; Result
    end // ( Result .IsNil )
   end // ( l_ParentIfDefStr .IsNotNil )
  end // ( l_Parent .IsNotNil )
  Result RemoveDuplicatedIfDef
 )
 &gt;&gt;&gt; Result 
; // IfNDefStr

ModelElement elem_func FriendClass
 Cached:
 (
  VAR l_TypeName
  Self .TypeName &gt;&gt;&gt; l_TypeName
  l_TypeName 'Friend' Cat Self MakeClass: (
    IN aMade
   aMade -&gt; Stereotype := st_SimpleClass
   aMade -&gt; %SUM := ( 'Друг к классу ' l_TypeName Cat )
   aMade -&gt; Visibility := PrivateAccess
   aMade -&gt; Abstraction := at_abstract
   aMade -&gt; "ifdef" := ( Self .IfDefStr )
   aMade -&gt; "ifndef" := ( Self .IfNDefStr )
   aMade -&gt; "register in scripts" := false
  )
 )
 &gt;&gt;&gt; Result
; // FriendClass

ModelElement elem_func EffectiveType
 Cached:
 (
  RULES
   ( Self .UPisTrue "is friend" )
    ( Self .MainAncestor .FriendClass ) 
   DEFAULT
    ( Self .MainAncestor ) 
  ; // RULES  
 )
 &gt;&gt;&gt; Result
; // EffectiveType

ModelElement elem_func SelfParam
 Cached:
 (
  'Self' Self MakeParam
 )
 &gt;&gt;&gt; Result
; // SelfParam

CONST opModifyNone 1
CONST opModifySetter 2
CONST opModifyIteratorF 3
CONST opModifyTest 4
CONST opModifyExecute 5
CONST opModifyGetState 6

INTEGER elem_func OpModify
 Self 'OpModify' opModifyNone .ElemMember &gt;&gt;&gt; Result
; // OpModify

BOOLEAN elem_func IsIteratorF
 Self .OpModify opModifyIteratorF ==
 &gt;&gt;&gt; Result
; // IsIteratorF

BOOLEAN elem_func IsWriteonlyProperty
 Self .IsStereotype st_writeonly::Attribute 
 &gt;&gt;&gt; Result
; // IsWriteonlyProperty

BOOLEAN elem_func IsSetter
 RULES
  ( Self .IsWriteonlyProperty ) 
   true
  ( Self .OpModify opModifySetter == )
   true 
  DEFAULT
   false
 ; // RULES
 &gt;&gt;&gt; Result
; // IsSetter

BOOLEAN elem_func IsTester
 Self .OpModify opModifyTest == &gt;&gt;&gt; Result
; // IsTester

BOOLEAN elem_func IsExecutor
 Self .OpModify opModifyExecute == &gt;&gt;&gt; Result
; // IsExecutor

BOOLEAN elem_func IsGetState
 Self .OpModify opModifyGetState == &gt;&gt;&gt; Result
; // IsGetState

BOOLEAN elem_func IsVCMOperationPrim
 RULES
  ( Self .IsStereotype st_VCMOperationPrim )
   true
  ( 
   ( Self .Parent .IsNotNil ) 
   AND ( Self .Parent .IsVCMOperations )
  ) 
   true
  DEFAULT
   false 
 ; // RULES
 &gt;&gt;&gt; Result
; // IsVCMOperationPrim

BOOLEAN elem_func IsInternalOperation
 Self .IsStereotype st_InternalOperation::Operation &gt;&gt;&gt; Result
; // IsInternalOperation

INTERFACE elem_func ParamsParam
 Cached:
 (
  'aParams' Self MakeParam
 ) 
 &gt;&gt;&gt; Result
; // ParamsParam

INTERFACE elem_func StateParam
 Cached:
 (
  'State' Self MakeInOutParam
 ) 
 &gt;&gt;&gt; Result
; // StateParam

BOOLEAN elem_func IsFactoryMethod
 Self .IsStereotype st_Factory
 &gt;&gt;&gt; Result
; // IsFactoryMethod

BOOLEAN elem_func IsFactory
  RULES
   ( Self .IsStereotype st_factory::Operation )
    true
   ( Self .IsFactoryMethod )
    true
   DEFAULT
    false
  ; //RULES   
 &gt;&gt;&gt; Result
; // IsFactory

ARRAY elem_func MethodParameters
 Cached:
 (
  RULES
   ( Self .IsVCMOperationPrim )
    RULES
     ( Self .IsTester )
      ( GarantModel::IvcmTestParamsPrim .ParamsParam .ToArray )
     ( Self .IsExecutor )
      RULES
       ( Self .IsInternalOperation )
        ( Self .Parameters )
       DEFAULT
        ( GarantModel::IvcmTestExecutePrim .ParamsParam .ToArray )
      ; // RULES  
     ( Self .IsGetState )
      ( GarantModel::TvcmOperationStateIndex .StateParam .ToArray )
     ( Self .IsInternalOperation ) 
      ( GarantModel::IvcmTestExecutePrim .ParamsParam .ToArray )
     DEFAULT
      ( Self .Parameters )
    ; // RULES 
   ( Self .Parent .IsTestClass )
    (
     [ Self .Parent .EffectiveType .SelfParam ]
     .join&gt;
     ( Self .Parameters )
    )
   ( Self .IsIterator )
    (
     RULES
      ( Self .MainAncestor .IsNotNil )
       ( Self .MainAncestor call.me )
      DEFAULT
       (
        [ Self .ActionParam ]
        .join&gt; (
         Self .Attributes
         .filter&gt; .IsInParam
        ) // .join&gt;
       ) // DEFAULT
     ; // RULES
    ) 
   ( Self .IsFactoryMethod )
    RULES
     ( Self .MainAncestor .IsNotNil )
      ( Self .MainAncestor call.me )
     DEFAULT
      ( Self .FirstOperation .Parameters )
    ; // RULES  
   ( Self .IsMethod )
    RULES
     ( Self .ImplementsIterator )
      ( Self .MainImplements call.me )
     ( Self .MainAncestor .IsNotNil )
      RULES 
       ( Self .FirstOperation .IsNotNil )
        RULES
         (
          ( Self .FirstOperation .IsSummoned )
          AND ( Self .Abstraction at_regular == )
         ) 
          ( Self .MainAncestor call.me ) 
         DEFAULT
          ( Self .FirstOperation .Parameters )
        ; // RULES 
       DEFAULT
        ( Self .MainAncestor call.me )
      ; // RULES 
     DEFAULT
      ( Self .FirstOperation .Parameters )
    ; // ( Self .IsMethod )
   ( Self .IsFunction )
    ( Self .FirstOperation .Parameters )
   DEFAULT 
    ( Self .Parameters )
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // MethodParameters

elem_iterator PropertyKeys
 RULES
  ( Self .Parent .IsTestClass )
   (
    [ Self .Parent .EffectiveType .SelfParam ]
    .join&gt;
    ( Self .Attributes )
   )
  DEFAULT 
   ( Self .Attributes )
 ; // RULES  
 .filter&gt; ( .IsControlPrim ! )
 &gt;&gt;&gt; Result
; // PropertyKeys

ARRAY FUNCTION .With()&gt;
  OUTABLE IN aValue
  ^ IN aLambda
 RULES 
  ( aValue .IsNil )
   [empty]
  ( aValue IsArray )
   (
    [
     VAR l_WasBracket
     false &gt;&gt;&gt; l_WasBracket
     aValue 
     .filterNil&gt; 
     .for&gt; (
       IN anItem
      if ( l_WasBracket ! ) then
      begin
       '('
       true &gt;&gt;&gt; l_WasBracket
      end
      anItem aLambda DO
     ) // aValue .for&gt;
     if l_WasBracket then
     begin
      ')'
     end 
    ]
   ) // ( aValue IsArray )
  DEFAULT 
   [ '(' aValue aLambda DO ')' ]
 ; // RULES
 &gt;&gt;&gt; Result
; // .With()

ARRAY FUNCTION .With()
  OUTABLE IN aValue
 aValue .With()&gt; .KeepInStack &gt;&gt;&gt; Result 
; // .With()

ARRAY FUNCTION .CommaListWith()
  ARRAY IN aList
 [
  VAR l_WasComma
  false &gt;&gt;&gt; l_WasComma
  aList .for&gt; ( 
   .WithComma: l_WasComma .KeepInStack
  )
 ] .With() &gt;&gt;&gt; Result
; // .CommaListWith()
  
ARRAY elem_func ParametersList
 Cached:
 (
  Self .MethodParameters .map&gt; .Name .CommaListWith()
 )
 &gt;&gt;&gt; Result
; // ParametersList

CONST cUCStart '//#UC START# *'
CONST cUCEnd '//#UC END# *'

PROCEDURE ReadUCFromFile
  STRING IN aFileName
  STRING IN aCurrentGeneratedElementPrefix
 if ( aFileName sysutils:FileExists ) then
 begin
  FILE VAR l_In
  aFileName TryOpen: File:OpenRead &gt;&gt;&gt; l_In
  TRY
   VAR l_UCOpened
   ARRAY VAR l_Accumulated
   STRING VAR l_Key
   
   false &gt;&gt;&gt; l_UCOpened
   l_In File:ReadLines (
     IN aStr
     
    VAR l_Pos
    
    : Has
     string:Pos &gt;&gt;&gt; l_Pos
     l_Pos -1 !=
    ; // Has
     
    RULES 
     ( aStr cUCStart Has )
      ( 
       l_UCOpened ! ?ASSURE [ 'Секция кода уже открыта. Файл: ' aFileName ' строка:' aStr ]
       true &gt;&gt;&gt; l_UCOpened
       aStr string:Trim &gt;&gt;&gt; aStr
       [] &gt;&gt;&gt; l_Accumulated
       
       aStr &gt;&gt;&gt; l_Key
       '*' string:SplitTo! l_Key DROP
       
      )
     ( aStr cUCEnd Has )
      ( 
       l_UCOpened ?ASSURE [ 'Секция кода не открыта. Файл: ' aFileName ' строка:' aStr  ]
       false &gt;&gt;&gt; l_UCOpened
       
       VAR l_Head
       if ( l_Pos &gt; 0 ) then
       begin
        l_Pos 0 aStr string:Substring &gt;&gt;&gt; l_Head
        if ( l_Head string:TrimLeft .IsNotNil ) then
        begin
         l_Head .AddToArray: l_Accumulated
         
         aStr string:Len l_Pos - 
         l_Pos 
         aStr 
         string:Substring &gt;&gt;&gt; aStr
        end // ( l_Head .IsNotNil )
       end // ( l_Pos &gt; 0 )
       
       aStr string:Trim &gt;&gt;&gt; aStr
       
       g_CurrentGenerator -&gt;^ l_Key ^:= l_Accumulated
       g_CurrentGenerator -&gt;^ ( aCurrentGeneratedElementPrefix l_Key Cat ) ^:= l_Accumulated
       
       nil &gt;&gt;&gt; l_Accumulated
      )
     DEFAULT
      (
       l_UCOpened ? ( 
        aStr .AddToArray: l_Accumulated
       ) // l_UCOpened ?
      ) 
    ; // RULES  
   ) // l_In File:ReadLines
  FINALLY
   nil &gt;&gt;&gt; l_In
  END // TRY..FINALLY
 end // ( aFileName sysutils:FileExists )
; // ReadUCFromFile

CONST cPalka '|'

elem_proc OutUserCode:
  STRING IN aKey
  ^ IN aOutExisting
  ^ IN aOutNew
  
 BOOLEAN VAR l_Found
 false &gt;&gt;&gt; l_Found
 
 if ( g_UCRead ! ) then
 begin
  true &gt;&gt;&gt; g_UCRead
  STRING VAR l_TempFileName
  g_TempFileName '.uc.txt' Cat &gt;&gt;&gt; l_TempFileName 
  STRING VAR l_RealFileName
  g_RealFileName '.uc.txt' Cat &gt;&gt;&gt; l_RealFileName
  
  STRING VAR l_CurrentGeneratedElementPrefix
  [ cUserCodePrefix g_CurrentGeneratedElement .LUID cPalka ] strings:Cat &gt;&gt;&gt; l_CurrentGeneratedElementPrefix
  
  l_RealFileName l_CurrentGeneratedElementPrefix ReadUCFromFile
  g_FinalFileNameForUC l_CurrentGeneratedElementPrefix ReadUCFromFile

  FILE VAR l_Out
  l_TempFileName MakePathAndOpenWrite &gt;&gt;&gt; l_Out
  TRY
   g_CurrentGenerator MembersIterator 
   .filter&gt; ( .WordName l_CurrentGeneratedElementPrefix SWAP StartsStr )
   .for&gt; (
     IN anItem
    STRING VAR l_Key 
    anItem .WordName cPalka string:Split &gt;&gt;&gt; l_Key DROP
    
    cUCStart l_Out File:WriteStr
    l_Key l_Out File:WriteWStrLn
    
    anItem DO .for&gt; ( l_Out File:WriteWStrLn )
     
    cUCEnd l_Out File:WriteStr
    l_Key l_Out File:WriteWStrLn
     
   ) // g_CurrentGenerator MembersIterator
  FINALLY
   nil &gt;&gt;&gt; l_Out
  END // TRY..FINALLY
  l_RealFileName l_TempFileName false CopyChangedFile
  
  if ( l_RealFileName FileSize 0 == ) then
  begin
   l_RealFileName false DoDeleteFile
  end // ( l_RealFileName FileSize 0 == )
  
 end //( g_UCRead ! ) 
 
 l_Found ! ? (
  VAR l_Field
  g_CurrentGenerator %% aKey &gt;&gt;&gt; l_Field
  if ( l_Field .IsNil ) then
  begin
   aKey aOutNew DO
  end // ( l_Field .IsNil )
  else
  begin
   aKey l_Field DO aOutExisting DO
  end // ( l_Field .IsNil )
 ) // l_Found ! ?
; // OutUserCode:

elem_proc DefaultUserCodePrim:
  STRING IN aSuffix
  STRING IN aKey
  ^ IN aOutNew
  
 VAR l_KeyStart 
 Self .UIDforUserCode &gt;&gt;&gt; l_KeyStart
 
 l_KeyStart aKey Cat &gt;&gt;&gt; aKey
 aKey '*' Cat &gt;&gt;&gt; aKey
 
 Self aKey .OutUserCode: (
   IN aKey
   IN aValue
  [ cUCStart aKey ] .Out
  aValue .for&gt; ( g_OutFile File:WriteWStrLn )
  [ cUCEnd aKey ] .Out
 ) (
   IN aKey
  VAR l_Field
  nil &gt;&gt;&gt; l_Field 
  
  if ( aSuffix .NotIsNil ) then
  begin
   // - вообще говоря тут затычка для переноса слов скрипта в новый генератор
   if ( [ l_KeyStart cUnderline l_KeyStart ] strings:Cat aKey StartsStr ) then
   // - проверяем, что это слово скрипта у которого родитель поменял UID
   // - тут ещё надо KeywordObjectToOperate проверять
   begin
    g_CurrentGenerator MembersIterator 
    .filter&gt; ( .WordName l_KeyStart SWAP StartsStr )
    .filter&gt; ( .WordName aSuffix '*' Cat SWAP EndsStr )
    .FirstElement &gt;&gt;&gt; l_Field
   end
  end // ( aSuffix .NotIsNil )
  
  if ( l_Field .IsNil ) then
  begin
   aKey aOutNew DO
  end // ( l_Field .IsNil )
  else
  begin
   [ cUCStart aKey ] .Out
   l_Field DO .for&gt; ( g_OutFile File:WriteWStrLn )
   [ cUCEnd aKey ] .Out
   //l_Field .WordName Msg
  end // ( l_Field .IsNil )
 ) // Self aKey .OutUserCode:
; // DefaultUserCodePrim:

elem_proc DefaultUserCode
  STRING IN aSuffix
  STRING IN aKey
  TtfwWord IN aCode
 Self aSuffix aKey .DefaultUserCodePrim: (
   IN aKey
  [ cUCStart aKey ] .Out
  [ aCode DO ] .Out
  [ cUCEnd aKey ] .Out
 ) // Self aKey .OutUserCode:
; // DefaultUserCode

elem_proc PredefinedUserCode:
  STRING IN aSuffix
  STRING IN aKey
  ^ IN aOutLambda
  ^ IN aCode
 Self aSuffix aKey .DefaultUserCodePrim: (
   IN aKey
  [ aCode DO ] aOutLambda DO
 ) // Self aKey .OutUserCode:
; // PredefinedUserCode:

elem_proc PredefinedMethodUserCode:
  STRING IN aSuffix
  STRING IN aKey
  TtfwWord IN aCode
  ^ IN aVarCode
  ^ IN aImplCode
 RULES
  ( aSuffix cVarUserCodeSuffix == )
   ( Self aSuffix aKey .PredefinedUserCode: .Out ( aVarCode DO ) )
  ( aSuffix cImplementationUserCodeSuffix == )
   ( Self aSuffix aKey .PredefinedUserCode: ( IN aValue Indented: ( aValue .Out ) ) ( aImplCode DO ) )
  DEFAULT 
   ( Self aSuffix aKey aCode .DefaultUserCode )
 ; // RULES
; // PredefinedMethodUserCode:

elem_proc PredefinedMethodUserCodeWithoutVar:
  STRING IN aSuffix
  STRING IN aKey
  TtfwWord IN aCode
  ^ IN aImplCode
 Self aSuffix aKey aCode .PredefinedMethodUserCode: () ( aImplCode DO ) 
; // PredefinedMethodUserCodeWithoutVar:
  
ModelElement elem_func ImplementorOrParent
 //Cached:
 (
  g_Implementor &gt;&gt;&gt; Result
  
  if ( Result .IsNil ) then
  begin
   Self .Parent &gt;&gt;&gt; Result
  end // ( Result .IsNil )
  Result
 )
 &gt;&gt;&gt; Result
; // ImplementorOrParent

BOOLEAN elem_func IsReadonlyProperty
 Self .IsStereotype st_readonly::Attribute &gt;&gt;&gt; Result
; // IsReadonlyProperty

BOOLEAN elem_func IsProperty
 Cached:
 (
  RULES
   ( Self .IsStereotype st_property::Attribute )
    true
   ( Self .IsReadonlyProperty )
    true
   ( Self .IsWriteonlyProperty )
    true
   DEFAULT
    false 
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // IsProperty

INTERFACE elem_func InterfaceLinkField
 Cached:
 (
  VAR l_TypeName
  Self .TypeName &gt;&gt;&gt; l_TypeName
  'f_' l_TypeName Cat Self MakeField: ( 
    IN aMade
   aMade -&gt; %SUM := ( 'Ссылка на интерфейс ' l_TypeName Cat )
   aMade -&gt; Visibility := PrivateAccess
  ) 
 )
 &gt;&gt;&gt; Result
; // InterfaceLinkField

BOOLEAN elem_func IsAutoHelper
 Self .UPisTrue "IsAutoHelper" &gt;&gt;&gt; Result
; // IsAutoHelper

STRING elem_func FieldName
 RULES
  ( Self .IsProperty )
   ( 'f_' Self .Name Cat )
  DEFAULT
   ( Self .Name )
 ; // RULES
 &gt;&gt;&gt; Result
; // FieldName

BOOLEAN elem_func HasFieldName
  STRING IN aName
 Self .FieldName aName == 
 &gt;&gt;&gt; Result
; // HasFieldName

elem_iterator Properties
 Cached:
 (
  VAR l_Properties
  Self .Attributes 
  .filter&gt; .IsProperty
  .filter&gt; ( .IsControlOverride ! )  
  &gt;&gt;&gt; l_Properties
  
  l_Properties
  
  if ( Self .IsService ) then
  begin
   VAR l_Facet
   Self .Facet &gt;&gt;&gt; l_Facet
   if ( l_Facet .IsNotNil ) then
   begin
    if ( l_Properties 'Alien' .HasModelElementWithName ! ) then
    begin
     VAR l_TypeName
     l_Facet .TypeName &gt;&gt;&gt; l_TypeName
     .join&gt;
     [
      'Alien' l_Facet MakeProperty: ( 
        IN aMade
       aMade -&gt; %SUM := ( 'Внешняя реализация сервиса ' l_TypeName Cat )
       aMade -&gt; Visibility := PublicAccess
       aMade -&gt; Stereotype := st_writeonly::Attribute
       aMade -&gt; Abstraction := at_final
       aMade -&gt; LinkType := lt_ref
       aMade -&gt; "pm" := true
       aMade -&gt; "needs field" := true
      ) // 'Alien' l_Facet MakeProperty:
     ] // .join&gt;
    end // ( l_Properties 'Alien' .HasModelElementWithName ! )
   end // ( l_Facet .IsNotNil )
  end // ( Self .IsService )
 )
 &gt;&gt;&gt; Result
; // Properties

BOOLEAN elem_func NeedPutToDFM
 Cached:
 (
  Self .UPisTrue "put to dfm" &gt;&gt;&gt; Result
  if Result then
  begin
   if ( Self .Parent .IsControlPrim ) then
   begin
    Self .Parent call.me &gt;&gt;&gt; Result
   end // ( Self .Parent .IsControlPrim )
  end // Result
  Result
 )
 &gt;&gt;&gt; Result
; // NeedPutToDFM

BOOLEAN elem_func ReadsField
 RULES
  ( Self .IsControlPrim )
   ( Self .NeedPutToDFM ! )
  ( Self .IsWriteonlyProperty ) 
   true
  ( Self .UPisTrue "reads field" )
   true
  DEFAULT
   false 
 ; // RULES
 &gt;&gt;&gt; Result
; // elem_func ReadsField

BOOLEAN elem_func WritesField
 RULES
  ( Self .IsReadonlyProperty )
   true
  ( Self .UPisTrue "writes field" )
   true
  DEFAULT
   false 
 ; // RULES 
 &gt;&gt;&gt; Result
; // elem_func WritesField

BOOLEAN elem_func NeedsField
 RULES
  ( Self .IsOverride )
   false
  ( Self .IsControlPrim )
   RULES
    ( Self .NeedPutToDFM )
     false
    DEFAULT
     true 
   ; // RULES 
  ( Self .UPisTrue "reads field" )
   true
  ( Self .UPisTrue "writes field" )
   true
  ( Self .Parent .IsInterface ) 
   RULES
    ( Self .UPisTrue "needs field" )
     true
    DEFAULT
     false 
   ; // RULES
  ( Self .Abstraction at_abstract == ) 
   false
  ( Self .UPisTrue "needs field" )
   true
  DEFAULT
   false
 ; // RULES
 &gt;&gt;&gt; Result
; // NeedsField

BOOLEAN elem_func CanMapPropertiesToFields
 RULES
  ( Self .IsClassOrMixIn )
   true
  ( Self .IsException )
   true
  DEFAULT
   false
 ; // RULES
 &gt;&gt;&gt; Result
; // CanMapPropertiesToFields

elem_iterator Fields
 Cached:
 (
  VAR l_Fields
  Self .Attributes
  .filter&gt; ( .IsProperty ! )
  .filter&gt; ( .IsStereotype st_impurity_value::Attribute ! )
  .filter&gt; ( .IsStereotype st_switch::Attribute ! )
  .filter&gt; ( .IsStereotype st_impurity_param::Attribute ! )
  .filter&gt; ( .IsStereotype st_static::Attribute ! )
  &gt;&gt;&gt; l_Fields
  
  if ( Self .CanMapPropertiesToFields ) then
  begin
   l_Fields array:Copy &gt;&gt;&gt; l_Fields
   l_Fields
   .joinWithLambded&gt; (
    Self .Properties 

    .join&gt; ( 
     Self .Implemented 
     .filter&gt; .IsProperty
     .filter&gt; ( .Parent .IsInterface ) 
    ) // .join&gt;
    .filter&gt; .NeedsField
    .filter&gt; ( 
      IN anItem 
     l_Fields .HasSomeOf: ( anItem .FieldName .HasName ) !
//     l_Fields .HasSomeOf: ( anItem .FieldName .HasFieldName ) !
    ) // .filter&gt;
   ) .ToArray
  end // ( Self .CanMapPropertiesToFields )
  else
   l_Fields
  
  if ( Self .IsStaticObject ) then
  begin
   if ( Self .IsAutoHelper ) then
   begin
    .joinWithLambded&gt; ( Self .ImplementsEx ) .ToArray: .InterfaceLinkField
   end // ( Self .IsAutoHelper )
  end // ( Self .IsStaticObject )
 )
 &gt;&gt;&gt; Result
; // Fields

BOOLEAN elem_func IsSingleton
 Self .UPisTrue "singleton" &gt;&gt;&gt; Result
; // IsSingleton

BOOLEAN elem_func HasFactory
 Cached:
 (
  Self .OperationsEx
  .filter&gt; .IsFactory 
  .NotEmpty
 ) 
 &gt;&gt;&gt; Result
; // HasFactory

INTERFACE elem_func InstanceField
 Cached:
 (
  VAR l_TypeName
  Self .TypeName &gt;&gt;&gt; l_TypeName
  
  'g_' l_TypeName Cat 
   if ( Self .HasFactory ) then
    GarantModel::Pointer
   else
    Self 
  MakeField: ( 
    IN aMade
   aMade -&gt; %SUM := ( 'Экземпляр синглетона ' l_TypeName Cat )
   aMade -&gt; Visibility := PrivateAccess
   aMade -&gt; 'extprop:pas:Value' := 'nil'
   aMade -&gt; "ifdef" := ( Self .IfDefStr )
   aMade -&gt; "ifndef" := ( Self .IfNDefStr )
  )
 )
 &gt;&gt;&gt; Result
; // InstanceField

BOOLEAN elem_func IsLocalVar
 Self .IsStereotype st_var::Attribute &gt;&gt;&gt; Result
; // IsLocalVar

BOOLEAN elem_func IsGlobalVar
 Self .IsStereotype st_globalvar::Attribute &gt;&gt;&gt; Result
; // IsGlobalVar

elem_iterator InnerGlobalVars
 Self .Attributes
 .filter&gt; .IsGlobalVar
 .joinWithLambded&gt; ( Self .OperationsEx ) call.me
 &gt;&gt;&gt; Result
; // InnerGlobalVars

elem_iterator GlobalVars
 RULES
  ( Self .IsClassOrMixIn )
   (
    Self .Attributes
    .filter&gt; ( .IsStereotype st_static::Attribute )
    if ( Self .IsSingleton ) then
    begin
     .join&gt; ToArray: ( Self .InstanceField )
    end // ( Self .IsSingleton )
    .join&gt; ( Self .InnerGlobalVars )
   )
  ( Self .IsUtilityPack ) 
   (
    Self .Attributes
    .filter&gt; ( .IsProperty ! )
    .join&gt; ( Self .InnerGlobalVars )
   )
  DEFAULT
   [empty] 
 ; // RULES
 &gt;&gt;&gt; Result
; // GlobalVars

BOOLEAN elem_func IsWideString
 Cached:
 (
  RULES
   ( Self .Name 'a-string' == )
    false
   ( Self .Name 'a-wstring' == )
    true
   ( Self .IsTypedef )
    RULES
     ( Self .IsPointer )
      false
     DEFAULT
      ( Self .MainAncestor call.me )
    ; // RULES  
   DEFAULT
    false
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // IsWideString

BOOLEAN elem_func IsString
 Cached:
 (
  RULES
   ( Self .Name 'a-string' == )
    true
   ( Self .IsWideString )
    true
   ( Self .IsTypedef )
    RULES
     ( Self .IsPointer )
      false
     DEFAULT
      ( Self .MainAncestor call.me )
    ; // RULES  
   DEFAULT
    false
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // IsString

BOOLEAN elem_func IsUntyped
 Self .Name 'void' == &gt;&gt;&gt; Result
; // IsUntyped

BOOLEAN elem_func IsManaged
 Cached:
 (
  RULES
   ( Self .IsRecord )
    true
   ( Self .IsUnion )
    true
   ( Self .IsArray )
    true
   ( Self .IsInterface )
    true
   ( Self .IsTypedef )
    RULES
     ( Self .IsPointer )
      false
     DEFAULT
      ( Self .MainAncestor call.me )
    ; // RULES  
   ( Self .IsMixInParamType )
    true
   ( Self .IsString )
    true
   ( Self .IsUntyped )
    true
   DEFAULT
    false
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // IsManaged

BOOLEAN elem_func IsConstants
 Self .IsStereotype st_Constants &gt;&gt;&gt; Result
; // IsConstants

BOOLEAN elem_func IsSetConst
 Self .IsStereotype st_SetConst &gt;&gt;&gt; Result
; // IsSetConst

BOOLEAN elem_func IsConstantArray
 Self .IsStereotype st_ConstantArray &gt;&gt;&gt; Result
; // IsConstantArray

BOOLEAN elem_func IsLocalConst
 Self .IsStereotype st_LocalConst &gt;&gt;&gt; Result
; // IsLocalConst

BOOLEAN elem_func IsChoices
 Self .IsStereotype st_Choices
 &gt;&gt;&gt; Result
; // IsChoices

BOOLEAN elem_func IsChoice
 Self .IsStereotype st_Choice
 &gt;&gt;&gt; Result
; // IsChoice

BOOLEAN elem_func IsConstantsButNotType
 RULES
  ( Self .IsRange )
   false
  ( Self .IsConstants )
   true
  ( Self .IsSetConst )
   true
  ( Self .IsConstantArray )
   true
  ( Self .IsLocalConst )
   true
  ( Self .IsMessage )
   true
  ( Self .IsChoices )
   true
  ( Self .IsChoice )
   true
  DEFAULT
   false 
 ; // RULES
 &gt;&gt;&gt; Result  
; // IsConstantsButNotType

BOOLEAN elem_func IsType
 Cached:
 (
  RULES
   ( Self .MDAClass class_Operation == )
    false
   ( Self .MDAClass class_Attribute == )
    false
   ( Self .MDAClass class_Parameter == )
    false
   ( Self .MDAClass class_Category == )
    false
   ( Self .MDAClass class_Dependency == )
    false
   DEFAULT
    RULES
     ( Self .IsConstantsButNotType )
      false
     ( Self .IsVCMOperations )
      false
     ( Self .IsControlPrim )
      false
     ( Self .IsProperty )
      false
     ( Self .IsMethod )
       false
     ( Self .IsElementProxy )
      false
     ( Self .IsTestClass )
      false
     ( Self .IsUserType ) 
      false
     ( Self .IsUtilityPack )
      false
     ( Self .IsInterfaces )
      false
     ( Self .IsTarget )
      false
     ( Self .IsEvdSchemaElement )
      false
     ( Self .IsPureMixIn )
      false
     ( Self .IsDefine )
      false
     ( Self .IsMixIn )
      false
     ( Self .IsMixInParamType )
      false 
     DEFAULT
      true
    ; // RULES
  ; // RULES  
 )
 &gt;&gt;&gt; Result
; // IsType

STRING CompileTime-VAR g_IfDefStr ''
STRING CompileTime-VAR g_IfNDefStr ''
ARRAY CompileTime-VAR g_IfDefArr []
ARRAY CompileTime-VAR g_IfNDefArr []

BOOLEAN CompileTime-VAR g_WasType false
ModelElement CompileTime-VAR g_WasTypeOpener nil
BOOLEAN CompileTime-VAR g_WasConst false
BOOLEAN CompileTime-VAR g_WasForwarded false

PROCEDURE DropWasType
 false &gt;&gt;&gt; g_WasType
 nil &gt;&gt;&gt; g_WasTypeOpener
; // DropWasType

elem: IfDefPrim:
  IN aElseLambda
  ^ IN aOutLambda
  ^ IN aLambda
 
 if ( Self IsString ! ) then
 begin
  TF g_IfDefStr (
   TF g_IfNDefStr (
    TF g_IfDefArr (
     TF g_IfNDefArr (
     
      VAR l_IfDefStr
      Self .IfDefStr &gt;&gt;&gt; l_IfDefStr
      
      VAR l_IfNDefStr
      Self .IfNDefStr &gt;&gt;&gt; l_IfNDefStr
      
      BOOLEAN VAR l_NeedOut
      false &gt;&gt;&gt; l_NeedOut
      
      ARRAY VAR l_Body
      nil &gt;&gt;&gt; l_Body
      
      : OutIfBody
        STRING IN anOpen
        STRING IN aClose
       VAR l_NeedAND
       false &gt;&gt;&gt; l_NeedAND
       
       : OutItem
         IN anItem
         STRING IN aPrefix
         ARRAY IN anOuted
        if ( anItem .IsNotNil ) then
        begin
         if ( anItem .TextNotInArray: anOuted ) then
         begin
          anItem .AddToArray: anOuted
          true &gt;&gt;&gt; l_NeedOut
          cSpace 
          if l_NeedAND then
          begin
           'AND' cSpace
          end
          else
          begin
           true &gt;&gt;&gt; l_NeedAND
          end // l_NeedAND
          aPrefix 'Defined(' anItem ')'
         end // ( anItem .TextNotInArray: anOuted )
        end // ( anItem .IsNotNil )
       ; // OutItem
       
       [ 
        l_IfDefStr ',' string:Split:for&gt; ( cEmptyStr g_IfDefArr OutItem )
        l_IfNDefStr ',' string:Split:for&gt; ( 'NOT ' g_IfNDefArr OutItem )
       ] &gt;&gt;&gt; l_Body
       
       if l_NeedOut then
       begin
        [
         anOpen
         l_Body
         aClose
         if ( g_EnableAutoEOL ! ) then
          \n
        ] aOutLambda DO
       end // l_NeedOut
      ; // OutIfBody
      
      if ( ( l_IfDefStr .IsNotNil ) OR ( l_IfNDefStr .IsNotNil ) ) then
      begin
       if ( ( l_IfDefStr g_IfDefStr != ) OR ( l_IfNDefStr g_IfNDefStr != ) ) then
       begin
        g_IfDefArr array:CopyNotNil &gt;&gt;&gt; g_IfDefArr
        g_IfNDefArr array:CopyNotNil &gt;&gt;&gt; g_IfNDefArr
        
        l_IfDefStr &gt;&gt;&gt; g_IfDefStr
        l_IfNDefStr &gt;&gt;&gt; g_IfNDefStr
        
        : IfOut
         cOpenComment '$If' Cat cCloseComment OutIfBody
        ; // IfOut
        
        if g_NeedOutLn then
        begin
         false &gt;&gt;&gt; g_NeedOutLn
         OutLnToFile
        end // g_NeedOutLn
        IfOut
       end // ( ( l_IfDefStr g_IfDefStr != ) OR ( l_IfNDefStr g_IfNDefStr != ) )
      end // ( ( l_IfDefStr .IsNotNil ) OR ( l_IfNDefStr .IsNotNil ) )
      
      aLambda DO 
      
      if l_NeedOut then
      begin
      
       : IfEndOut
        false &gt;&gt;&gt; l_NeedOut
        nil &gt;&gt;&gt; g_IfDefArr
        nil &gt;&gt;&gt; g_IfNDefArr
        
        if ( aElseLambda .IsNotNil ) then
        begin
         [ cOpenComment '$Else' l_Body cCloseComment \n ] aOutLambda DO
         aElseLambda DO
        end // ( aElseLambda .IsNotNil )
        
        [ 
         cOpenComment '$IfEnd' cCloseComment cSpace '//' 
         l_Body 
         if g_NeedOutLn then
         begin
          false &gt;&gt;&gt; g_NeedOutLn
          \n
         end // g_NeedOutLn
        ] aOutLambda DO
        nil &gt;&gt;&gt; l_Body
        
        if ( Self .IsType ) then
        begin
         if ( g_WasForwarded ! ) then
         begin
          if ( g_WasTypeOpener Self ?== ) then
          begin
           DropWasType
          end // ( g_WasTypeOpener Self ?== )
         end // ( g_WasForwarded ! )
        end // ( Self .IsType )
        
       ; // IfEndOut
       
       IfEndOut
      end // l_NeedOut
     ) // TF g_IfNDefArr 
    ) // TF g_IfDefArr
   ) // // TF g_IfNDefStr  
  ) // TF g_IfDefStr 
 end // ( Self IsString ! )
 else
 begin
  aLambda DO
 end // ( Self IsString ! )
; // IfDefPrim:

elem_proc IfDef:
  ^ IN aLambda
 Self nil .IfDefPrim: .Out ( aLambda DO ) 
; // IfDef:
 
elem_proc IfDefElse:
  ^ IN aLambda
  ^ IN aElseLambda
 Self aElseLambda .IfDefPrim: .Out ( aLambda DO ) 
; // IfDefElse:

BOOLEAN elem_func IsConstructor
  RULES
   ( Self .IsStereotype st_ctor::Operation )
    true
   ( Self .IsStereotype st_Constructor )
    true
   DEFAULT
    false
  ; //RULES   
 &gt;&gt;&gt; Result
; // IsConstructor

BOOLEAN elem_func IsStaticConstructor
  RULES
   ( Self .IsConstructor )
    RULES
     ( Self .Parent .IsRecord )
      true
     DEFAULT
      false
    ; // RULES
   DEFAULT
    false
  ; //RULES   
 &gt;&gt;&gt; Result
; // IsStaticConstructor

BOOLEAN elem_func NeedsFinalize
 Cached:
 (
  RULES
   ( Self .IsNil )
    false
   DEFAULT
    RULES
     ( 
      Self .Attributes
      .mapToTarget&gt; 
      .filter&gt; .IsManaged
      .NotEmpty
     )
      true
     ( Self .MainAncestor call.me )
      true
     DEFAULT
      false
    ; // RULES
  ; // RULES  
 )
 &gt;&gt;&gt; Result
; // NeedsFinalize

BOOLEAN elem_func ParentIsInterface
 Cached:
 (
  Self .Parent .IsInterface
 )
 &gt;&gt;&gt; Result
; // ParentIsInterface

INTEGER elem_func FieldLinkType
 RULES
  ( Self .IsProperty )
   RULES
    ( Self .ParentIsInterface )
     lt_ref
    ( Self .LinkType lt_lnk == ) 
     lt_lnk
    DEFAULT
     lt_ref
   ; // RULES
  DEFAULT
   ( Self .LinkType )
 ; // RULES
 &gt;&gt;&gt; Result
; // FieldLinkType

BOOLEAN elem_func IsFieldForCleanup
 ( Self .FieldLinkType lt_ref == ) 
 AND ( Self .Target .IsManaged )
 AND ( 
  ( Self .GetUP 'extprop:clearViaProperty' .IsNil )
  OR ( Self .Target .IsMixInParamType ! )
 )
 &gt;&gt;&gt; Result
; // IsFieldForCleanup

BOOLEAN elem_func IsVCMApplication
 Self .IsStereotype st_VCMApplication
 &gt;&gt;&gt; Result
; // IsVCMApplication

elem_proc MethodUserCode
  STRING IN aKey
  TtfwWord IN aCode
  
 STRING VAR l_Key 
 aKey &gt;&gt;&gt; l_Key
 
 VAR l_Implementor
 Self .ImplementorOrParent &gt;&gt;&gt; l_Implementor
 
 RULES
  ( l_Key 'iter' == )
   ()
  ( l_Key 'afteriter' == )
   ()
  ( l_Key 'iterparam' == )
   ()
  DEFAULT
   (
    RULES
     ( Self .IsSetter ) then
      ( 'set' l_Key Cat &gt;&gt;&gt; l_Key )
     ( Self .IsProperty ) then
      ( 'get' l_Key Cat &gt;&gt;&gt; l_Key )
     ( Self .IsTester ) then
      ( 'test' l_Key Cat &gt;&gt;&gt; l_Key )
     ( Self .IsExecutor ) then
      ( 'exec' l_Key Cat &gt;&gt;&gt; l_Key )
     ( Self .IsGetState ) then
      ( 'getstate' l_Key Cat &gt;&gt;&gt; l_Key )
    ; // RULES
    
    if ( l_Implementor .IsNotNil ) then
    begin
     [ 
      cUnderline 
      if ( Self .IsLocalMethod ! ) then
      begin
       l_Implementor .LUID
      end // ( Self .IsLocalMethod ! )
      l_Key 
     ] strings:Cat &gt;&gt;&gt; l_Key
    end // ( l_Implementor .IsNotNil )
   ) // DEFAULT
 ; // RULES
 
 BOOLEAN elem_func IsSingletonExists
  Self .Name 'Exists' ==
  AND ( Self .IsStaticOp )
  AND ( l_Implementor .IsSingleton )
  &gt;&gt;&gt; Result
 ; // IsSingletonExists
 
 : WithoutVar:
   ^ IN aImplCode
  Self aKey l_Key aCode .PredefinedMethodUserCodeWithoutVar: ( aImplCode DO ) 
 ; // WithoutVar:
 
 RULES
  ( Self .IsSingletonExists )
   (
    WithoutVar:
    ( 
     'Result := g_' l_Implementor .TypeName ' &lt;&gt; nil;'
    ) 
   ) // ( Self .IsSingletonExists )
  ( 
   Self .Name 'Alien' ==
   AND ( Self .IsSetter ) 
   AND ( l_Implementor .IsService )
  )
   (
    WithoutVar:
    (
     'Assert((f_Alien = nil) OR (aValue = nil));' \n
     'f_Alien := aValue;'
    ) 
   ) // Self .Name 'Alien' ==
   
  ( 
   ( Self .LUID GarantModel::TComponent.Loaded .LUID == ) // TComponent.Loaded
   AND ( l_Implementor .IsVCMApplication )
  ) 
   (
    WithoutVar:
    (
     'inherited;'
    )
   )
  
  ( Self .LUID '4C937013031D' == ) // GetFolder
   (
    WithoutVar:
    (
     'Result := ' cQuote l_Implementor .Parent .Name cQuote ';'
    )
   )
  ( Self .LUID '4DAED6F60146' == ) // GetModelElementGUID
   (
    WithoutVar:
    (
     'Result := ' cQuote l_Implementor .LUID cQuote ';'
    )
   )
  ( 
   Self .LUID '4EE1DC8903BB' == // GetInteger
   AND ( l_Implementor .Parent .IsUserType )
  ) 
   WithoutVar: ( 'Result := ' l_Implementor .Parent .Name ';' )
   
  ( Self .LUID GarantModel::TtfwAxiomaticsResNameGetter.ResName .LUID == ) // ResName
   WithoutVar: ( 'Result := ' cQuote l_Implementor .EffectiveUnitName cQuote ';' )
  ( Self .LUID '4DB079E00084' == ) // GetModuleOperationCode
   ( 
    WithoutVar:
    (
     'Result := TdmStdRes.mod_opcode_' 
     l_Implementor .Name 
      'Tkw_' .CutPrefix
       '_op' cUnderline string:ReplaceFirst
     ';'
    )
   ) 
  ( Self .LUID GarantModel::TtfwRegisterableWord.GetWordNameForRegister .LUID == ) // GetWordNameForRegister
   ( 
    WithoutVar:
    ( 
     'Result := '
     
     cQuote
      
     VAR l_NameForScript
     l_Implementor .NameForScript &gt;&gt;&gt; l_NameForScript
     if ( l_NameForScript .IsValueValid ) then
     begin
     
      ANY FUNCTION Mangle
        IN aValue
       RULES
        ( aValue IsBool )
         RULES
          aValue
           'true'
          DEFAULT
           'false'
         ; // RULES 
        DEFAULT
         aValue
       ; // RULES
       &gt;&gt;&gt; Result
      ; // Mangle
      
      l_NameForScript Mangle
     end // ( l_NameForScript .IsValueValid )  
     else
     begin
      l_Implementor .Parent .GetUP 'extprop:pas:ElementPrefixBase'
      l_Implementor .Name cUnderline ':' string:Replace
     end // ( l_NameForScript .IsValueValid ) 
      
     cQuote 
      
     ';' 
    ) // ( Self .Name 'GetWordNameForRegister' == )
   )
  ( Self .LUID GarantModel::l3UnknownPrim.ClearFields .LUID == ) // ClearFields
   (
    WithoutVar:
    ( 
     l_Implementor .Fields 
     .filter&gt; .IsFieldForCleanup
     .for&gt; (
       IN aField
      aField nil .IfDefPrim: \n
      ( 
       VAR l_FieldName
       
       aField .GetUP 'extprop:clearViaProperty' &gt;&gt;&gt; l_FieldName 
       
       if (
           ( aField .Target .CannotFinalizeProperty )
           OR ( l_FieldName .IsNil ) 
          ) then
       begin
        RULES
         ( 
          ( aField .IsReadonlyProperty ) 
          OR ( aField .Target .CannotFinalizeProperty )
         )
          ( aField .FieldName &gt;&gt;&gt; l_FieldName )
         ( 
          ( aField .IsProperty ) 
          AND ( aField .LinkType lt_agr == )
          AND ( aField .Target .IsWideString )
         )
         // http://mdp.garant.ru/pages/viewpage.action?pageId=594895802&focusedCommentId=620849995#comment-620849995
          ( aField .FieldName &gt;&gt;&gt; l_FieldName )
         DEFAULT 
          ( aField .Name &gt;&gt;&gt; l_FieldName )
        ; // RULES  
       end // ( l_FieldName .IsNil )
       
       RULES 
        ( aField .Target .IsInterface )
         ( l_FieldName ' := nil' )
        ( aField .Target .IsString )
         ( l_FieldName ' := ' cQuote cQuote )
        ( aField .Target .IsOpenArray )
         ( l_FieldName ' := nil' )
        DEFAULT
         ( 'Finalize(' l_FieldName ')' )
       ; // RULES 
       ';' \n
      ) // aField .IfDef:
     ) // l_Implementor .Fields
     'inherited;'
    ) 
   )
  DEFAULT
   (
    if ( Self .IsStaticConstructor ) then
    begin
     if ( aKey cImplementationUserCodeSuffix == ) then
     begin
      if ( l_Implementor .NeedsFinalize ) then
      begin
       ' Finalize(Result);' .Out
      end // ( l_Implementor .NeedsFinalize )
      ' System.FillChar(Result, SizeOf(Result), 0);' .Out
     end // ( aKey cImplementationUserCodeSuffix == )
    end // ( Self .IsStaticConstructor )
    Self aKey l_Key aCode .DefaultUserCode 
   )
 ; // RULES 
; // MethodUserCode

BOOLEAN elem_func IsIni
 Self .IsStereotype st_ini::Operation &gt;&gt;&gt; Result
; // IsIni

BOOLEAN elem_func IsFini
 Self .IsStereotype st_fini::Operation &gt;&gt;&gt; Result
; // IsFini

elem: IfDefBrace:
  ^ IN aLambda
 VAR l_WasIf 
 false &gt;&gt;&gt; l_WasIf
 Self nil .IfDefPrim: ( l_WasIf ! ? ( true &gt;&gt;&gt; l_WasIf \n ) )
 (
  aLambda DO
  l_WasIf ? \n
 ) // Self .IfDefPrim:
; // IfDefBrace:

elem: IfDefBraceLn:
  ^ IN aLambda
 VAR l_WasIf 
 false &gt;&gt;&gt; l_WasIf
 Self nil .IfDefPrim: ( true &gt;&gt;&gt; l_WasIf \n )
 (
  aLambda DO
  l_WasIf ? \n
 ) // Self .IfDefPrim:
; // IfDefBraceLn:

BOOLEAN elem_func IsClassRef
 Self .UPisTrue "isClassRef"
 &gt;&gt;&gt; Result
; // IsClassRef

ARRAY STRING TYPE ArrayOrString

STRING elem_func TypeInfo
 RULES
  ( Self .IsNil )
   '@tfw_tiVoid'
  ( Self .TypeName 'Tl3PCharLen' == )
   '@tfw_tiWString'
  ( Self .IsString )
   '@tfw_tiString'
  ( Self .TypeName 'Il3CString' == )
   '@tfw_tiString'
  ( Self .TypeName 'Tl3WString' == )
   '@tfw_tiString'
  ( Self .TypeName 'Tl3PCharLenPrim' == )
   '@tfw_tiString'
  ( Self .IsRecord )
   '@tfw_tiStruct'
  ( Self .IsClassRef ) 
   '@tfw_tiClassRef'
  DEFAULT
   ( [ 'TypeInfo(' Self .TypeName ')' ] strings:Cat )
 ; // RULES
 &gt;&gt;&gt; Result 
; // TypeInfo 

STRING elem_func PopSig
 RULES
  ( Self .TypeName 'TClass' == )
   'PopClass'
  ( Self .TypeName 'TtfwStackValue' == )
   'Pop'
  ( Self .TypeName 'TClass' == )
   'PopClass'
  ( Self .TypeName 'ItfwValueList' == )
   'PopList'
  ( Self .TypeName 'ItfwFile' == )
   'PopFile'
  ( Self .IsClassRef )
   ( [ 'PopClassAs(' Self .TypeName ')' ] strings:Cat )
  ( Self .TypeName 'Tl3WString' == )
   'PopWStr'
  ( Self .TypeName 'Tl3PCharLenPrim' == )
   'PopWStr'
  ( Self .TypeName 'Tl3PCharLen' == )
   'PopWStr'
  ( Self .TypeName 'Il3CString' == )
   'PopString'
  ( Self .IsSimpleClass )
   ( [ 'PopObjAs(' Self .TypeName ')' ] strings:Cat )
  ( Self .IsInterface )
   ( [ 'PopIntf(' Self .TypeName ')' ] strings:Cat )
  ( Self .TypeName 'String' == )
   'PopDelphiString'
  ( Self .TypeName 'Char' == )
   'PopChar'
  ( Self .TypeName 'AnsiChar' == )
   'PopChar'
  ( Self .TypeName 'TPoint' == )
   'PopPoint'
  ( Self .TypeName 'WideString' == )
   'PopWideString'
  ( Self .TypeName 'AnsiString' == )
   'PopDelphiString'
  ( Self .TypeName 'Integer' == )
   'PopInt'
  ( Self .TypeName 'TColor' == )
   'PopInt'
  ( Self .TypeName 'Cardinal' == )
   'PopInt'
  ( Self .IsEnum )
   'PopInt'
  ( Self .TypeName 'THandle' == )
   'PopInt'
  ( Self .TypeName 'Boolean' == )
   'PopBool'
  ( Self .IsTypedef )
   ( Self .MainAncestor call.me ) 
  DEFAULT 
   ( [ 'Не знаем как снять со стека : ' Self .TypeName ] strings:Cat )
 ; // RULES
 &gt;&gt;&gt; Result  
; // PopSig

STRING elem_func PushType
 RULES
  ( Self .TypeName 'ItfwValueList' == )
   ''
  ( Self .TypeName 'ItfwFile' == )
   ''
  ( Self .TypeName 'Il3CString' == )
   ''
  ( Self .IsInterface )
   ( [ ', ' 'TypeInfo(' Self .TypeName ')' ] strings:Cat )
  DEFAULT
  ''
 ; // RULES
 &gt;&gt;&gt; Result
; // PushType

STRING elem_func PushSig
 RULES
  ( Self .IsNil )
   ''
  ( Self .TypeName 'TClass' == )
   'PushClass'
  ( Self .TypeName 'TtfwStackValue' == )
   'Push'
  ( Self .TypeName 'TClass' == )
   'PushClass'
  ( Self .TypeName 'ItfwValueList' == )
   'PushList'
  ( Self .TypeName 'ItfwFile' == )
   'PushFile'
  ( Self .IsClassRef )
   'PushClass'
  ( Self .TypeName 'Tl3WString' == )
   'PushString'
  ( Self .TypeName 'Tl3PCharLenPrim' == )
   'PushString'
  ( Self .TypeName 'Tl3PCharLen' == )
   'PushWStr'
  ( Self .TypeName 'Il3CString' == )
   'PushString'
  ( Self .IsSimpleClass )
   'PushObj'
  ( Self .IsInterface )
   'PushIntf'
  ( Self .TypeName 'String' == )
   'PushString'
  ( Self .TypeName 'Char' == )
   'PushChar'
  ( Self .TypeName 'AnsiChar' == )
   'PushChar'
  ( Self .TypeName 'TPoint' == )
   'PushPoint'
  ( Self .TypeName 'WideString' == )
   'PushWideString'
  ( Self .TypeName 'AnsiString' == )
   'PushString'
  ( Self .TypeName 'Integer' == )
   'PushInt'
  ( Self .TypeName 'TColor' == )
   'PushInt'
  ( Self .TypeName 'Cardinal' == )
   'PushInt'
  ( Self .IsEnum )
   'PushInt'
  ( Self .TypeName 'THandle' == )
   'PushInt'
  ( Self .TypeName 'Boolean' == )
   'PushBool'
  ( Self .IsTypedef )
   ( Self .MainAncestor call.me ) 
  DEFAULT 
   ( [ 'Не знаем как положить на стек: ' Self .TypeName ] strings:Cat )
 ; // RULES
 &gt;&gt;&gt; Result  
; // PushSig

STRING elem_func CastSig
 RULES
  ( Self .TypeName 'ItfwValueList' == )
   ''
  ( Self .TypeName 'ItfwFile' == )
   ''
  ( Self .IsClassRef )
   ( Self .TypeName )
  ( Self .TypeName 'Tl3PCharLen' == )
   ( Self .TypeName )
  ( Self .IsSimpleClass ) 
   ( Self .TypeName )
  ( Self .IsInterface ) 
   ( Self .TypeName )
  ( Self .TypeName 'TColor' == )
   ( Self .TypeName )
  ( Self .TypeName 'Cardinal' == )
   ( Self .TypeName )
  ( Self .IsEnum )
   ( Self .TypeName )
  ( Self .TypeName 'THandle' == )
   ( Self .TypeName )
  ( Self .IsTypedef )
   ( Self .MainAncestor call.me ) 
  DEFAULT
   ''
 ; // RULES
 &gt;&gt;&gt; Result  
; // CastSig

STRING elem_func TypeValue
 RULES
  ( Self .TypeName 'TtfwStackValue' == )
   ''
  ( Self .IsSimpleClass ) 
   ( [ '.AsObject(' Self .TypeName ')' ] strings:Cat ) 
  ( Self .TypeName 'Integer' == )
   '.AsInt'
  ( Self .TypeName 'TColor' == )
   '.AsInt'
  ( Self .TypeName 'Cardinal' == )
   '.AsInt'
  ( Self .IsEnum )
   '.AsInt'
  ( Self .TypeName 'String' == )
   '.AsDelphiString'
  ( Self .TypeName 'AnsiString' == )
   '.AsDelphiString'
  ( Self .TypeName 'Char' == )
   '.AsChar'
  ( Self .TypeName 'AnsiChar' == )
   '.AsChar'
  ( Self .TypeName 'Boolean' == )
   '.AsBoolean'
  ( Self .IsTypedef )
   ( Self .MainAncestor call.me ) 
  DEFAULT
   ( [ 'Не знаем как приводить значение типа ' Self .TypeName ] strings:Cat )
 ; // RULES
 &gt;&gt;&gt; Result  
; // TypeValue

STRING elem_func UnCastSig
 RULES
  ( Self .TypeName 'TColor' == )
   'Integer'
  ( Self .TypeName 'Cardinal' == )
   'Integer'
  ( Self .IsEnum )
   'Ord'
  ( Self .TypeName 'THandle' == )
   'Integer'
  ( Self .IsTypedef )
   ( Self .MainAncestor call.me ) 
  DEFAULT
   ''
 ; // RULES
 &gt;&gt;&gt; Result  
; // UnCastSig

elem_iterator BindServiceImplementationUC
 [
  Self .ImplementsInDependencies
  .for&gt; (
    IN anItem
   anItem .IfDefBrace:
   (
    cSpace anItem .TypeName '.Instance.Alien := ' Self .TypeName '.Instance;'
   ) // anItem .IfDefBrace:
  ) // Self .ImplementsInDependencies
 ]
 &gt;&gt;&gt; Result
; // BindServiceImplementationUC

elem_iterator RegAxiomUC
 [ cSpace Self .TypeName '.Register;' ]
 &gt;&gt;&gt; Result
; // RegAxiomUC

BOOLEAN elem_func IsCustomChoice
 Self .IsStereotype st_CustomChoice::Attribute
 &gt;&gt;&gt; Result
; // IsCustomChoice

BOOLEAN elem_func IsDefaultChoice
 Self .IsStereotype st_DefaultChoice::Attribute
 &gt;&gt;&gt; Result
; // IsDefaultChoice

elem_iterator AdditionalInitCode
  STRING IN aName
  
 STRING elem_func ChoiceName 
  [
   aName
   //%C%f_pas_Prefix()%C#f_AdditionalPrefix()
   '_Choice_'
   Self .Name
  ] strings:Cat 
  &gt;&gt;&gt; Result
 ; // ChoiceName
 
 [
 Self .Children 
 .filter&gt; .IsChoices
 .for&gt; (
   IN aChoices
  aChoices .Children 
  .filter&gt; .IsChoice
  .for&gt; (
    IN aChoice
   \n ' ' aName '.AddChoice(' aChoice .ChoiceName ');'
  ) // .for&gt;
 ) // .for&gt;
 
 Self .Attributes
 .filter&gt; .IsCustomChoice
 .for&gt; (
   IN aChoice
  \n ' ' aName '.AddCustomChoice(' aChoice .Target .ChoiceName ');'
 ) // .for&gt; 
 
 Self .Attributes
 .filter&gt; .IsDefaultChoice
 .for&gt; (
   IN aChoice
  \n ' ' aName '.AddDefaultChoice(' aChoice .Target .ChoiceName ');'
 ) // .for&gt; 
 
 if ( Self .UPisTrue "NeedCheck" ) then
 begin
  \n ' ' aName '.SetNeedCheck(true);'
 end // ( Self .UPisTrue "NeedCheck" )
 
 VAR l_Value
 Self .GetUP "CheckCaption" &gt;&gt;&gt; l_Value
 if ( l_Value .IsNotNil ) then
 begin
  \n ' ' aName '.SetCheckCaption(str_' Self .Name '_CheckCaption);'
 end // ( l_Value .IsNotNil )
 
 Self .GetUP "SettingsCaption" &gt;&gt;&gt; l_Value
 if ( l_Value .IsNotNil ) then
 begin
  \n ' ' aName '.SetSettingsCaption(str_' Self .Name '_SettingsCaption);'
 end // ( l_Value .IsNotNil )
 
 Self .GetUP "LongHint" &gt;&gt;&gt; l_Value
 if ( l_Value .IsNotNil ) then
 begin
  \n ' ' aName '.SetLongHint(str_' Self .Name '_LongHint);'
 end // ( l_Value .IsNotNil )
 
 \n ' ' aName '.SetDlgType(' 'mt' Self .GetUP "DlgType" ');'
 ]
 &gt;&gt;&gt; Result
; // AdditionalInitCode

PRINTABLE elem_func InitStrUCPrim
  ModelElement IN aSpeller
 [
  VAR l_Name
  [ Self .Parent .GetUP 'extprop:pas:ElementPrefix' Self .Name ] strings:Cat &gt;&gt;&gt; l_Name
  
  ' ' l_Name '.Init;'
  
  if ( aSpeller .IsMessage ) then
  begin
   aSpeller l_Name .AdditionalInitCode
  end // ( aSpeller .IsMessage )
 ]
 &gt;&gt;&gt; Result
; // InitStrUCPrim
        
PRINTABLE elem_func InitStrUC
 Self .SpelledFor Self .Speller .InitStrUCPrim
 &gt;&gt;&gt; Result
; // InitStrUC

PRINTABLE elem_func GetUserCode
  STRING IN aKey
 RULES
  ( 
   Self .IsIni
   AND ( Self .IsSummoned )
  )
   (
    VAR l_Parent
    Self .Parent &gt;&gt;&gt; l_Parent
    RULES
     ( l_Parent .IsServiceImplementation )
      ( l_Parent .BindServiceImplementationUC )
     ( Self .Name 'Ini_Reg' == ) 
      [ cSpace l_Parent .TypeName '.RegisterInEngine;' ]
     ( Self .Name 'RegAxiom' == ) 
      ( l_Parent .RegAxiomUC )
     ( Self .Name 'Ini_Reg_Class' == ) 
      [ 
       if ( l_Parent GarantModel::TtfwWord .InheritsFrom ) then
       begin
        ' ' l_Parent .TypeName '.RegisterClass;'
       end
       else
       begin
        ' TtfwClassRef.Register(' l_Parent .TypeName ');' 
       end 
      ] 
     ( 
      ( 'Init_Str_' Self .Name StartsStr ) 
      AND ( Self .SpelledFor .IsNotNil )
     )
      ( Self .InitStrUC )
     ( 
      ( 'Ini_FormFactory_' Self .Name StartsStr ) 
      AND ( Self .SpelledFor .IsNotNil )
     )
      [
       VAR l_SpelledFor
       Self .SpelledFor &gt;&gt;&gt; l_SpelledFor
       ' ' 'fm_' l_SpelledFor .TypeName .CutT '.SetFactory(' l_SpelledFor .TypeName '.Make);'  
      ]
     ( 
      ( 'Reg_Type_' Self .Name StartsStr ) 
      AND ( Self .SpelledFor .IsNotNil )
     )
      [
       VAR l_SpelledFor
       Self .SpelledFor &gt;&gt;&gt; l_SpelledFor
       ' TtfwTypeRegistrator.RegisterType('
       
       l_SpelledFor .TypeInfo
       
       ');'
      ] 
     DEFAULT
      '!!! Lost ini !!!'
    ; // RULES  
   )
  ( 
   Self .IsFini
   AND ( Self .IsSummoned )
  )
   '!!! Lost fini !!!'
  DEFAULT
   ( Self aKey cEmptyStr .ElemMember )
 ; // RULES
 &gt;&gt;&gt; Result
; // GetUserCode

BOOLEAN elem_func IsConstructorsHolder
 ( Self .MainAncestor .IsNotNil )
 AND ( Self .Attributes .IsEmpty )
 AND ( Self .OperationsEx .filter&gt; ( .IsConstructor ! ) .IsEmpty )
 &gt;&gt;&gt; Result
; // IsConstructorsHolder

ModelElement elem_func MethodType
 Cached:
 (
  RULES
   ( Self .InTie )
    RULES
     ( Self .Target .TypeName 'Boolean' == )
      GarantModel::ByteBool
     DEFAULT
      ( Self .Target )
    ; // RULES
   ( Self .IsInternalOperation )
    RULES
     ( Self .OpModify opModifyExecute == )
      ( Self .Target )
     DEFAULT
      nil 
    ; // RULES 
   ( Self .IsVCMOperationPrim )
     nil
   ( Self .IsIterator )
    (
     RULES
      ( Self .MainAncestor .IsNotNil )
       ( Self .MainAncestor call.me )
      ( Self .UPisTrue "needs result" ) 
       (
        VAR l_Type
        Self .Attributes 
        .filter&gt; .IsResultType
        .mapToTarget&gt;
        .FirstElement &gt;&gt;&gt; l_Type
        RULES
         ( l_Type .IsNotNil )
          l_Type
         DEFAULT
          GarantModel::Integer
        ; // RULES  
       ) 
      DEFAULT
       nil
     ; // RULES 
    )
   ( Self .IsStaticConstructor )
    if ( Self .Parent .IsConstructorsHolder ) then
     ( Self .Parent .MainAncestor )
    else
     ( Self .Parent )
   ( Self .IsControlOverride )
    ( Self .MainAncestor call.me ) 
   ( Self .IsControlPrim )
    ( Self .MainAncestor ) 
   ( Self .IsStereotype st_Area )
    ( Self .MainAncestor )
   ( Self .IsConstructor ) 
    nil
   ( Self .IsMethod )
    RULES
     ( Self .ImplementsIterator )
      ( Self .MainImplements call.me )
     ( Self .MainAncestor .IsNotNil ) 
      ( Self .MainAncestor call.me )
     DEFAULT
      ( Self .FirstOperation .Target )
    ; // RULES  
   ( Self .IsFunction )
    ( Self .FirstOperation .Target )
   DEFAULT 
    ( Self .Target )
  ; // RULES
  VAR l_Type
  &gt;&gt;&gt; l_Type
  RULES 
   ( l_Type .IsNil )
   begin
    RULES
     ( Self .IsStereotype st_factory::Operation )
      ( Self .Parent .MainImplementsInterface )
     ( Self .IsFactoryMethod )
      ( Self .MainImplementsInterface )
     DEFAULT
      l_Type
    ; // RULES
   end // ( l_Type .IsNil )
   DEFAULT
    l_Type
  ; // RULES
  &gt;&gt;&gt; l_Type
  RULES 
   ( l_Type .IsNil )
   begin
    RULES
     ( Self .IsStereotype st_factory::Operation )
      ( 'BadFactoryType' )
     ( Self .IsFactoryMethod )
      ( Self .Parent .MainImplementsInterface )
     DEFAULT
      l_Type
    ; // RULES
   end // ( l_Type .IsNil )
   DEFAULT
    l_Type
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // MethodType

BOOLEAN elem_func IsAcceptableForScripts
 Self .UPisTrue 'extprop:rc:isAcceptableForScripts' 
 &gt;&gt;&gt; Result
; // IsAcceptableForScripts

BOOLEAN elem_func InheritsOrImplementsAcceptableForScripts
 Cached:
 (
  RULES
   ( Self .InheritsEx .filter&gt; .IsAcceptableForScripts .NotEmpty )
    true
   ( Self .ImplementsEx .filter&gt; .IsAcceptableForScripts .NotEmpty )
    true
   DEFAULT
    false
  ; // RULES 
 )
 &gt;&gt;&gt; Result
; // InheritsOrImplementsAcceptableForScripts

BOOLEAN elem_func HasSelf
 RULES
  ( Self .Parent .InheritsOrImplementsAcceptableForScripts ! )
   false
  ( Self .IsCreator )
   false
  ( Self .IsKeyWord )
   true
  DEFAULT
   false
 ; // RULES
 &gt;&gt;&gt; Result
; // HasSelf

BOOLEAN elem_func IsOutParam
 Self .IsStereotype st_out &gt;&gt;&gt; Result
; // IsOutParam

ARRAY FUNCTION .filterOutParam&gt;
  ARRAY IN anArray
 anArray
 .filter&gt; ( .IsOutParam ! ) 
 &gt;&gt;&gt; Result
; // .filterOutParam&gt;

STRING FUNCTION .UpperFirstChar
  STRING IN aSubstr
 RULES
  ( aSubstr .IsNil )
   ''
  DEFAULT
   begin
   [ 
    1 0 aSubstr string:Substring string:Upper
    VAR l_Len
    aSubstr string:Len 1 - &gt;&gt;&gt; l_Len
    l_Len &lt; 0 ?FAIL 'l_Len &lt; 0'
    VAR l_Tail
    l_Len
     1 aSubstr string:Substring &gt;&gt;&gt; l_Tail
    l_Tail .IsNil ?FAIL 'l_Tail .IsNil'
    l_Tail  
   ] strings:Cat 
  end // DEFAULT
 ; // RULES 
 &gt;&gt;&gt; Result 
; // .UpperFirstChar

STRING FUNCTION .FromTie
  STRING IN aValue
 '' &gt;&gt;&gt; Result
 if ( aValue .IsNotNil ) then
 begin
  aValue cUnderline string:Split:for&gt; ( 
    IN aSubstr
   aSubstr .IsNil ?FAIL 'aSubstr .IsNil' 
   [ 
    Result 
    aSubstr .UpperFirstChar
   ] strings:Cat &gt;&gt;&gt; Result 
  ) // aValue cUnderline string:Split:for&gt;
 end // ( aValue .IsNotNil )
; // .FromTie
 
STRING FUNCTION .ToBorland
  STRING IN aValue
 '' &gt;&gt;&gt; Result
 aValue cUnderline string:Split:for&gt; ( 
   IN aSubstr
/*{  if ( aSubstr .IsNil ) then 
  begin
   Result cUnderline Cat &gt;&gt;&gt; Result
  end 
  else}*/
  begin
   Result aSubstr Cat &gt;&gt;&gt; Result
  end 
 )
; // .ToBorland

STRING elem_func MethodName

 STRING elem_func FineName
  Self .Name '__' cUnderline string:Replace
  &gt;&gt;&gt; Result
 ; // FineName

 Cached:
 (
  RULES
   ( Self .IsNil )
    ''
   ( Self .InTie )
    ( Self .Name .FromTie )
   ( Self .IsVCMOperationPrim )
    RULES
     ( Self .IsTester )
      ( [ Self .Parent .Name cUnderline Self .Name '_Test' ] strings:Cat )
     ( Self .IsExecutor )
      ( [ Self .Parent .Name cUnderline Self .Name '_Execute' ] strings:Cat )
     ( Self .IsGetState )
      ( [ Self .Parent .Name cUnderline Self .Name '_GetState' ] strings:Cat )
     DEFAULT
      ( [ Self .Parent .Name cUnderline Self .Name ] strings:Cat )
    ; // RULES 
   ( Self .IsIterator )
    (
     RULES
      ( Self .IsIteratorF )
       ( Self .Name 'F' Cat )
      ( Self .MainAncestor .IsNotNil )
       ( Self .MainAncestor call.me )
      DEFAULT
       ( Self .Name )
     ; // RULES
    ) // ( Self .IsIterator )
   ( Self .IsStaticConstructor )
    if ( Self .Parent .IsConstructorsHolder ) then
     ( [ Self .Parent .MainAncestor .TypeName cUnderline Self .Name ] strings:Cat )
    else
     ( [ Self .Parent .TypeName cUnderline Self .Name ] strings:Cat )
   ( Self .UPisTrue 'extprop:isGlobal' )
    ( Self .Name .ToBorland )
    
   ( Self .Parent .IsUtilityPack ) 
    ( 
      VAR l_Prefix
      Self .Parent .GetUP 'extprop:pas:ElementPrefixBase' &gt;&gt;&gt; l_Prefix
      if ( l_Prefix .IsNil ) then
      begin
       Self .Parent .GetUP 'extprop:pas:ElementPrefix' &gt;&gt;&gt; l_Prefix
      end // ( l_Prefix .IsNil )
      l_Prefix Self .FineName Cat 
    )
   ( Self .IsMethodAndImplementsIterator )
    RULES
     ( Self .IsIteratorF )
      ( Self .MainImplements call.me 'F' Cat )
     DEFAULT
      ( Self .MainImplements call.me )
    ; // RULES  
   ( '__' Self .Name StartsStr ) 
    ( Self .FineName )
   DEFAULT
    ( Self .FineName )
  ; // RULES 
 )
 &gt;&gt;&gt; Result
; // MethodName

elem_proc UserCode:
 ^ IN aSuffix
 ^ IN aCode
 
 STRING VAR l_Key
 
 aSuffix DO &gt;&gt;&gt; l_Key
 
 VAR l_Code
 Self cUserCodePrefix l_Key Cat .GetUserCode &gt;&gt;&gt; l_Code
 
 if ( l_Code .IsValueValid ) then
 begin
  if ( l_Code cEmptyUserCode ?!= ) then
  begin
   l_Code .Out
  end // ( l_Code cEmptyUserCode ?!= )
 end // ( l_Code .IsValueValid )
 else
 begin
 
  : AsDefault
   Self l_Key l_Key aCode .DefaultUserCode
  ; // AsDefault
  
  : AsMethod
   Self l_Key aCode .MethodUserCode
  ; // AsMethod
  
  VAR l_Implementor
  Self .ImplementorOrParent &gt;&gt;&gt; l_Implementor
  
  BOOLEAN FUNCTION IsUID
    STRING IN anUID
   ( Self .LUID anUID == ) 
   AND ( l_Implementor .IsSummoned ) &gt;&gt;&gt; Result
  ; // IsUID
  
  : Pair:
    ^ IN aVar
    ^ IN aCode
   RULES
    ( l_Key cVarUserCodeSuffix == )
     ( aVar DO )
    ( l_Key cImplementationUserCodeSuffix == )
     ( aCode DO )
    DEFAULT
     AsDefault 
   ; // RULES
  ; // Pair:
  
  : Code:
    ^ IN aCode
   Pair: () ( aCode DO )
  ; // Code:
  
  VAR l_Call
  // - метод, который собственно надо звать из DoDoIt или DoRun.
  l_Implementor .KeywordImplementationMethod &gt;&gt;&gt; l_Call
  
  VAR l_Op
  l_Implementor .KeywordOperation &gt;&gt;&gt; l_Op
  
  VAR l_Self
  l_Implementor .KeywordObjectToOperate &gt;&gt;&gt; l_Self
  
  elem_iterator ParametersWithoutContext
   Self .Parameters
   .filter&gt; ( 'aCtx' .HasName ! )
   &gt;&gt;&gt; Result
  ; // ParametersWithoutContext
  
  : .AsVar
    STRING IN aName
    ModelElement IN aType
   'var' cSpace 'l_' aName ': ' aType .TypeName ';' 
  ; // .AsVar
  
  elem: ParamAsVar
   Self .Name Self .Target .AsVar
  ; // ParamAsVar
  
  : .Pop
    STRING IN aName
    ModelElement IN aType
   'try' \n
   
   ' ' 'l_' aName 
   ' := ' 
   
   VAR l_CastSig
   aType .CastSig &gt;&gt;&gt; l_CastSig
   
   if ( l_CastSig .IsNotNil ) then
   begin
    l_CastSig '('
   end
   
   'aCtx.rEngine.' aType .PopSig
   
   if ( l_CastSig .IsNotNil ) then
   begin
    ')'
   end
   
   ';' \n
   
   'except' \n 
   ' on E: Exception do' \n
   ' begin' \n
   '  RunnerError(''Ошибка при получении параметра ' aName ': ' aType .TypeName ' : '' + E.Message, aCtx);' \n
   '  Exit;' \n
   ' end;//on E: Exception' \n
   'end;//try..except' \n
  ; // .Pop
  
  elem: ParamPop
   Self .Name Self .Target .Pop
  ; // ParamPop
  
  RULES
   (
    ( Self .IsInternalOperation )
    AND ( Self .OpModify opModifyNone == )
   ) 
    Code: (
     Indented: ( 
      [ 
       if ( 
           ( Self .Target .IsNotNil )
           OR ( Self .Parameters .NotEmpty )
          ) then
       begin
        'with (aParams.Data As I' Self .Parent .Name cUnderline Self .Name '_Params) do' \n ' '
       end // ( Self .Target .IsNotNil ) ..
       if ( Self .Target .IsNotNil ) then
       begin
        'ResultValue := '
       end // ( Self .Target .IsNotNil )
       'Self.' Self .MethodName '_Execute' Self .Parameters .map&gt; ( .Name 'a' .CutPrefix ) .CommaListWith() ';'
      ] .Out 
     ) 
    )
   (
    ( Self .LUID '4DB6D7F70155' == ) // IsImmediate
    AND ( l_Implementor .GetUP "is immediate" IsBool )
   ) 
    Code: ( [ ' Result := ' l_Implementor .GetUP "is immediate" ';' ] .Out )
    
   ( 
    ( l_Op .IsNotNil )
    AND ( GarantModel::TtfwCompilingWord.SuppressNextImmediate .LUID IsUID ) // SuppressNextImmediate
   ) 
    Code: ( [ ' Result := ' 'tfw_sni' l_Op .GetUP "SupressNextImmediate" ';' ] .Out )
    
   ( 
    ( l_Op .IsNotNil )  
    AND ( '4DDFD2EA0116' IsUID ) // GetString
   )
    Code: 
      (
       if ( 'Слово словаря для идентификатора контрола' l_Implementor .Documentation StartsStr ) then
       begin
        [ ' Result := ' cQuote l_Op .Name cQuote ';' ] .Out 
       end
       else
       begin
        [ ' Result := ' cQuote l_Op .TypeName .CutT cQuote ';' ] .Out 
       end 
      )
    
   (
    ( l_Op .IsNotNil )
    AND ( l_Self .IsNotNil )
    AND ( GarantModel::TtfwWord.SetValuePrim .LUID IsUID ) // SetValuePrim
   ) 
     Pair:
       (
        if ( l_Op .GetUP 'extprop:prop_stereo' 'readonly' != ) then
        begin
         if ( l_Self .IsNotNil ) then
         begin
          [ l_Self .SelfName l_Self .AsVar ] .Out
         end // ( l_Self .IsNotNil )
         
         l_Op .Parameters 
         .filterOutParam&gt;
         .for&gt; (
           IN aParam
          [ aParam .ParamAsVar ] .Out 
         ) // .for&gt;
        end // ( l_Op .GetUP 'extprop:prop_stereo' 'readonly' != )
       )
       (
        if ( l_Op .GetUP 'extprop:prop_stereo' 'readonly' == ) then
        begin
         [
          ' RunnerError(''Нельзя присваивать значение readonly свойству '
          l_Op .GetUP 'extprop:prop_name'
          ''', aCtx);'
         ] .Out
        end // ( l_Op .GetUP 'extprop:prop_stereo' 'readonly' == )
        else
        begin
         Indented:
         (
          [
           if ( l_Self .IsNotNil ) then
           begin
            l_Self .SelfName l_Self .Pop
           end // ( l_Self .IsNotNil )
           
           l_Op .Parameters 
           .filterOutParam&gt;
           .for&gt; (
             IN aParam
            aParam .ParamPop
           ) // .for&gt;
           
           if ( l_Self .IsNotNil ) then
           begin
            if ( l_Op .UPisTrue "mapped" ) then
            begin
             'l_' l_Self .SelfName
             cDot
             l_Op .GetUP 'extprop:prop_name'
             ' := '
             
             VAR l_CastSig
             l_Op .Target .CastSig &gt;&gt;&gt; l_CastSig
             
             if ( l_CastSig .IsNotNil ) then
             begin
              l_CastSig '('
             end
             
             'aValue' l_Op .Target .TypeValue
             
             if ( l_CastSig .IsNotNil ) then
              ')'
            end // ( l_Op .UPisTrue "mapped" )
            else
            begin
             'DoSetValue' 
             '('
             'l_' l_Self .SelfName
             
             l_Op .Parameters 
             .filterOutParam&gt;
             .for&gt; (
               IN aParam
             ', '
             'l_'
              aParam .Name
             ) // .for&gt;
             
             ', '
             
             VAR l_CastSig
             l_Op .Target .CastSig &gt;&gt;&gt; l_CastSig
             
             if ( l_CastSig .IsNotNil ) then
             begin
              l_CastSig '('
             end
             
             'aValue' l_Op .Target .TypeValue
             
             if ( l_CastSig .IsNotNil ) then
              ')'
              
             ')'
            end
            ';'
           end // ( l_Self .IsNotNil )
          ] .Out
         ) // Indented:
        end // ( l_Op .GetUP 'extprop:prop_stereo' 'readonly' == )
       )
       
   (
    ( l_Call .IsNotNil )
    AND 
    (
     ( GarantModel::TtfwWordPrim.DoDoIt .LUID IsUID ) // DoDoIt
     OR ( GarantModel::TtfwAnonimousWord.DoRun .LUID IsUID ) // DoRun
    ) 
   )
     Pair:
       (
        l_Call .ParametersWithoutContext
        .for&gt; (
          IN aParam
         [ aParam .ParamAsVar ] .Out
        ) // .for&gt;
       )
       (
        Indented:
        (
         [
          l_Call .ParametersWithoutContext
          .filterOutParam&gt;
          .for&gt; (
            IN aParam
           aParam .ParamPop 
          ) // .for&gt;
          
          VAR l_PushSig
          l_Call .Target .PushSig &gt;&gt;&gt; l_PushSig
          
          VAR l_UnCastSig
          '' &gt;&gt;&gt; l_UnCastSig
          
          if ( l_PushSig .IsNotNil ) then
          begin
           'aCtx.rEngine.' l_PushSig '('
           l_Call .Target .UnCastSig &gt;&gt;&gt; l_UnCastSig
           
           if ( l_UnCastSig .IsNotNil ) then
           begin
            l_UnCastSig '('
           end // ( l_UnCastSig .IsNotNil )
          end
          
          l_Call .MethodName 
          '(' 
          'aCtx' 
          l_Call .ParametersWithoutContext
          .for&gt; (
            IN aParam
           ', ' 'l_' aParam .Name
          ) // .for&gt;  
          ')'
          
          if ( l_PushSig .IsNotNil ) then
          begin
           if ( l_UnCastSig .IsNotNil ) then
           begin
            ')'
           end // ( l_UnCastSig .IsNotNil )
           l_Call .Target .PushType
           ')'
          end
          
          ';'
          
          l_Call .ParametersWithoutContext
          .filter&gt; ( .IsOutParam )
          .reverted&gt; 
          .for&gt; (
            IN aParam
           \n 
           'aCtx.rEngine.' 
           aParam .Target .PushSig 
           '(' 
           'l_' aParam .Name 
           aParam .Target .PushType
           ')'
           ';'
          ) // .for&gt;
            
         ] .Out
        ) // Indented:
       )
   
   ( 
    ( l_Op .IsNotNil )
    AND ( '52A086150180' IsUID ) // RegisterInEngine
   ) 
     Code:
       (
        [
         ' inherited;' \n
         ' TtfwClassRef.Register(' 
         if ( l_Op .IsControlPrim ) then
         begin
          l_Op .MethodType .TypeName
         end // ( l_Op .IsControlPrim )
         else
         begin
          l_Op .TypeName
         end // ( l_Op .IsControlPrim )
         ')' ';'
        ] .Out
       )
   
   ( 
    ( l_Op .IsNotNil )
    AND ( GarantModel::TtfwWordPrim.DoDoIt .LUID IsUID ) // DoDoIt
    AND ( l_Implementor GarantModel::TkwBynameControlPush .InheritsFrom )
   ) 
     Code:
       (
        [
         ' aCtx.rEngine.PushString(' cQuote l_Op .Name cQuote ')' ';' \n
         ' inherited;'
        ] .Out
       )
   
   ( GarantModel::TtfwWord.ParamsTypes .LUID IsUID ) // ParamsTypes
     Code:
       ( 
        VAR l_NeedComma
        false &gt;&gt;&gt; l_NeedComma
        [ 
         ' Result := '
         'OpenTypesToTypes'
         '('
         '['
         if ( l_Self .IsNil ) then
          [empty]
         else
          [ l_Self ]
         .join&gt;  
         (
          l_Op .Parameters 
          .filterOutParam&gt;
          .mapToTarget&gt;
         ) // .join&gt;
         .map&gt; .TypeInfo
         .for&gt; (
          .WithComma: l_NeedComma .KeepInStack
         )
         ']'
         ')'
         ';' 
        ] .Out 
       ) // ( l_Key cImplementationUserCodeSuffix == )
   ( GarantModel::TtfwWord.GetResultTypeInfo .LUID IsUID ) // GetResultTypeInfo
     Code:
       ( 
        [ 
         ' Result := '
         if ( l_Op .IsCreator ) then
         begin
          l_Self .TypeInfo
         end // ( l_Op .IsCreator )
         else
         begin
          l_Op .Target .TypeInfo
         end // ( l_Op .IsCreator )
         ';' 
        ] .Out 
       ) // ( l_Key cImplementationUserCodeSuffix == )
   ( GarantModel::TtfwWord.GetAllParamsCount .LUID IsUID ) // GetAllParamsCount
     Code:
       ( 
        [ 
         ' Result := '
         l_Op .Parameters 
         .filterOutParam&gt;
         .CountIt
         l_Op .HasSelf ? ( 1 + )
         l_Op .IsVarWorker ? ( 1 + )
         ';' 
        ] .Out 
       ) // ( l_Key cImplementationUserCodeSuffix == )
   ( GarantModel::TtfwWord.RightParamsCount .LUID IsUID ) // RightParamsCount
     Code:
       ( ' Result := 1;' .Out )
       
   ( GarantModel::TtfwClassLike.BindParams .LUID IsUID )
     Code:
       ( ' Result := true;' .Out )
   
   (
    ( Self .LUID '4B7AB0B6016E' == ) // TTestResultsPlace.CommandLineKey
    AND ( Self .OpKind opkind_Normal != )
   ) 
     Code:
       ( [ ' Result := ' cQuote '-' l_Implementor .Name 'Release' .CutPrefix cQuote ';' ] .Out )
       
   ( Self .IsFactory )
    begin
     Pair:
      (
       if ( Self .Parent .IsSingleton ! ) then
       begin
        'var' .Out
        [ ' l_Inst : ' Self .Parent .TypeName ';' ] .Out
       end // ( Self .Parent .IsSingleton ! )
      ) 
      
      ( 
       if ( Self .Parent .IsSingleton ) then
       begin
        Indented: (
         [
          VAR l_TypeName
          Self .Parent .TypeName &gt;&gt;&gt; l_TypeName
          'if (' 'g_' l_TypeName ' = nil) then' \n
          'begin' \n
          ' l3System.AddExitProc(' l_TypeName 'Free' ');' \n
          VAR l_Type
          Self .MethodType .TypeName &gt;&gt;&gt; l_Type
          ' ' l_Type '(' 'g_' l_TypeName ')' ' := inherited ' Self .Name ';' \n
          'end;' \n
          'Result := ' l_Type '(' 'g_' l_TypeName ')' ';'
         ] .Out
        ) // Indented:
       end // ( Self .Parent .IsSingleton )
       else
       begin
        Indented: (
         [ 
          'l_Inst := ' 
          
          VAR l_CallTo
          Self .MainAncestor &gt;&gt;&gt; l_CallTo
          if ( l_CallTo .IsNil ) then
           'Create' 
          else
          begin
           l_CallTo .Name
          end // ( l_CallTo .IsNil )
           
          Self .ParametersList ';' 
         ] .Out
         'try' .Out
         [
          ' Result := '
          
          if (
              ( Self .MethodType .IsMixInParamType )
              AND ( Self .Parent .IsMixIn )
             ) then
           '_Instance_R_(l_Inst)'
          else    
           'l_Inst' 
          
          if ( Self .UPisTrue "need As" ) then
          begin
           ' As ' Self .MethodType .TypeName
          end // ( Self .UPisTrue "need As" )
          
          ';' 
         ] .Out
         'finally' .Out
         ' l_Inst.Free;' .Out
         'end;//try..finally' .Out
        ) // Indented:
       end // ( Self .Parent .IsSingleton )
      ) 
    end // ( Self .IsFactory )
    
   (
    ( Self .OpKind opkind_Normal == ) // - метод новый, а не перекрытый
    AND ( l_Op .IsNotNil )
    AND ( l_Self .IsNotNil )
    AND ( l_Implementor .IsSummoned )
    AND ( l_Op .UPisTrue "mapped" )
   )
     Code:
       ( 
        [ 
         ' '
         if ( Self .Target .IsNotNil ) then
         begin
          'Result := ' 
         end
         'a' l_Self .SelfName cDot l_Op .Name l_Op .ParametersList ';' 
        ] .Out 
       )
    
   ( 
    'ResNameGetter' Self .Name EndsStr 
    AND ( Self .IsSimpleClass ) 
   )
    RULES
     ( l_Key 'impl' == )
      ( [ cSpace cOpenComment '$R ' Self .EffectiveUnitName '.res' cCloseComment ] .Out )
     DEFAULT
      () 
    ; // RULES
   ( Self .IsElementProxy )
    AsDefault
   ( Self .IsClassOrMixIn )
    AsDefault
   ( Self .IsRecord )
    AsDefault
   ( Self .IsUtilityPack )
    AsDefault
   ( Self .IsTarget )
    AsDefault
   ( Self .IsIni )
    AsDefault
   ( Self .IsFini )
    AsDefault
   ( Self .IsInterfaces )
    AsDefault
   DEFAULT
    AsMethod
  ; // RULES 
 end // ( l_Code .IsValueValid ) 
; // UserCode:

ARRAY FUNCTION .mapToUnitProducer&gt;
  ARRAY IN anArray
 anArray 
 .map&gt; .UnitProducer
 .filterNil&gt;
 .filterMixIns&gt;
 &gt;&gt;&gt; Result
; // .mapToUnitProducer&gt;

elem_proc OutUses:
  STRING IN aUCPrefix
  ^ IN aUsed
  ^ IN aLambda
  ^ IN anItemTransform
  
 ARRAY VAR l_Used
 aUsed DO &gt;&gt;&gt; l_Used
  
 ARRAY FUNCTION .filterUsed&gt;
   ARRAY IN anArray
  anArray
  .filter&gt; ( 
    IN anItem 
   anItem .UnitName &gt;&gt;&gt; anItem 
   if ( anItem .NotInArray: l_Used ) then
   begin
    anItem .AddToArray: l_Used
    true
   end
   else
   begin
    false
   end 
  ) &gt;&gt;&gt; Result  
 ; // .filterUsed&gt; 
  
 'uses' .Out
   VAR l_NeedComma
   false &gt;&gt;&gt; l_NeedComma
   Indented: ( 
    aLambda DO 
     .mapToUnitProducer&gt;
     .filter&gt; ( Self ?!= )
     .filter&gt; ( .UnitName Self .UnitName ?!= )
     .filter&gt; ( .UnitName 'System' ?!= )
     .filterUsed&gt; 
     .for&gt; ( 
       IN anItem
      anItem .IfDef: ( anItem anItemTransform DO .WithComma: l_NeedComma .Out )
     ) // .for&gt;
     
    if (
        ( Self .IsElementProxy )
        OR ( Self .UPisTrue "need UC" )
       ) then
    begin
     Self .UserCode: aUCPrefix ()
    end // ( Self .IsElementProxy )
    
    if (
        ( aUCPrefix 'intf_uses' == )
        AND ( Self .UPisTrue "need UC in project" )
       ) then
    begin
     Self .UserCode: 'manualuses' ()
    end // ( Self .IsElementProxy )
    
   ) // Indented:
 ';' .Out
 OutLn
; // OutUses:

ARRAY FUNCTION .mapToTargetAndValueType&gt;
  ARRAY IN anArray
 anArray .mapToTarget&gt;
 .join&gt; ( anArray .map&gt; .ValueType )
 &gt;&gt;&gt; Result
; // .mapToTargetAndValueType&gt;

elem_iterator AttributesAndOperations
 Cached:
 (
  Self .Attributes
  .join&gt; ( Self .OperationsEx )
  .filter&gt; ( .IsSomeKeyWord ! )
  .filter&gt; ( .IsStereotype st_link::Attribute ! )
 )
 &gt;&gt;&gt; Result
; // AttributesAndOperations

INTERFACE FUNCTION MakeIniProcedure:
  STRING IN aName
  ^ IN aLambda
 aName MakeProcedure: (
   IN aMade
  aMade -&gt; Stereotype := st_ini::Operation
  aMade -&gt; Visibility := PrivateAccess
  aMade aLambda DO
 ) // MakeProcedure:
 &gt;&gt;&gt; Result
; // MakeIniProcedure:

BOOLEAN elem_func IsFriend
 Self .IsStereotype st_friend::Dependency 
 &gt;&gt;&gt; Result
; // IsFriend

elem_iterator FriendInDependencies
 Cached:
 (
  Self .Dependencies 
  .filter&gt; .IsFriend
  .mapToTarget&gt;
  array:Copy
 ) 
 &gt;&gt;&gt; Result
; // FriendInDependencies

BOOLEAN elem_func NeedsScript
 RULES
  ( Self .UPisTrue "needs script" )
   true
  DEFAULT
   RULES
    ( Self .IsScriptKeywordsPack )
     RULES
      ( Self .IsSummoned )
       false
      ( Self .Parent .IsVCMForm )
       false
      ( Self .Parent .IsVCMFormsPack )
       false
      ( Self .UPisTrue "no class name" )
       true
      ( Self .UPisTrue "no_pop" )
       true
      DEFAULT
       false
     ; // RULES
    DEFAULT
     false
   ; // RULES  
 ; // RULES    
 &gt;&gt;&gt; Result
; // NeedsScript

ModelElement elem_func ClassForKeywordImplementation
  IN aKeywordSelf
  
 VAR l_ClassName
 Self .Name
 &gt;&gt;&gt; l_ClassName  
 
 l_ClassName
 RULES
  ( Self .IsVarWorker )
   GarantModel::TtfwWordWorkerEx
  ( Self .IsGlobalKeyWord )
   GarantModel::TtfwGlobalKeyWord
  ( Self .GetUP 'extprop:prop_stereo' .IsValueValid ) 
   GarantModel::TtfwPropertyLike 
  DEFAULT
   GarantModel::TtfwClassLike
 ; // RULES 
 MakeClass: (
   IN aMade
  VAR l_WordName
  Self .NameForScript &gt;&gt;&gt; l_WordName
  if ( l_WordName .IsNil ) then
  begin
   l_ClassName cUnderline ':' string:Replace &gt;&gt;&gt; l_WordName
  end // ( l_WordName .IsNil )
  aMade -&gt; UID := ( 
   [ 
    Self .LUID 
    if ( aKeywordSelf .NotIsNil ) then
    begin
     cUnderline aKeywordSelf .LUID
    end // ( aKeywordSelf .NotIsNil )
    '_Word' 
   ] strings:Cat 
  )
  aMade -&gt; %SUM := ( 'Слово скрипта ' l_WordName Cat ) 
  aMade -&gt; Parent := ( Self .Parent .WeakRef )
  aMade -&gt; Stereotype := st_ScriptKeyword
  aMade -&gt; Visibility := PrivateAccess
  aMade -&gt; Abstraction := at_final
  aMade -&gt; SpelledFor := Self
  aMade -&gt; Speller := aKeywordSelf
  aMade -&gt; "is immediate" := ( Self .GetUP "is immediate" )
  aMade -&gt; "ifdef" := ( Self .IfDefStr )
  aMade -&gt; "ifndef" := ( Self .IfNDefStr )
  aMade -&gt; "NameForScript" := l_WordName
  aMade -&gt; 'extprop:pas:TypeName' := ( 
   [ 
    'T' 'kw'
    //l_ClassName 'kw' .CutPrefix cUnderline '' string:Replace .UpperFirstChar
    l_ClassName 'kw' .CutPrefix .FromTie
   ] strings:Cat 
  )
  aMade -&gt; IsSummoned := true
  // - это вообще говоря "времянка", чтобы Override методы выводили код
 ) // MakeClass:
 
 VAR l_Made
 &gt;&gt;&gt; l_Made
 
 if ( Self .Speller .IsNil ) then
 // - здесь вообще говоря надо массив Speller'ов, и учесть его ниже, где алиасы выводятся
 begin
  Self -&gt; Speller := l_Made
 end // ( Self .Speller .IsNil )
 
 l_Made
 
 &gt;&gt;&gt; Result
; // ClassForKeywordImplementation

elem_iterator ChildrenEx
 Cached:
 (
  VAR l_Children
  Self .Children &gt;&gt;&gt; l_Children
  
  Self .FriendInDependencies
  .filter&gt; ( .IsEvdSchemaElement ! )
  .filter&gt; ( .IsInterface ! )
  .map&gt; .FriendClass
  .filter&gt; ( l_Children SWAP .Name .HasModelElementWithName ! )
  .for&gt; (
    IN aFriend
   l_Children 
   .join&gt; ToArray: aFriend
   array:Copy
   &gt;&gt;&gt; l_Children
  ) // .for&gt;
  
  if ( Self .IsScriptKeywordsPack ) then
  begin
   Self .OperationsEx 
   .filter&gt; .IsGlobalKeyWord
   .map&gt; ( nil .ClassForKeywordImplementation )
   .filter&gt; ( l_Children SWAP .Name .HasModelElementWithName ! )
   .for&gt; (
     IN aClass
    l_Children 
    .join&gt; ToArray: aClass
    array:Copy
    &gt;&gt;&gt; l_Children
   ) // .for&gt;
  end // ( Self .IsScriptKeywordsPack )
    
  l_Children
  if ( Self .IsTestClass ) then
  begin
   if ( Self .UPisTrue "is friend" ) then
   begin
    .join&gt; ToArray: ( Self .MainAncestor .FriendClass )
   end // ( Self .UPisTrue "is friend" )
  end // ( Self .IsTestClass )
  
  if ( Self .NeedsScript ) then
  begin
   STRING VAR l_ClassName
   [ 'T' Self .UnitName 'ResNameGetter' ] strings:Cat &gt;&gt;&gt; l_ClassName
   if ( l_Children l_ClassName .HasModelElementWithName ! ) then
   begin
    .join&gt; 
    [
     l_ClassName GarantModel::TtfwAxiomaticsResNameGetter MakeClass: (
       IN aMade
      aMade -&gt; UID := ( Self .LUID '_ResNameGetter' Cat ) 
      aMade -&gt; Parent := ( Self .WeakRef ) 
      aMade -&gt; Stereotype := st_SimpleClass
      aMade -&gt; %SUM := 'Регистрация скриптованой аксиоматики'
      aMade -&gt; Visibility := PrivateAccess
      aMade -&gt; Abstraction := at_final
      aMade -&gt; "ifdef" := ( Self .IfDefStr )
      aMade -&gt; "ifndef" := ( Self .IfNDefStr )
      aMade -&gt; "register in scripts" := false
      aMade -&gt; "need UC" := true
      
      aMade -&gt; Operations := [
       'RegAxiom' MakeIniProcedure: (
         IN aMadeIni
        aMadeIni -&gt; %SUM := 'Регистрация скриптованой аксиоматики'
        aMadeIni .AddMethodWithParams: cUserCodePrefix aMade .RegAxiomUC
       ) // MakeIniProcedure:
      ] // aMade -&gt; Operations
      
      aMade -&gt; Implemented := [
       GarantModel::TtfwAxiomaticsResNameGetter.ResName .ImplementMethod
      ] // aMade -&gt; Implemented
     ) // l_ClassName GarantModel::TtfwAxiomaticsResNameGetter MakeClass:
    ] // .join&gt;
   end // ( l_Children l_ClassName .HasModelElementWithName ! )
  end // ( Self .NeedsScript )
  
  .joinWithLambded&gt; (
  Self .OperationsEx
  .filter&gt; .IsIterator
  .filter&gt; ( .IsServiceIterator ! )
  .filter&gt; ( .IsOverride ! )
  .filter&gt; ( l_Children SWAP .IteratorAction .Name .HasModelElementWithName ! )
  ) ( .ToArray: .IteratorAction )
  
  array:Copy
 )
 &gt;&gt;&gt; Result
; // ChildrenEx

elem_iterator ChildrenWithoutOwnFile
 Cached:
 ( 
  Self .ChildrenEx 
  .filter&gt; ( .NeedOwnFile ! ) 
 )
 &gt;&gt;&gt; Result
; // ChildrenWithoutOwnFile

elem_iterator ChildrenWithOwnFile
 Cached:
 ( 
  Self .ChildrenEx 
  .filter&gt; .NeedOwnFile
  array:Copy
 )
 &gt;&gt;&gt; Result
; // ChildrenWithOwnFile

INTERFACE FUNCTION MakeConstants:
  STRING IN aName
  ^ IN aLambda
 aName nil MakeParam: ( 
   IN aMade
  aMade -&gt; Stereotype := st_Constants
  aMade aLambda DO
 )
 &gt;&gt;&gt; Result 
; // MakeConstants:
  
INTERFACE FUNCTION MakeConstant:
  STRING IN aName
  PRINTABLE IN aValue
  ^ IN aLambda
 aName nil MakeParam: ( 
   IN aMade
  aMade -&gt; Class := class_Attribute
  aMade -&gt; 'extprop:pas:Value' := aValue
  aMade aLambda DO
 )
 &gt;&gt;&gt; Result 
; // MakeConstant:

elem_iterator ConstantsEx
 Cached:
 (
  Self .Constants
  
  RULES
   ( Self .IsTypedef )
    begin
     VAR l_OtherEnum
     Self .MainAncestor &gt;&gt;&gt; l_OtherEnum
     RULES
      ( l_OtherEnum .IsEnum )
       RULES
        ( Self .Name l_OtherEnum .Name == )
         RULES
          ( l_OtherEnum .Attributes .NotEmpty )
           begin
            VAR l_ConstantsName
            [ Self .Name cUnderline l_OtherEnum .Name cUnderline 'Constants' ] strings:Cat &gt;&gt;&gt; l_ConstantsName
            RULES
             ( 
              Self .Parent call.me 
              .filter&gt; ( .Name l_ConstantsName == )
              .IsEmpty
             )
              begin
               .join&gt;
               [
                VAR l_ElementPrefix
                l_OtherEnum .GetUP 'extprop:pas:ElementPrefix' &gt;&gt;&gt; l_ElementPrefix
                l_ConstantsName MakeConstants: (
                  IN aConstants
                 aConstants -&gt; %SUM := ( [ 'Алиасы для значений ' l_OtherEnum .Parent .Name cDot l_OtherEnum .Name ] strings:Cat )
                 aConstants -&gt; Visibility := PublicAccess
                 //aConstants -&gt; 'extprop:pas:ElementPrefix' := l_ElementPrefix
                 aConstants -&gt; Attributes := [
                  l_OtherEnum .Attributes .for&gt; (
                    IN anItem
                   VAR l_Name 
                   [ l_ElementPrefix anItem .Name ] strings:Cat &gt;&gt;&gt; l_Name
                   l_Name
                   [ l_OtherEnum .EffectiveUnitName cDot l_Name ] strings:Cat 
                   MakeConstant: (
                     IN aConstant
                    RULES
                     ( anItem .Documentation .IsNotNil )
                      ( aConstant -&gt; %SUM := ( anItem .Documentation ) )
                    ; // RULES 
                   ) // MakeConstant:
                  ) // l_OtherEnum .Attributes .for&gt;
                 ] // aConstants -&gt; Attributes
                ) // MakeConstants:
               ] // .join&gt;
              end
            ; // RULES
           end // ( l_OtherEnum .Attributes .NotEmpty )
         ; // RULES
       ; // RULES
     ; // RULES
    end // ( Self .IsTypedef )
  ; // RULES
  array:Copy
 )
 &gt;&gt;&gt; Result
; // ConstantsEx

elem_iterator ConstantsAndChildrenWithoutOwnFile
 Cached:
 ( 
  Self .ConstantsEx
  .join&gt; ( Self .ChildrenWithoutOwnFile )
 )
 &gt;&gt;&gt; Result
; // ConstantsAndChildrenWithoutOwnFile

elem_iterator AllOwnChildren
 Cached:
 ( 
  Self .ConstantsAndChildrenWithoutOwnFile
  .join&gt; ( Self .AttributesAndOperations )
 )
 &gt;&gt;&gt; Result
; // AllOwnChildren

ARRAY FUNCTION .OperationsNeededElements
  ARRAY IN anArray
 anArray .mapToTargetAndValueType&gt;
 .join&gt; ( 
  anArray 
  .filter&gt; .IsMessageOperation
  .filter&gt; ( .GetUP "Message ID" 'CM_' SWAP StartsStr )
  .map&gt; ( DROP GarantModel::Controls ) 
 ) // .join&gt;
 .joinWithLambded&gt; anArray ( .Parameters .mapToTargetAndValueType&gt; )
 .joinWithLambded&gt; anArray ( .AttributesAndOperations call.me )
 .joinWithLambded&gt; ( anArray .filter&gt; .IsFactoryMethod ) ( .MethodParameters .mapToTargetAndValueType&gt; )
 .joinWithLambded&gt; ( anArray .filter&gt; .IsIterator ) ( .MethodParameters .mapToTargetAndValueType&gt; )
 .joinWithLambded&gt; ( anArray .filter&gt; .IsFactoryMethod ) ( .ToArray: .MainImplementsInterface )
 .joinWithLambded&gt; ( anArray .filter&gt; .IsMethod .map&gt; .MainAncestor .filterNil&gt; ) ( .MethodParameters .mapToTargetAndValueType&gt; )
 .joinWithLambded&gt; ( anArray .filter&gt; .IsMethod 
                     .map&gt; .MainAncestor 
                     .filterNil&gt; 
                     .map&gt; .MethodType 
                     .filterNil&gt; ) ( .ToArray )
 .joinWithLambded&gt; anArray .CanRaise
 .joinWithLambded&gt; anArray .CanRaiseInSet 
 &gt;&gt;&gt; Result 
; // .OperationsNeededElements

elem_iterator NeededElementsFromInheritsOrImplements
 Cached:
 (
  ( Self .InheritsEx )
  .join&gt; ( Self .ImplementsEx .filter&gt; ( .IsEvdSchemaElement ! ) )
 )
 &gt;&gt;&gt; Result
; // NeededElementsFromInheritsOrImplements

elem_iterator AttributesAndOperationsNeededElements
 Self .AttributesAndOperations 
 .OperationsNeededElements
 &gt;&gt;&gt; Result
; // AttributesAndOperationsNeededElements

BOOLEAN elem_func InheritsFromOrSomeAncestorImplements
  ModelElement IN anIntf
 RULES 
  ( Self anIntf .InheritsFrom )
   true 
  ( Self anIntf .SomeAncestorImplements )
   true
  DEFAULT
   false     
 ; // RULES      
 &gt;&gt;&gt; Result      
; // InheritsFromOrSomeAncestorImplements
       
BOOLEAN elem_func HasManagedAttributes
 Cached:
 (
  RULES
   ( Self .IsNil )
    false
   DEFAULT
    ( 
     Self .Fields
     .filter&gt; .IsFieldForCleanup
     .NotEmpty
    )
  ; // RULES  
 )
 &gt;&gt;&gt; Result
; // HasManagedAttributes

BOOLEAN FUNCTION .HasModelElement
  ARRAY IN anArray
  ModelElement IN anElement
 anArray .HasSomeOf: ( anElement .IsSameModelElement )
 &gt;&gt;&gt; Result
; // .HasModelElement

elem_iterator OverriddenEx
 Cached:
 (
  VAR l_Overridden
  Self .Overridden &gt;&gt;&gt; l_Overridden
  
  l_Overridden
  
  if ( Self .IsClassOrMixIn ) then
  begin
   if ( Self .HasManagedAttributes ) then
   begin
    if ( Self GarantModel::l3UnknownPrim .InheritsFromOrSomeAncestorImplements ) then
    begin
     if ( l_Overridden GarantModel::l3UnknownPrim.ClearFields .HasModelElement ! ) then
     begin     
      .join&gt; ToArray: ( GarantModel::l3UnknownPrim.ClearFields .OverrideMethod )
     end // ( l_Overridden GarantModel::l3UnknownPrim.ClearFields .HasModelElement )
    end // ( Self GarantModel::l3UnknownPrim .InheritsFromOrSomeAncestorImplements )
   end // ( Self .HasManagedAttributes )
   
   if ( Self .IsScriptKeyword ) then
   begin
    if ( Self .IsMixIn ! ) then
    begin
     if ( Self .Abstraction at_abstract != ) then
     begin
      if ( Self GarantModel::TtfwRegisterableWord .InheritsFromOrSomeAncestorImplements ) then
      begin
       if ( l_Overridden GarantModel::TtfwRegisterableWord.GetWordNameForRegister .HasModelElement ! ) then
       begin     
        .join&gt; ToArray: ( GarantModel::TtfwRegisterableWord.GetWordNameForRegister .OverrideMethod )
       end // ( l_Overridden GarantModel::TtfwRegisterableWord.GetWordNameForRegister .HasModelElement )
      end // ( Self GarantModel::TtfwRegisterableWord .InheritsFromOrSomeAncestorImplements ) 
     end // ( Self .Abstraction at_abstract != )
    end // ( Self .IsMixIn ! )

    BOOLEAN VAR l_HasDoIt
    ( l_Overridden 
      .join&gt; ( Self .ImplementedEx ) 
      GarantModel::TtfwWordPrim.DoDoIt .HasModelElement )
    &gt;&gt;&gt; l_HasDoIt
    
    VAR l_Op
    Self .KeywordOperation &gt;&gt;&gt; l_Op
    if (
        ( l_Op .IsNotNil ) 
        AND ( l_Op .IsSomeKeyWord )
       ) then
    begin
     if (
          ( l_Op .GetUP "SupressNextImmediate" .IsNotNil )
          AND ( l_Op .GetUP "SupressNextImmediate" 'None' != )
        ) then
     begin
      if ( l_Overridden GarantModel::TtfwCompilingWord.SuppressNextImmediate .HasModelElement ! ) then
      begin     
       .join&gt; ToArray: ( GarantModel::TtfwCompilingWord.SuppressNextImmediate .OverrideMethod )
      end // ( l_Overridden GarantModel::TtfwCompilingWord.SuppressNextImmediate .HasModelElement ! )
     end // ( l_Op .GetUP "SupressNextImmediate" .IsNotNil )
     
     if ( l_Overridden GarantModel::TtfwWord.GetResultTypeInfo .HasModelElement ! ) then
     begin     
      .join&gt; ToArray: ( GarantModel::TtfwWord.GetResultTypeInfo .OverrideMethod )
     end // ( l_Overridden GarantModel::TtfwWord.GetResultTypeInfo .HasModelElement ! )
     
     if ( l_Overridden GarantModel::TtfwWord.GetAllParamsCount .HasModelElement ! ) then
     begin     
      .join&gt; ToArray: ( GarantModel::TtfwWord.GetAllParamsCount .OverrideMethod )
     end // ( l_Overridden GarantModel::TtfwWord.GetAllParamsCount .HasModelElement ! )
     
     if ( l_Op .IsVarWorker ) then
     begin
      if ( l_Overridden GarantModel::TtfwWord.RightParamsCount .HasModelElement ! ) then
      begin     
       .join&gt; ToArray: ( GarantModel::TtfwWord.RightParamsCount .OverrideMethod )
      end // ( l_Overridden GarantModel::TtfwWord.RightParamsCount .HasModelElement ! )
     end // ( l_Op .IsVarWorker )
     
     if ( l_Op .UPisTrue "bind params" ) then
     begin
      if ( l_Overridden GarantModel::TtfwClassLike.BindParams .HasModelElement ! ) then
      begin     
       .join&gt; ToArray: ( GarantModel::TtfwClassLike.BindParams .OverrideMethod )
      end // ( l_Overridden GarantModel::TtfwClassLike.BindParams .HasModelElement ! )
     end // ( l_Op .UPisTrue "bind params" )
     
     if ( l_Overridden GarantModel::TtfwWord.ParamsTypes .HasModelElement ! ) then
     begin     
      .join&gt; ToArray: ( GarantModel::TtfwWord.ParamsTypes .OverrideMethod )
     end // ( l_Overridden GarantModel::TtfwWord.ParamsTypes .HasModelElement ! )
     
     if ( 
         ( l_Op .GetUP 'extprop:prop_stereo' .IsValueValid )
         OR ( l_Op .UPisTrue "lvalue" )
        ) then
     begin
      if ( l_Overridden GarantModel::TtfwWord.SetValuePrim .HasModelElement ! ) then
      begin     
       .join&gt; ToArray: ( GarantModel::TtfwWord.SetValuePrim .OverrideMethod )
      end // ( l_Overridden GarantModel::TtfwWord.SetValuePrim .HasModelElement ! )
     end // ( l_Op .GetUP 'extprop:prop_stereo' .IsValueValid )
     
     if ( l_Op .IsVarWorker ) then
     begin
      if ( l_Overridden GarantModel::TtfwAnonimousWord.DoRun .HasModelElement ! ) then
      begin     
       .join&gt; ToArray: ( GarantModel::TtfwAnonimousWord.DoRun .OverrideMethod )
       true &gt;&gt;&gt; l_HasDoIt
      end // ( l_Overridden GarantModel::TtfwAnonimousWord.DoRun .HasModelElement ! )
     end // ( l_Op .IsVarWorker )
     else
     begin
      if ( l_HasDoIt ! ) then
      begin     
       .join&gt; ToArray: ( GarantModel::TtfwWordPrim.DoDoIt .OverrideMethod )
       true &gt;&gt;&gt; l_HasDoIt
      end // ( l_HasDoIt ! )
     end // ( l_Op .IsVarWorker )
     
    end // ( l_Op .IsNotNil )
    
    if ( l_HasDoIt ! ) then
    begin
     if ( 
         Self .InheritsEx 
         .filter&gt; ( GarantModel::TtfwRegisterableWord .IsSameModelElement )
         .NotEmpty 
        ) then
     begin
      //Self .Name Msg
      .join&gt; ToArray: ( GarantModel::TtfwWordPrim.DoDoIt .OverrideMethod )
     end // .filter&gt; ( GarantModel::TtfwRegisterableWord .IsSameModelElement )
    end // ( l_HasDoIt ! )
    
   end // ( Self .IsScriptKeyword )
   
   if ( Self .GetUP "is immediate" IsBool ) then
   begin
    if ( Self GarantModel::TtfwWord .InheritsFromOrSomeAncestorImplements ) then
    begin
     if ( l_Overridden GarantModel::TtfwWord.IsImmediate .HasModelElement ! ) then
     begin     
      .join&gt; ToArray: ( GarantModel::TtfwWord.IsImmediate .OverrideMethod )
     end // ( l_Overridden GarantModel::TtfwWord.IsImmediate .HasModelElement )
    end // ( Self GarantModel::TtfwWord .InheritsFromOrSomeAncestorImplements ) 
   end // ( Self .GetUP "is immediate" IsBool )
   
  end // ( Self .IsClassOrMixIn )
  
  if ( Self .IsTestCase ) then
  begin
   if ( Self GarantModel::TBaseTest .InheritsFromOrSomeAncestorImplements ) then
   begin
    if ( l_Overridden GarantModel::TAbstractTest.GetFolder .HasModelElement ! ) then
    begin     
     .join&gt; ToArray: ( GarantModel::TAbstractTest.GetFolder .OverrideMethod )
    end // ( l_Overridden GarantModel::TAbstractTest.GetFolder .HasModelElement )
    
    if ( l_Overridden GarantModel::TAbstractTest.GetModelElementGUID .HasModelElement ! ) then
    begin     
     .join&gt; ToArray: ( GarantModel::TAbstractTest.GetModelElementGUID .OverrideMethod )
    end // ( l_Overridden GarantModel::TAbstractTest.GetModelElementGUID .HasModelElement )
   end // ( Self GarantModel::TBaseTest .InheritsFromOrSomeAncestorImplements )
  end // ( Self .IsTestCase )
  
  if ( Self .IsVCMApplication ) then
  begin
   .join&gt; ToArray: ( GarantModel::TComponent.Loaded .OverrideMethod )
  end // ( Self .IsVCMApplication )
 ) 
 &gt;&gt;&gt; Result
; // OverriddenEx

elem_iterator ImplementedAndOverridden
 Cached:
 (
  Self .ImplementedEx
  .join&gt; ( Self .OverriddenEx )
 ) 
 &gt;&gt;&gt; Result
; // ImplementedAndOverridden

elem_iterator NeededElements
 Cached:
 (
  if ( Self .IsScriptKeywordsPack ) then
  begin
   [empty]
  end // ( Self .IsScriptKeywordsPack ) 
  else
  begin 
   Self .NeededElementsFromInheritsOrImplements
  end // ( Self .IsScriptKeywordsPack )
  .join&gt; ( Self .AttributesAndOperationsNeededElements )
  if ( Self .IsTypedef ! ) then
  begin
   .join&gt; ( Self .ImplementedAndOverridden .OperationsNeededElements )
  end // Self .IsTypedef !
  if ( Self .IsClassOrMixIn ) then
  begin
   .joinWithLambded&gt; ( Self .ClassImplementsPrim ) .InterfaceForClassImplements
  end // ( Self .IsClassOrMixIn )
  .joinWithLambded&gt; ( Self .NeededElementsFromInheritsOrImplements .filter&gt; .IsMixIn ) call.me
  Self .NeededElementsFromInheritsOrImplements .filter&gt; .IsMixIn .for&gt; ( 
    IN anItem
   .joinWithLambded&gt; ( anItem .ConstantsAndChildrenWithoutOwnFile ) call.me
  )
 )
 &gt;&gt;&gt; Result
; // NeededElements

elem_iterator NeededElements:
  ^ IN aChildAcceptable
 if ( Self aChildAcceptable DO ) then
 begin 
  Self .NeededElements
 end // ( Self aChildAcceptable DO )
 else
  [empty]
 &gt;&gt;&gt; Result 
; // NeededElements:

elem_iterator NeededElementsTotal
  IN aChildAcceptable
  
 [empty]
  
 .joinWithLambded&gt; ( Self .ConstantsAndChildrenWithoutOwnFile .filter&gt; ( aChildAcceptable DO ) ) .NeededElements
 
 .joinWithLambded&gt; ( Self .ConstantsAndChildrenWithoutOwnFile ) ( aChildAcceptable call.me )
 
 &gt;&gt;&gt; Result
; // NeededElementsTotal

elem_iterator NeededElementsTotal:
  ^ IN aChildAcceptable
 Self aChildAcceptable .NeededElementsTotal
 &gt;&gt;&gt; Result
; // NeededElementsTotal:

BOOLEAN elem_func IsForInterfacePrim
 Cached:
 (
  RULES
   ( Self .Visibility PublicAccess == )
    true
   ( Self .Visibility ProtectedAccess == )
    true
   DEFAULT
    false 
  ; // RULES
 ) 
 &gt;&gt;&gt; Result
; // IsForInterfacePrim

BOOLEAN elem_func IsForInterface
 Cached:
 (
  RULES
   ( Self .Parent .IsNotNil )
    RULES
     ( Self .Parent call.me )
      ( Self .IsForInterfacePrim )
     DEFAULT
      false
    ; // RULES
   ( Self .IsForInterfacePrim )
    true  
   DEFAULT
    false
  ; // RULES
 ) 
 &gt;&gt;&gt; Result
; // IsForInterface

BOOLEAN elem_func IsForImplementation
 Cached:
 (
  Self .IsForInterface ! 
 ) 
 &gt;&gt;&gt; Result
; // IsForImplementation

BOOLEAN elem_func IsVCMControls
 Self .IsStereotype st_VCMControls
 &gt;&gt;&gt; Result
; // IsVCMControls

elem_iterator DependsEx
 Cached:
 (
  Self .Depends
  array:Copy
 ) 
 &gt;&gt;&gt; Result
; // DependsEx

elem_iterator IntfUses
 Cached:
 (
  GarantModel::l3IntfUses .ToArray
  
  if ( Self .IsInterfaces ) then
  begin
   .join&gt; ( Self .DependsEx .filter&gt; .IsInterfaces )
  end // ( Self .IsInterfaces )
  
  .join&gt; ( Self .NeededElements: .IsForInterface )
  .join&gt; ( Self .NeededElementsTotal: .IsForInterface )
  
  if ( Self .IsControllerInterfaces ) then
  begin
   .join&gt; ToArray: GarantModel::vcmInterfaces 
   .join&gt; ToArray: GarantModel::vcmControllers
  end // ( Self .IsControllerInterfaces )
  
  if ( Self .IsVCMControls ) then
  begin
   .join&gt; ToArray: GarantModel::vcmExternalInterfaces 
  end // ( Self .IsVCMControls )
 ) 
 &gt;&gt;&gt; Result
; // IntfUses

BOOLEAN elem_func IsInjects
 Self .IsStereotype st_injects::Dependency 
 &gt;&gt;&gt; Result
; // IsInjects

elem_iterator InjectedElements
 Cached:
 (
  Self .Injected 
  .filter&gt; .IsInjects
  .map&gt; .Parent
  array:Copy
 ) 
 &gt;&gt;&gt; Result
; // InjectedElements

BOOLEAN elem_func IsUses
 Self .IsStereotype st_uses::Dependency 
 &gt;&gt;&gt; Result
; // IsUses

elem_iterator UsesInDependencies
 Cached:
 (
  Self .Dependencies 
  .filter&gt; .IsUses 
  .mapToTarget&gt;
  array:Copy
 ) 
 &gt;&gt;&gt; Result
; // UsesInDependencies

BOOLEAN elem_func IsFactoryInTie
 ( Self .IsFactory )
 AND ( Self .InTie )
 &gt;&gt;&gt; Result
; // IsFactoryInTie

INTERFACE elem_func InstanceFreeMethod
 Cached:
 (
  VAR l_TypeName
  Self .TypeName &gt;&gt;&gt; l_TypeName
  l_TypeName 'Free' Cat MakeProcedure: ( 
    IN aMade
   aMade -&gt; %SUM := ( 'Метод освобождения экземпляра синглетона ' l_TypeName Cat )
   aMade -&gt; Visibility := PrivateAccess
   aMade -&gt; "ifdef" := ( Self .IfDefStr )
   aMade -&gt; "ifndef" := ( Self .IfNDefStr )
   aMade -&gt;^ cVarUserCodeName ^:= cEmptyUserCode
   aMade -&gt;^ cImplementationUserCodeName ^:= [ 
    if ( Self .HasFactory ) then
    begin
     ' IUnknown(' 'g_' l_TypeName ') := nil;' 
    end
    else
    begin
     ' l3Free(' 'g_' l_TypeName ');' 
    end // ( Self .HasFactory )
   ]
  ) 
 )
 &gt;&gt;&gt; Result
; // InstanceFreeMethod

elem_iterator GlobalOperationsPrim
 Cached:
 (
  RULES
   ( Self .IsInterface )
    ( 
     Self .OperationsEx
     .filter&gt; .IsStaticMethod
     .filter&gt; ( .IsFactoryInTie ! )
    ) 
   ( Self .IsRecord )
    ( 
     Self .OperationsEx
     .filter&gt; .IsConstructor
    ) 
   ( Self .IsUtilityPack )
    ( Self .OperationsEx )
   ( Self .IsClassOrMixIn ) 
    (
     if ( Self .IsSingleton ) then
     begin
      [ Self .InstanceFreeMethod ]
     end // ( Self .IsSingleton )
     else
      [empty]
    )
   DEFAULT
    [empty]
  ; // RULES
  
  VAR l_Operations
  array:Copy &gt;&gt;&gt; l_Operations
  l_Operations
  
  .joinWithLambded&gt; (
  Self .OperationsEx
  .filter&gt; .IsIterator
  .filter&gt; ( .IsServiceIterator ! )
  .filter&gt; ( .IsOverride ! )
  .filter&gt; ( l_Operations SWAP .IteratorStub .Name .HasModelElementWithName ! )
  ) ( .ToArray: .IteratorStub )
 )
 &gt;&gt;&gt; Result
; // GlobalOperationsPrim

elem_iterator GlobalOperations
 Self .GlobalOperationsPrim
 .filter&gt; ( .IsIni ! )
 .filter&gt; ( .IsFini ! )
 .filter&gt; ( .IsKeyWord ! )
 .filter&gt; ( .IsGlobalKeyWord ! )
 &gt;&gt;&gt; Result
; // GlobalOperations

elem_iterator OperationsUsed
 [empty]
 .joinWithLambded&gt; ( Self .OperationsEx ) .UsesInDependencies
 
 .joinWithLambded&gt; (
  Self .GlobalOperations
  .filter&gt; .IsStaticOp
  .filter&gt; ( .UPisTrue 'extprop:isAsm' )
 ) ( DROP ToArray: GarantModel::l3LocalStub )
 
 .joinWithLambded&gt; ( Self .OperationsEx ) call.me
 &gt;&gt;&gt; Result
; // OperationsUsed

elem_iterator MixInValues
 Self .Attributes
 .filter&gt; ( .IsStereotype st_impurity_value::Attribute )
 &gt;&gt;&gt; Result
; // MixInValues

BOOLEAN elem_func InheritsOrImplementsMixIn
 Cached:
 (
  RULES
   ( Self .InheritsEx .filter&gt; .IsMixIn .NotEmpty )
    true
   ( Self .ImplementsEx .filter&gt; .IsMixIn .NotEmpty )
    true
   DEFAULT
    false
  ; // RULES 
 )
 &gt;&gt;&gt; Result
; // InheritsOrImplementsMixIn

BOOLEAN elem_func ImplementsMixIn
 Cached:
 (
  RULES
   //( Self .InheritsEx .filter&gt; .IsMixIn .NotEmpty )
   // true
   ( Self .ImplementsEx .filter&gt; .IsMixIn .NotEmpty )
    true
   DEFAULT
    false
  ; // RULES 
 )
 &gt;&gt;&gt; Result
; // ImplementsMixIn

elem_iterator OtherMixinValuesUses
 [empty]
 .joinWithLambded&gt; ( Self .InheritsEx ) ( .MixInValues .mapToTarget&gt; )
 .joinWithLambded&gt; ( Self .InheritsEx ) call.me
 &gt;&gt;&gt; Result
; // OtherMixinValuesUses

BOOLEAN elem_func IsClass
 Self .IsSimpleClass &gt;&gt;&gt; Result
; // IsClass

BOOLEAN elem_func NeedRegisterInScriptsPrim
 Cached:
 (
  RULES
   ( Self .GetUP "register in scripts" false ?== )
    false
   ( Self .UPisTrue "register in scripts" )
    true
   ( Self .InheritsEx .filter&gt; call.me .NotEmpty )
    true
   ( Self .IsGuiControl )
    true 
   DEFAULT
    false
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // NeedRegisterInScriptsPrim

BOOLEAN elem_func NeedRegisterInScripts
 Cached:
 (
  RULES
   ( Self .IsMixIn )
    false
   ( Self .IsVCMCustomForm )
    true
   ( Self .NeedRegisterInScriptsPrim )
    RULES
     ( Self .Name 'Hack' string:Pos -1 != )
      false
     ( Self .IsMixIn )
      false 
     ( Self .Abstraction at_abstract == ) 
      true
     ( Self .IsScriptKeyword )
      false
     ( Self .IsTestClass ) 
      false
     ( Self .IsClass )
      true 
     ( Self .IsEnum )
      true 
     ( Self .IsException )
      true
     ( Self .IsInterface )
      true
     DEFAULT
      false
    ; // RULES
   DEFAULT
    false
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // NeedRegisterInScripts

elem_iterator ImplementsIsInterface
 Cached:
 (
  Self .ImplementsEx .filter&gt; .IsInterface
 ) 
 &gt;&gt;&gt; Result
; // ImplementsIsInterface

elem_iterator Used
 Cached:
 (
  Self .UsesInDependencies
  if ( Self .IsInterface ! ) then
  begin
   .join&gt; ( Self .InjectedElements )
   .joinWithLambded&gt; ( Self .ImplementsIsInterface ) .InjectedElements
  end // Self .IsInterface !
  .joinWithLambded&gt; ( Self .InheritsEx .filter&gt; .IsMixIn ) call.me
  .joinWithLambded&gt; ( Self .ImplementsEx .filter&gt; .IsMixIn ) call.me
  .join&gt; ( Self .OperationsUsed )
  
  if ( Self .InheritsOrImplementsMixIn ) then
  begin
   .join&gt; ( Self .OtherMixinValuesUses )
  end // ( Self .InheritsOrImplementsMixIn )
  
  if ( Self .IsSingleton ) then
  begin
   .join&gt; ToArray: GarantModel::SysUtils 
   .join&gt; ToArray: GarantModel::l3Base
  end // ( Self .IsSingleton )
  
  if ( Self .IsClassOrMixIn ) then
  begin
   if ( Self .ImplementedAndOverridden 
        .filter&gt; .IsIterator 
        .NotEmpty ) then
   begin
    .join&gt; ToArray: GarantModel::l3Base 
   end // ( Self .ImplementedAndOverridden .filter&gt; .IsIterator .NotEmpty )
   .joinWithLambded&gt; ( Self .ImplementedAndOverridden ) .UsesInDependencies
  end // ( Self .IsClassOrMixIn )
  
  if ( Self .NeedRegisterInScripts ) then
  begin
   RULES
    ( Self .IsEnum )
     begin
      .join&gt; ToArray: GarantModel::TtfwTypeRegistrator(Proxy)
     end // ( Self .IsEnum )
    ( Self .IsException )
     begin
      .join&gt; ToArray: GarantModel::TtfwTypeRegistrator(Proxy)
     end // ( Self .IsException )
    ( Self .IsInterface )
     begin
      .join&gt; ToArray: GarantModel::TtfwTypeRegistrator(Proxy)
     end // ( Self .IsInterface )
    ( Self GarantModel::TtfwWord .InheritsFrom ! )
     begin
      .join&gt; ToArray: GarantModel::TtfwClassRef(Proxy) 
     end // ( Self GarantModel::TtfwWord .InheritsFrom ! )
   ; // RULES
  end // ( Self .NeedRegisterInScripts )
  
  if ( Self .IsTestCase ) then
  begin
   .join&gt; ToArray: GarantModel::TestFrameWork 
  end // ( Self .IsTestCase )  
  
 )
 &gt;&gt;&gt; Result
; // Used

elem_iterator UsedTotal
 Self .Used
 .joinWithLambded&gt; ( Self .AllOwnChildren ) call.me
 &gt;&gt;&gt; Result
; // UsedTotal

elem_iterator AbstractUses
 Cached:
 (
  [empty]
  ( 
   Self .InheritsEx
   .filter&gt; .IsSimpleClass 
   .filter&gt; ( .Abstraction at_abstract == )
  ) .for&gt; ( 
    IN aG
   .joinWithLambded&gt; ( 
    aG .ImplementsEx
    .filter&gt; .IsMixIn
   ) // .joinWithLambded&gt; 
   .UsesInDependencies
   .join&gt; ( aG call.me ) 
  ) // .for&gt;
 ) 
 &gt;&gt;&gt; Result
; // AbstractUses

BOOLEAN elem_func IsTestForTestLibrary
 RULES
  ( Self .IsTestClass )
   true
  ( Self .IsTestCaseMixIn )
   true
  ( Self .IsTestCase )
   RULES
    ( Self .Abstraction at_abstract == )
     false
    DEFAULT
     true
   ; // RULES 
  DEFAULT
   false
 ; // RULES
 &gt;&gt;&gt; Result
; // IsTestForTestLibrary

elem_iterator DependsVCMGUI
 Cached:
 (
  Self .DependsEx
  .filter&gt; .IsVCMGUI
  array:Copy
 ) 
 &gt;&gt;&gt; Result
; // DependsVCMGUI

elem_iterator DependsTestLibrary
 Cached:
 (
  Self .DependsEx
  .filter&gt; .IsTestLibrary
  array:Copy
 ) 
 &gt;&gt;&gt; Result
; // DependsTestLibrary

elem_iterator ImplUses
 Cached:
 (
  GarantModel::l3ImplUses .ToArray
  if ( Self .IsScriptKeywordsPack ) then
  begin
   .join&gt; ( Self .NeededElementsFromInheritsOrImplements )
  end // ( Self .IsScriptKeywordsPack )  
  
  .join&gt; ( Self .NeededElements: .IsForImplementation )
  .join&gt; ( Self .NeededElementsTotal: .IsForImplementation )
  .join&gt; ( Self .UsedTotal )
  
  if ( Self .IsScriptKeywordsPack ) then
  begin
   .join&gt; ( Self .ChildrenWithOwnFile )
   .join&gt; ToArray: GarantModel::SysUtils
   .join&gt; ToArray: GarantModel::TtfwTypeRegistrator(Proxy)
   .join&gt; ToArray: GarantModel::TypeInfoExt
  end // ( Self .IsScriptKeywordsPack )
  
  if ( Self .IsTarget ) then
  begin
   .join&gt; ( Self .ChildrenWithOwnFile )
  end // ( Self .IsTarget )
  
  if ( Self .IsVCMCustomForm ) then
  begin
   .join&gt; ( Self .ChildrenWithOwnFile )
  end // ( Self .IsVCMCustomForm )
  
  if ( Self .IsVCMFormsPack ) then
  begin
   .join&gt; ( Self .ChildrenWithOwnFile )
  end // ( Self .IsVCMFormsPack )
  
  if ( Self .IsVCMFormSetFactory ) then
  begin
   .join&gt; ( Self .ChildrenWithOwnFile )
  end // ( Self .IsVCMFormSetFactory )
  
  if ( Self .IsVCMApplication ) then
  begin
   .join&gt; ( Self .ChildrenWithOwnFile )
   .join&gt; ToArray: GarantModel::evExtFormat
   if ( Self .Abstraction at_final == ) then
   begin
    .join&gt; ToArray: GarantModel::StdRes
   end // ( Self .Abstraction at_final == )
  end // ( Self .IsVCMApplication )
  
  if ( Self .IsVCMUseCaseRealization ) then
  begin
   .join&gt; ( Self .ChildrenWithOwnFile )
  end // ( Self .IsVCMUseCaseRealization )
  
  if ( Self .IsTestLibrary ) then
  begin
   .join&gt; ( Self .ChildrenWithOwnFile .filter&gt; .IsTestUnit )
  end // ( Self .IsTestLibrary )
  
  if ( Self .IsTestUnit ) then
  begin
   .join&gt; ( Self .ChildrenWithOwnFile .filter&gt; .IsTestForTestLibrary )
  end // ( Self .IsTestUnit )
  
  if ( Self .IsClassOrMixIn ) then
  begin
   .join&gt; ( Self .AbstractUses )
  end // ( Self .IsClassOrMixIn )
   
  if ( Self .IsTestClass ) then
  begin
   .join&gt; ToArray: GarantModel::Variants 
   .join&gt; ToArray: GarantModel::ActiveX 
   .join&gt; ToArray: GarantModel::tc5OpenAppClasses 
   .join&gt; ToArray: GarantModel::tc5PublicInfo 
   .join&gt; ToArray: GarantModel::tc6OpenAppClasses 
   .join&gt; ToArray: GarantModel::tc6PublicInfo
  end // ( Self .IsTestClass )
   
  if ( Self .Name 'l3IID' == ) then
  begin
   .join&gt; ToArray: GarantModel::Windows 
   .join&gt; ToArray: GarantModel::SysUtils
  end // ( Self .Name 'l3IID' == )
  
  RULES
   ( Self .IsTestTarget )
    begin
     .join&gt; ToArray: GarantModel::SysUtils
     .join&gt; ToArray: GarantModel::l3Base
     .join&gt; ToArray: GarantModel::TKBridge
     .join&gt; ToArray: GarantModel::KTestRunner
     .join&gt; ToArray: GarantModel::TextTestRunner
     .join&gt; ToArray: GarantModel::GUITestRunner
     if ( Self .UPisTrue "no scripts" ! ) then
     begin
      .join&gt; ToArray: GarantModel::TvcmInsiderTest 
     end // ( Self .UPisTrue "no scripts" ! )
    end // ( Self .IsTestTarget )
  ; // RULES 
  
  RULES
   ( Self .IsVCMTestTarget )
    begin
     RULES
      (
       Self .DependsVCMGUI
       .filter&gt; ( .GetUP "F1Like" false ?== )
       .IsEmpty
      )
       ( .join&gt; ToArray: GarantModel::TF1AutoTestSuite )
      DEFAULT
       ( .join&gt; ToArray: GarantModel::TAutoTestsSuite )
     ; // RULES 
     .join&gt; ToArray: GarantModel::StdRes
    end // ( Self .IsVCMTestTarget )
   ( Self .IsTestTarget )
    begin
     if ( Self .UPisTrue "is insider test" ! ) then
     begin
      if ( Self .UPisTrue "no scripts" ! ) then
      begin
       .join&gt; ToArray: GarantModel::TAutoTestsSuite
       .join&gt; ToArray: GarantModel::TtfwScriptEngineEX
      end // ( Self .UPisTrue "no scripts" ! )
     end // ( Self .UPisTrue "is insider test" ! )
    end // ( Self .IsTestTarget )
   ( Self .IsVCMGUI ) 
    ( .join&gt; ToArray: GarantModel::StdRes )
  ; // RULES
  
  RULES
   ( Self .IsTestLibrary )
    begin
     .join&gt; ( Self .DependsTestLibrary )
          
     RULES
      (
       Self .ChildrenEx 
       .filter&gt; .IsTestUnit 
       .filter&gt; ( 
        .ChildrenEx 
        .filter&gt; .IsTestClass 
        .NotEmpty
       ) // .filter&gt;
       .NotEmpty
      )
      begin
       .join&gt; ToArray: GarantModel::tc5OpenApp 
       .join&gt; ToArray: GarantModel::tc6OpenApp
      end
     ; // RULES
    end // ( Self .IsTestLibrary )
   ( Self .IsTestTarget )
    begin
    
     VAR l_Parent
     Self .Parent &gt;&gt;&gt; l_Parent
     
     // Сначала перебираем чужие тестовые библиотеки:
     .join&gt; (
      Self .DependsTestLibrary
      .filter&gt; ( .Parent l_Parent .IsSameModelElement ! )
      array:Copy
     ) // .join&gt;
     
     // Потом перебираем свои тестовые библиотеки:
     .join&gt; (
      Self .DependsTestLibrary
      .filter&gt; ( .Parent l_Parent .IsSameModelElement )
      array:Copy
     ) // .join&gt;
     
    end // ( Self .IsTestTarget ) 
   ( Self .IsDLL ) 
    begin
     VAR l_Parent
     Self .Parent &gt;&gt;&gt; l_Parent
     
     Self .DependsEx
     .filter&gt; .IsLibrary
     .filter&gt; ( .Parent l_Parent .IsSameModelElement )
     .for&gt; (
       IN aLibrary
      
      aLibrary .ChildrenEx
      .for&gt; (
        IN aChild
       .join&gt; ToArray: aChild
      ) // .for&gt;
       
      aLibrary .ChildrenEx 
      .filter&gt; .IsUnit
      .for&gt; (
        IN aUnit
       aUnit .ChildrenEx 
       .for&gt; (
         IN aClass
        .join&gt; ToArray: aClass
       ) // .for&gt;
      ) // .for&gt;
     ) // .for&gt;
    end // ( Self .IsDLL )
   ( Self .IsVCMGUI )
    begin
     .join&gt; ( Self .DependsTestLibrary )
     
     Self .DependsEx
     .filter&gt; .IsVCMUseCase
     .for&gt; (
       IN aUseCase
      aUseCase .ChildrenEx
      .filter&gt; .IsVCMUseCaseRealization
      .for&gt; (
        IN aUseCaseRealization
       .join&gt; ToArray: aUseCaseRealization
      ) // .for&gt;
     ) // .for&gt;
    end // ( Self .IsVCMGUI )
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // ImplUses

elem_iterator IntfAndImplUses
 Self .IntfUses
 .join&gt; ( Self .ImplUses )
 &gt;&gt;&gt; Result
; // IntfAndImplUses

elem_iterator ProjectUsesPrim
 Cached:
 (
  GarantModel::l3IntfUses .ToArray
  
  RULES
   ( Self .IsVCMGUI )
    begin
     if ( Self .GetUP "F1Like" false ?!= ) then
     begin
      .join&gt; ToArray: GarantModel::nsApplication 
     end // ( Self .GetUP "F1Like" false ?!= )
     .join&gt; ToArray: GarantModel::Tl3ExceptionsLog 
     .join&gt; ToArray: GarantModel::ControlResizeBugFix
    end // ( Self .IsVCMGUI )
   ( Self .IsVCMTestTarget )
    begin
     .joinWithLambded&gt; ( Self .DependsVCMGUI ) call.me
    end // ( Self .IsVCMTestTarget )
   ( Self .IsExe )
    begin
     .join&gt; ToArray: GarantModel::Tl3ExceptionsLog 
     if ( Self .UPisTrue "console" ! ) then
     begin
      .join&gt; ToArray: GarantModel::ControlResizeBugFix
     end // ( Self .UPisTrue "console" ! )
    end // ( Self .IsExe )
  ; // RULES
  
  .join&gt; ( Self .IntfAndImplUses )
  
  RULES
   ( Self .IsVCMGUI )
    begin
     .join&gt; ToArray: GarantModel::Tl3MouseWheelHelper
    end // ( Self .IsVCMGUI )
  ; // RULES
  
  ARRAY VAR l_Uses
  [] &gt;&gt;&gt; l_Uses
  
  .mapToUnitProducer&gt;
  //.filter&gt; ( Self ?!= )
  .filter&gt; ( .NotInArray: l_Uses )
  // - возможно это стоит включить, а также включить сюда фильтрацию дубликатов
  //   чтобы уменьшить повторно выполняемую работу в ProjectUses AccumulateUses
  .for&gt; (
   .AddToArray: l_Uses
  ) // .for&gt;
  
  l_Uses
 )
 &gt;&gt;&gt; Result
; // ProjectUsesPrim

elem_iterator ProjectUses
 ARRAY VAR l_ProjectUses
 [] &gt;&gt;&gt; l_ProjectUses
 ARRAY VAR l_InUses
 [] &gt;&gt;&gt; l_InUses
 
 PROCEDURE AccumulateUses
   ARRAY IN aUses
  aUses 
  .for&gt; (
    IN anItem
   //if ( l_InUses .filter&gt; ( anItem ?== ) .IsEmpty ) then 
   if ( anItem .NotInArray: l_InUses ) then
   // - это можно в filter перенести, выше
   begin
    anItem .AddToArray: l_InUses
    anItem .AddToArray: l_ProjectUses
    RULES
     ( anItem IsString )
      ()
     DEFAULT
      ( anItem .ProjectUsesPrim call.me ) 
    ; // RULES 
   end // ( anItem .NotInArray: l_InUses )
  ) // .for&gt;
 ; // AccumulateUses
 
 Self .ProjectUsesPrim AccumulateUses
 
 l_ProjectUses
 &gt;&gt;&gt; Result
; // ProjectUses
     
ModelElement elem_func SecondAttribute
 Cached:
 (
  Self .Attributes .SecondElement
 )
 &gt;&gt;&gt; Result
; // SecondAttribute

STRING elem_func FineDocumentation
 Self .Documentation &gt;&gt;&gt; Result
 if ( Result .IsNotNil ) then
 begin
  Result cOpenComment '[' string:Replace &gt;&gt;&gt; Result
  Result cCloseComment ']' string:Replace &gt;&gt;&gt; Result
  [ cOpenComment '* ' Result cSpace cCloseComment ] strings:Cat &gt;&gt;&gt; Result
 end // Result .IsNotNil
; // FineDocumentation

elem_proc OutDocumentation
 STRING VAR l_Doc
 Self .FineDocumentation &gt;&gt;&gt; l_Doc
 if ( l_Doc .IsNotNil ) then
 begin
  Indented: ( l_Doc .Out )
 end // l_Doc .IsNotNil
; // OutDocumentation

STRING elem_func MethodCallingConventions
 RULES
  ( Self .InTie )
   'stdcall'
  ( Self .IsMethod )
   ( Self .FirstOperation .GetUP "calling conventions" )
  ( Self .IsFunction )
   ( Self .FirstOperation .GetUP "calling conventions" )
  DEFAULT
   ( Self .GetUP "calling conventions" )
 ; // RULES
 &gt;&gt;&gt; Result
 
 if ( Result 'none' == ) then
 begin
  cEmptyStr &gt;&gt;&gt; Result
 end // ( Result 'none' == )
 
 if ( Result .IsNotNil ) then
 begin
  cSpace Result ';' Cat Cat &gt;&gt;&gt; Result
 end // ( Result .IsNotNil )
; // MethodCallingConventions

CONST cConstPrefix 'const '

STRING elem_func InPrefix
 Cached:
 (
  RULES
   ( Self .IsNil )
    cConstPrefix
   ( Self .IsRecord )
    cConstPrefix
   ( Self .IsUnion )
    cConstPrefix
   ( Self .IsArray )
    cConstPrefix
   ( Self .IsInterface )
    cConstPrefix
   ( Self .IsTypedef )
    RULES
     ( Self .IsPointer )
      cEmptyStr
     DEFAULT
      ( Self .MainAncestor call.me )
    ; // RULES  
   ( Self .IsMixInParamType )
    cConstPrefix
   ( Self .IsString )
    cConstPrefix
   ( Self .IsUntyped )
    cConstPrefix
   DEFAULT
    cEmptyStr
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // InPrefix

STRING elem_func ParamPrefix
 RULES
  ( Self .IsStereotype st_in )
   ( Self .Target .InPrefix )
  ( Self .IsStereotype st_const )
   cConstPrefix
  ( Self .IsStereotype st_noconst )
   cEmptyStr
  ( Self .IsOutParam )
   'out '
  ( Self .IsStereotype st_inout )
   'var '
  DEFAULT
   ( Self .Target .InPrefix ) 
 ; // RULES
 &gt;&gt;&gt; Result
; // ParamPrefix

BOOLEAN elem_func IsDestructor
 RULES
  ( Self .MethodName 'Destroy' == )
   true
  ( Self .MethodName 'destroy' == )
   true
  DEFAULT
   false 
 ; // RULES 
 &gt;&gt;&gt; Result
; // IsDestructor

OUTABLE elem_func MethodKeyword
 Cached:
 (
  RULES
   ( Self .IsStaticConstructor )
    'function'
   ( Self .IsConstructor )
    ( 'constructor' )
   ( Self .IsFactory )
    ( 'class function' )
   ( Self .IsDestructor )
    ( 'destructor' )
   DEFAULT
   (
     ModelElement VAR l_Type
     Self .MethodType &gt;&gt;&gt; l_Type
     VAR l_IsFunc
     ( l_Type .IsNotNil ) AND ( l_Type .TypeName .IsNotNil ) &gt;&gt;&gt; l_IsFunc
     
     [
     RULES
      ( Self .ParentIsInterface )
       ()
      ( Self .UPisTrue 'extprop:isGlobal' )
       ()
      ( Self .IsStaticMethod )
       'class '
     ; // RULES 
  
     if l_IsFunc then
     begin
      'function'
     end // l_IsFunc
     else
     begin
      'procedure'
     end // l_IsFunc
     ]
   ) // DEFAULT
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // MethodKeyword

BOOLEAN elem_func IsInline
 Self .IsStereotype st_inline::Operation 
 &gt;&gt;&gt; Result
; // IsInline

BOOLEAN elem_func IsOperationOverride
 Self .IsStereotype st_override::Operation
 &gt;&gt;&gt; Result
; // IsOperationOverride

INTEGER elem_func MethodAbstraction
 Cached:
 (
  Self .OpKind CASE
   opkind_Normal
    ( 
     RULES
      ( Self .IsMessageOperation )
       at_message
      (
       ( Self .IsIterator )
       AND ( Self .MainAncestor .IsNotNil )
      ) 
       at_override
      ( Self .IsStaticConstructor )
       at_final
      ( Self .Parent .IsUtilityPack )
       at_final
      ( Self .Parent .IsStaticObject )
       at_final
      ( Self .ParentIsInterface )
       at_final
      ( Self .IsFunction )
       at_final
      ( Self .IsOperationOverride )
       at_override
      DEFAULT
       ( Self .Abstraction )
     ; // RULES
    ) // opkind_Normal
   opkind_Implemented
    (
     RULES
      ( Self .IsVCMOperationPrim )
       at_final
      ( Self .Parent .IsContract )
       at_abstract
      ( Self .ParentIsInterface )
       RULES
        ( Self .IsIteratorF ) 
         at_final
        ( Self .IsIterator )
         RULES
          ( 'F' Self .Name EndsStr )
           at_final
          DEFAULT
           at_virtual
         ; // RULES 
        DEFAULT
         at_final
       ; // RULES 
      ( Self .IsInline )
       at_final
      DEFAULT
       at_override 
     ; // RULES
    ) // opkind_Implemented
   opkind_Overridden
    RULES
     ( Self .IsInline )
      at_final
     DEFAULT 
      at_override
    ; // RULES  
   DEFAULT
    at_final 
  END // CASE
 ) 
 &gt;&gt;&gt; Result
; // MethodAbstraction

STRING elem_func MethodNamePrefix
 RULES
  ( Self .IsSetter )
   begin
    RULES
     ( Self .InTie )
      'Set'
     ( Self .UPisTrue "pm" )
      'pm_Set'
     DEFAULT
      'Set_'
    ; // RULES  
   end // ( Self .IsSetter )
  ( Self .IsProperty )
   begin
    RULES
     ( Self .InTie )
      'Get'
     ( Self .UPisTrue "pm" )
      'pm_Get'
     DEFAULT
      'Get_'
    ; // RULES  
   end // ( Self .IsProperty )
  DEFAULT
   cEmptyStr
 ; // RULES 
 &gt;&gt;&gt; Result
; // MethodNamePrefix

STRING CompileTime-VAR g_MethodParentPrefix ''
BOOLEAN CompileTime-VAR g_EnableMethodDirectives true
BOOLEAN CompileTime-VAR g_EnableMethodDocumentation true

ANY elem_func ExtValue
 Cached:
 (
  Self .GetUP 'extprop:pas:Value' &gt;&gt;&gt; Result
  if ( Result .IsValueValid ) then
  begin
   RULES
    ( Result IsString )
     begin
      RULES
       ( '.[]' Result EndsStr )
        begin
         '[]' &gt;&gt;&gt; Result
        end // ( '.[]' Result EndsStr )
       ( '.nil' Result EndsStr )
        begin
         'nil' &gt;&gt;&gt; Result
        end // ( '.[]' Result EndsStr )
       ( 
        ( ']' Result EndsStr )
        AND ( '[' Result StartsStr ! )
       ) 
        begin
         VAR l_Head
         Result cDot string:Split &gt;&gt;&gt; Result &gt;&gt;&gt; l_Head
         if ( Result .IsNil ) then
         begin
          l_Head &gt;&gt;&gt; Result
         end // ( Result .IsNil )
        end // ( '.[]' Result EndsStr )
       ( 'vcmUserControls.vcm_utAny' Result == )
        ( 'vcm_utAny' &gt;&gt;&gt; Result )
       ( 'evdInterfaces.evDefaultStoreFlags' Result == )
        ( 'evDefaultStoreFlags' &gt;&gt;&gt; Result )
       DEFAULT
        begin
         VAR l_Type
         Self .ValueType &gt;&gt;&gt; l_Type
         if ( l_Type .IsNotNil ) then
         begin
          VAR l_Target
          Self .Target &gt;&gt;&gt; l_Target
          if (
              ( l_Target .IsNil )
              OR ( l_Target l_Type != ) 
             ) then
          begin
           VAR l_Unit
           l_Type .EffectiveUnitName &gt;&gt;&gt; l_Unit
           if ( Self .EffectiveUnitName l_Unit != ) then
           begin 
            l_Unit cDot Cat &gt;&gt;&gt; l_Unit
            if ( l_Unit Result StartsStr ! ) then
            begin
             l_Unit Result Cat &gt;&gt;&gt; Result
            end // ( l_Unit Result StartsStr ! ) 
           end // ( Self .EffectiveUnitName l_Unit != )
          end // ( Self .Target l_Type != )
         end // ( l_Type .IsNotNil )
        end // DEFAULT
      ; // RULES
     end // ( Result IsString )
   ; // RULES
  end // ( Result .IsValueValid )
  Result
 )
 &gt;&gt;&gt; Result
; // ExtValue

elem_proc MethodInterfacePrim
 IN aPrefix
 IN aOverload
 IN aOfObject
 IN aBody
 
 : OutOverload
  aOverload DO 
 ; // OutOverload
 
 : OutCallingConventions
  Self .MethodCallingConventions
 ; // OutCallingConventions

 : OutReintroduce
  RULES
   ( Self .IsStaticConstructor )
    ()
   ( Self .ParentIsInterface )
    ()
   ( Self .IsConstructor )
    ( ' reintroduce;' )
   ( Self .IsFactory )
    ( ' reintroduce;' )
  ; // RULES
 ; // OutReintroduce
 
 RULES
  ( Self .IsNil )
   ()
  DEFAULT 
  begin
   Self .IfDef:
   (
    [ 
     aPrefix DO
     
     ModelElement VAR l_Type
     Self .MethodType &gt;&gt;&gt; l_Type
     
     VAR l_IsFunc
   
     RULES
      ( Self .IsSetter ) 
       ( 
         false &gt;&gt;&gt; l_IsFunc
         'procedure' 
       )
      DEFAULT
       ( 
         ( l_Type .IsNotNil ) AND ( l_Type .TypeName .IsNotNil ) &gt;&gt;&gt; l_IsFunc
         Self .MethodKeyword 
       )
     ; // RULES  
     
     if ( Self .IsFunction ! ) then
     begin
      cSpace
      
      g_MethodParentPrefix
      
      RULES
       ( Self .IsProperty )
        (
         Self .MethodNamePrefix 
         Self .MethodName 
        )
       DEFAULT
        ( Self .MethodName  )
      ; // RULES
      
     end // ( Self .IsFunction ! )
     
     VAR l_WasParam
     false &gt;&gt;&gt; l_WasParam
     
     VAR l_MethodAbstraction
     Self .MethodAbstraction &gt;&gt;&gt; l_MethodAbstraction
     
     RULES
      ( Self .IsSetter )
       ( 
        Self .PropertyKeys 
        .join&gt; ToArray: ( l_Type .ValueParam )
       )
      ( Self .IsProperty )
       ( Self .PropertyKeys )
      DEFAULT
      ( Self .MethodParameters )
     ; // RULES  
     .for&gt; (
       IN aParam
      if ( l_WasParam ! ) then
       '('
      
      VAR l_WasIf 
      false &gt;&gt;&gt; l_WasIf
      
      elem: IfDefBraceLn:
        ^ IN aLambda
       Self nil .IfDefPrim: ( 
        \n 
        l_WasIf ! ? SWAP
        true &gt;&gt;&gt; l_WasIf
       )
       (
        aLambda DO
        l_WasIf ? \n
       ) // Self .IfDefPrim:
      ; // IfDefBraceLn:
      
      aParam .IfDefBraceLn:
      (
       if ( l_WasParam ) then
       begin
        ';' \n cSpace
       end 
       
       true &gt;&gt;&gt; l_WasParam
       
       aParam .ParamPrefix
       aParam .Name
       
       VAR l_Type 
       aParam .Target &gt;&gt;&gt; l_Type
       if ( l_Type .IsNotNil ) then
       begin
        ': ' l_Type .TypeName
       end // ( l_Type .IsNotNil )
       
       //if ( l_MethodAbstraction at_override != ) then
       begin
        VAR l_Value
        aParam .ExtValue &gt;&gt;&gt; l_Value
        //aParam .GetUP 'Value' &gt;&gt;&gt; l_Value
        if ( l_Value .IsValueValid ) then
        begin
         ' = ' l_Value
        end // ( l_Value .IsValueValid )
       end // ( l_MethodAbstraction at_override != )
       
       VAR l_Doc
       aParam .FineDocumentation &gt;&gt;&gt; l_Doc
       if ( l_Doc .IsNotNil ) then
       begin
        \n cSpace l_Doc
       end // ( l_Doc .IsNotNil )
      ) // aParam .IfDefBraceLn:
     ) // Self .MethodParameters .for&gt;
   
     if ( l_WasParam ) then
      ')'
     
     if l_IsFunc then
     begin
      ': ' l_Type .TypeName
     end // l_IsFunc
   
     aOfObject DO
     ';'
     
     if g_EnableMethodDirectives then
     begin
      l_MethodAbstraction CASE
       at_final (
        OutReintroduce
        OutOverload
        OutCallingConventions
       ) 
       at_virtual ( 
        OutReintroduce
        OutOverload
        ' virtual;'
        OutCallingConventions 
       )
       at_abstract ( 
        OutReintroduce
        OutOverload
        ' virtual; abstract;' 
        OutCallingConventions
       )
       at_override 
        ' override;'
       at_message ( 
        ' message ' Self .GetUP "Message ID" ';'
       ) 
      END // CASE
     end // g_EnableMethodDirectives
     
     VAR l_WasComma
     false &gt;&gt;&gt; l_WasComma
     VAR l_WasOut
     false &gt;&gt;&gt; l_WasOut
     
     RULES
      ( Self .IsSetter )
       ( Self .CanRaiseInSet )
      DEFAULT
       ( Self .CanRaise )
     ; // RULES
     .for&gt; (
       IN anItem
      if ( l_WasOut ! ) then
      begin
       true &gt;&gt;&gt; l_WasOut
       cSpace cOpenComment ' can raise '
      end // ( l_WasOut ! )
      anItem .TypeName .WithComma: l_WasComma .KeepInStack
     ) // Self .CanRaise .for&gt;
     if l_WasOut then
     begin
      cSpace
      cCloseComment
     end // l_WasOut
    ] 
    .Out? ? (
     if g_EnableMethodDocumentation then
      if ( Self .IsProperty ! ) then
      begin
       Self .OutDocumentation
      end // ( Self .IsProperty ! )
     Self aBody DO
    ) // .Out? ?
   ) // Self .IfDef: 
  end // DEFAULT
 ; // RULES 
; // MethodInterfacePrim

elem: AsSetterDo:
  ^ IN aLambda
 RULES
  ( Self .IsWriteonlyProperty )
   ( Self aLambda DO )
  DEFAULT 
   (
    Self .DecorateMethodAndDo: ( 
      IN aMethod
     aMethod -&gt; OpModify := opModifySetter
     aMethod aLambda DO 
    ) // Self .DecorateMethodAndDo:
   ) // DEFAULT
 ; // RULES
; // AsSetterDo:

elem: AsTestDo:
  ^ IN aLambda
 Self .DecorateMethodAndDo: ( 
   IN aMethod
  aMethod -&gt; OpModify := opModifyTest
  aMethod aLambda DO 
 ) // Self .DecorateMethodAndDo:
; // AsTestDo:

elem: AsExecuteDo:
  ^ IN aLambda
 Self .DecorateMethodAndDo: ( 
   IN aMethod
  aMethod -&gt; OpModify := opModifyExecute
  aMethod aLambda DO 
 ) // Self .DecorateMethodAndDo:
; // AsExecuteDo:

elem: AsGetStateDo:
  ^ IN aLambda
 Self .DecorateMethodAndDo: ( 
   IN aMethod
  aMethod -&gt; OpModify := opModifyGetState
  aMethod aLambda DO 
 ) // Self .DecorateMethodAndDo:
; // AsGetStateDo:

elem: AsIteratorFDo:
  ^ IN aLambda
 Self .DecorateMethodAndDo: ( 
   IN aMethod
  aMethod -&gt; OpModify := opModifyIteratorF
  aMethod -&gt;^ cVarUserCodeName ^:= [
  'var' \n
  ' Hack : Pointer absolute anAction;'
  ]
  aMethod -&gt;^ cImplementationUserCodeName ^:= [
  ' try' \n
  '  '
  if ( Self .UPisTrue "needs result" ) then
   'Result := '
  RULES
   ( Self .IsMethodAndImplementsIterator ) 
    ( Self .MainImplements .MethodName )
   DEFAULT
    ( Self .Name )
  ; // RULES  
  Self .ParametersList
  ';'
  \n
  ' finally' \n
  '  l3FreeLocalStub(Hack);' \n
  ' end;//try..finally'
  ]
  aMethod aLambda DO 
 ) // Self .DecorateMethodAndDo:
; // AsIteratorFDo:

elem_proc MethodInterfaceEx
 IN aPrefix
 IN aOverload
 IN aOfObject
 IN aBody
 
 : NormalCall 
  Self aPrefix aOverload aOfObject aBody .MethodInterfacePrim
 ; // NormalCall
 
 : CallAsGetter
  if ( Self .ReadsField ! ) then
   if ( Self .UPisTrue "inherits getter from some ancestor" ! ) then
    NormalCall
 ; // CallAsGetter
 
 : CallAsSetter
  if ( Self .WritesField ! ) then
   if ( Self .UPisTrue "inherits setter from some ancestor" ! ) then
    ( Self .AsSetterDo: ( aPrefix aOverload aOfObject aBody .MethodInterfacePrim ) )
 ; // CallAsSetter
 
 RULES
  ( Self .IsVCMOperationPrim )
   (
    //if ( Self .IsInternalOperation ! ) then
    begin
     if ( 
         ( Self .UPisTrue "is query" ! )
         AND ( Self .UPisTrue "no test" ! )
        ) then
     begin
      Self .AsTestDo: ( aPrefix aOverload aOfObject aBody .MethodInterfacePrim )
     end // ( Self .UPisTrue "is query" ! ) ..
    end // ( Self .IsInternalOperation ! )
    if (
        ( Self .UPisTrue "is FormActivate" ! ) 
        OR ( Self .IsInternalOperation )
       ) then
    begin
     Self .AsExecuteDo: ( aPrefix aOverload aOfObject aBody .MethodInterfacePrim )
    end // ( Self .UPisTrue "is FormActivate" ! )
    if ( Self .IsInternalOperation ! ) then
    begin
     if ( Self .UPisTrue "has states" ) then
     begin
      Self .AsGetStateDo: ( aPrefix aOverload aOfObject aBody .MethodInterfacePrim )
     end // ( Self .UPisTrue "has states" )
    end // ( Self .IsInternalOperation ! )
    if ( Self .IsInternalOperation ) then
     NormalCall
   ) // ( Self .IsVCMOperationPrim )
  ( Self .IsReadonlyProperty )
   CallAsGetter
  ( Self .IsWriteonlyProperty ) 
   CallAsSetter
  ( Self .IsProperty ) 
   ( 
    CallAsGetter
    CallAsSetter 
   ) // ( Self .IsProperty )
  ( Self .IsIterator )
   (
    NormalCall
    if ( 'F' Self .Name EndsStr ! )
     if ( Self .IsOverride ! ) then
     begin
      ( Self .AsIteratorFDo: ( aPrefix aOverload aOfObject aBody .MethodInterfacePrim ) )
     end // ( Self .IsOverride ! )
   ) // ( Self .IsIterator )
  ( Self .IsMethodAndImplementsIterator )
   (
    NormalCall
    if ( 'F' Self .Name EndsStr ! )
     //if ( Self .IsOverride ! ) then
     begin
      ( Self .AsIteratorFDo: ( aPrefix aOverload aOfObject aBody .MethodInterfacePrim ) )
     end // ( Self .IsOverride ! )
   ) // ( Self .IsIterator )
  DEFAULT
   NormalCall 
 ; // RULES
; // MethodInterfaceEx
 
elem_proc MethodInterfaceEx:
 ^ IN aPrefix
 ^ IN aOverload
 ^ IN aOfObject
 ^ IN aLambda
 Self aPrefix aOverload aOfObject aLambda .MethodInterfaceEx
; // MethodInterfaceEx:

BOOLEAN elem_func CanBeClassAncestor
 RULES
  ( Self .IsClassOrMixIn )
   true
  ( Self .IsException )
   true
  ( Self .IsEvdSchemaElement ) 
   true
  ( Self .IsTypedef )
   RULES
    ( Self .IsPointer )
     false
    DEFAULT
     ( Self .MainAncestor call.me )
   ; // RULES  
  DEFAULT
   false
 ; // RULES
 &gt;&gt;&gt; Result
; // CanBeClassAncestor

ModelElement elem_func MainClassAncestor
 Cached:
 (
  Self .InheritsEx
  .filter&gt; .CanBeClassAncestor 
  .FirstElement
 )
 &gt;&gt;&gt; Result
; // MainClassAncestor

elem_iterator MixInPropertiesTotal
 Cached:
 (
  Self .Properties
  .joinWithLambded&gt; ( Self .ImplementsEx .filter&gt; .IsPureMixIn ) call.me
  .joinWithLambded&gt; ( Self .InheritsEx .filter&gt; .IsPureMixIn ) call.me
 ) 
 &gt;&gt;&gt; Result
; // PropertiesTotal

elem_iterator InterfacePropertiesTotal
 Cached:
 (
  Self .Properties
  .joinWithLambded&gt; ( Self .ImplementsEx .filter&gt; .IsPureMixIn ) .MixInPropertiesTotal
 ) 
 &gt;&gt;&gt; Result
; // InterfacePropertiesTotal

elem_iterator InterfaceProperties
 Cached:
 (
  RULES
   ( Self .IsPureMixIn )
    ( Self .Properties )
   DEFAULT
    ( Self .InterfacePropertiesTotal )
  ; // RULES 
 ) 
 &gt;&gt;&gt; Result
; // InterfaceProperties

INTERFACE elem_func InstanceMethod
 Cached:
 (
  VAR l_TypeName
  Self .TypeName &gt;&gt;&gt; l_TypeName
  'Instance' Self MakeFunction: (
    IN aMade
   aMade -&gt; Stereotype := st_static::Operation
   aMade -&gt; %SUM := ( 'Метод получения экземпляра синглетона ' l_TypeName Cat )
   aMade -&gt; Visibility := PublicAccess
   aMade -&gt;^ cVarUserCodeName ^:= cEmptyUserCode
   aMade -&gt;^ cImplementationUserCodeName ^:= [ 
   ' if (' 'g_' l_TypeName ' = nil) then' \n
   ' begin' \n
   '  l3System.AddExitProc(' l_TypeName 'Free' ');' \n
   '  g_' l_TypeName ' := Create;' \n
   ' end;' \n
   ' Result := g_' l_TypeName ';'
   ]
  )
 )
 &gt;&gt;&gt; Result
; // InstanceMethod

INTERFACE elem_func ExistsMethod
 Cached:
 (
  VAR l_TypeName
  Self .TypeName &gt;&gt;&gt; l_TypeName
  'Exists' GarantModel::Boolean MakeFunction: (
    IN aMade
   aMade -&gt; Stereotype := st_static::Operation
   aMade -&gt; %SUM := 'Проверяет создан экземпляр синглетона или нет'
   aMade -&gt; Visibility := PublicAccess
   aMade -&gt;^ cVarUserCodeName ^:= cEmptyUserCode
   aMade -&gt;^ cImplementationUserCodeName ^:= [ 
   ' Result := g_' l_TypeName ' &lt;&gt; nil;'
   ]
  ) 
 )
 &gt;&gt;&gt; Result
; // ExistsMethod

INTERFACE elem_func FakeMethod
 Cached:
 (
  'Fake' MakeProcedure: ( 
    IN aMade
   aMade -&gt; %SUM := 'это нужно чтобы правильно генерировались вызовы методов доступа к свойствам'
   aMade -&gt; Visibility := PrivateAccess
   aMade -&gt; Abstraction := at_virtual
   aMade -&gt;^ cVarUserCodeName ^:= cEmptyUserCode
   aMade -&gt;^ cImplementationUserCodeName ^:= ' Assert(false);'
  )
 )
 &gt;&gt;&gt; Result
; // FakeMethod

INTERFACE elem_func InitConstructor
 Cached:
 (
  'Init' MakeProcedure: (
    IN aMade
   aMade -&gt; Stereotype := st_ctor::Operation
   aMade -&gt; Visibility := PublicAccess
   aMade -&gt; Abstraction := at_final
   aMade -&gt; UID := ( Self .LUID 'Init' Cat )
   if ( Self .IsAutoHelper ) then
   begin
    aMade -&gt; Parameters := [ 
     Self .ImplementsEx .for&gt; (
       IN aR
      'a' aR .TypeName Cat aR MakeParam 
     )
    ]
    aMade -&gt;^ cImplementationUserCodeName ^:= [
     Self .ImplementsEx .for&gt; (
       IN aR
      ' ' 'f_' aR .TypeName ' := ' 'a' aR .TypeName ';'
     )
    ]
   end // ( Self .IsAutoHelper )
   aMade -&gt;^ cVarUserCodeName ^:= cEmptyUserCode
   //aMade -&gt;^ cImplementationUserCodeName ^:= ' Assert(false);'
  ) 
 )
 &gt;&gt;&gt; Result
; // InitConstructor

BOOLEAN elem_func NeedsFakeMethod
 Cached:
 (
  RULES
   ( Self .IsAutoHelper )
    true
   ( Self .Properties .filter&gt; ( .ReadsField ! ) .NotEmpty )
    true 
   DEFAULT
    false 
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // NeedsFakeMethod

BOOLEAN elem_func IsSettingsHolder
 Self .IsStereotype st_SettingsHolder
 &gt;&gt;&gt; Result
; // IsSettingsHolder

BOOLEAN elem_func IsInterfaceFactory
 Self .IsStereotype st_InterfaceFactory
 &gt;&gt;&gt; Result
; // IsInterfaceFactory

BOOLEAN elem_func UseNewGen
 Cached:
 (
  RULES
   ( Self .IsNil )
    false
   ( Self .IsUserType )
    true 
   ( Self .IsElementProxy )
    true
   ( Self .IsTestClass )
    true
   ( Self .IsTestCase )
    true
   ( Self .IsScriptKeyword )
    RULES
     ( Self .Parent .IsVCMControls )
      false
     ( Self .Parent .IsVCMModule )
      true
     DEFAULT 
      true
    ; // RULES  
   ( Self .IsScriptKeywordsPack )
    true
   ( Self .IsUtilityPack )
    true
   ( Self .IsScriptKeywords )
    true
   ( Self .IsStereotype st_Wrapper )
    true
   ( Self .IsStereotype st_EVD )
    false 
   ( Self .UPisTrue "UseNewGen" )
    true 
   ( Self .GetUP "finished" false ?== ) 
    true
   ( Self .ForceUseNewGen )
    true 
   ( Self .IsVCMCustomForm )
    ( Self .Parent call.me )
   ( Self .IsGuiControl )
    true
   ( Self .IsUseCaseControllerImp )
    ( Self .Parent call.me ) 
   ( Self .IsViewAreaControllerImp )
    ( Self .Parent call.me )
   ( Self .IsVCMControls )
    ( Self .Parent call.me )
   ( Self .IsMixIn )
    true
   ( Self .IsControllerInterfaces )
    true
   ( Self .IsInternalInterfaces )
    true
   ( Self .IsInterfaces )
    true
   ( Self .IsService )
    true 
   ( Self .IsServiceImplementation )
    true 
   ( Self .IsSettingsHolder ) 
    ( Self .Parent call.me )
   ( Self .IsInterfaceFactory ) 
    ( Self .Parent call.me )
   ( Self .IsVCMFormSetFactory ) 
    ( Self .Parent call.me )
   ( Self .IsVCMFormsPack ) 
    ( Self .Parent call.me )
   ( Self .IsVCMApplication ) 
    true
   ( Self .IsTestResults ) 
    true
   ( Self .IsSimpleClass ) 
    true
   ( Self .IsTestLibrary ) 
    true
   ( Self .IsLibrary ) 
    ( Self .Parent call.me )
   ( Self .IsVCMTestTarget ) 
    true
   ( Self .IsTestTarget ) 
    true
   ( Self .IsVCMGUI ) 
    true
   ( Self .IsExeTarget ) 
    true
   ( Self .IsDLL ) 
    true
   ( Self .IsTarget ) 
    ( Self .Parent call.me )
   DEFAULT
    ( Self .Parent call.me )
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // UseNewGen

elem_iterator AllOperationsForOverload
 Cached:
 (
  RULES
   ( Self .IsPureMixIn )
    ( Self .InterfaceOwnOperations )
   ( Self .IsInterface )
    ( Self .InterfaceOperationsTotal )
   ( Self .IsStaticObject )
    ( 
      Self .OperationsEx
      .filter&gt; ( .IsStaticConstructor ! )
      .join&gt; ( Self .ImplementedEx )
      
      if ( Self .NeedsFakeMethod ) then
      begin
       .join&gt; ToArray: ( Self .FakeMethod )
       .join&gt; ToArray: ( Self .InitConstructor )
      end // ( Self .NeedsFakeMethod )
    )
   ( Self .IsClassOrMixIn )
    ( 
      Self .OperationsEx
      
      VAR l_CastMethods
      [] &gt;&gt;&gt; l_CastMethods
      
      ( Self .ClassImplementsPrim ) .for&gt; (
        IN anItem
       .joinWithLambded&gt; 
       ( 
        anItem .InterfaceForClassImplements 
        .filter&gt; ( .NotInArray: l_CastMethods )
       ) 
       (
         IN anItem
        anItem .AddToArray: l_CastMethods 
        anItem .ToArray: .CastMethod
       )
      )
      .filter&gt; ( .IsStereotype st_responsibility::Operation ! ) 
      .filter&gt; ( .IsServiceIterator ! ) 
      .filter&gt; ( .IsIni ! )
      .filter&gt; ( .IsFini ! )
      
      (
       VAR l_VCMOperations
       [] &gt;&gt;&gt; l_VCMOperations
       
       .join&gt; ( 
         Self .ImplementedEx
        .filter&gt; ( .IsInline ! )
        .filter&gt; (
          IN anOp
          if ( anOp .IsVCMOperationPrim ) then
          begin
           VAR l_Name
           anOp .MethodName &gt;&gt;&gt; l_Name
           if ( l_Name .StringNotInArray: l_VCMOperations ) then
           begin
            l_Name .AddToArray: l_VCMOperations
            true
           end // ( l_Name .StringNotInArray: l_VCMOperations )
           else 
            false
          end // .IsVCMOperationPrim
          else
           true
        ) // .filter&gt;
        array:Copy
       ) // join&gt; ( Self .ImplementedEx )
      )
       
      if ( Self .IsSingleton ) then
      begin
       if ( Self .HasFactory ! ) then
       begin
        .join&gt; ToArray: ( Self .InstanceMethod )
       end // ( Self .HasFactory ! )
       //if ( Self .UseNewGen ) then
       begin
        if ( Self .OperationsEx 'Exists' .HasModelElementWithName ! ) then
        begin
         .join&gt; ToArray: ( Self .ExistsMethod )
        end // ( Self .OperationsEx 'Exists' .HasModelElementWithName ! )
       end // ( Self .UseNewGen )
      end // ( Self .IsSingleton )
    )
   DEFAULT
    ( Self .OperationsEx )
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // AllOperationsForOverload

elem_iterator AllOperationsForDefine
 Cached:
 (
  RULES
   ( Self .IsPureMixIn )
    ( Self .Properties )
   ( Self .IsInterface )
    ( Self .InterfacePropertiesTotal )
   ( 
    ( Self .IsStaticObject )
    OR ( Self .IsClassOrMixIn )
   ) 
    ( 
     Self .Properties
     .filter&gt; ( IN anItem
      ( anItem .ReadsField ! )
      OR ( anItem .WritesField ! )
     )
    )
   DEFAULT
    [empty]
  ; // RULES
  .join&gt; ( Self .AllOperationsForOverload )
  RULES
   ( Self .IsClassOrMixIn )
    ( 
     .join&gt; 
     ( 
      Self .OverriddenEx
      .filter&gt; ( .IsVCMOperationPrim ! )
     )
     .filter&gt; ( .IsInline ! ) 
    ) 
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // AllOperationsForDefine

elem_proc MethodInterfaceForEx:
  ^ IN anOperations
  ^ IN aLambda
 Self .MethodInterfaceEx: () ( 
  ARRAY VAR l_Ops
  anOperations DO &gt;&gt;&gt; l_Ops
  if ( l_Ops .IsNotNil ) then
  begin
   if ( Self .UPisTrue "force overload" ) then
   begin
    ' overload;'
   end // ( Self .UPisTrue "force overload" )
   else
   begin
    if ( l_Ops 
         .filter&gt; ( .IsProperty ! )
         .filter&gt; ( .IsVCMOperationPrim ! )
         .filter&gt; ( .MethodName Self .MethodName == ) 
         .CountIt &gt; 1 ) then
    begin
     ' overload;'
    end // l_Ops ..
   end // ( Self .UPisTrue "force overload" )
  end // ( l_Ops .IsNotNil )
 ) () (
  aLambda DO
 )
; // MethodInterfaceForEx:

elem_proc MethodInterfaceFor:
  ^ IN anOperations
 Self .MethodInterfaceForEx: ( anOperations DO ) DROP
; // MethodInterfaceFor:
  
STRING elem_func PropertyName
 Cached:
 (
  RULES
   ( Self .InTie )
    ( Self .Name .FromTie )
   DEFAULT
    ( Self .Name )
  ; // RULES   
 )   
 &gt;&gt;&gt; Result
; // PropertyName

elem_proc OutProperty
 Self .IfDef:
 (
  [
   'property '
   Self .PropertyName
   
   VAR l_WasParam
   false &gt;&gt;&gt; l_WasParam
 
   Self .PropertyKeys .for&gt; (
     IN aParam
    if l_WasParam then
     '; '
    else
    begin
     true &gt;&gt;&gt; l_WasParam
     '['
    end
    aParam .ParamPrefix
    aParam .Name
    ': '
    aParam .Target .TypeName
   )
 
   if l_WasParam then
    ']'
   ': '
   Self .MethodType .TypeName
 
   : OutRead
    \n cSpace 'read' cSpace 
    if ( Self .ReadsField ) then
     'f_'
    else
    begin
     Self .MethodNamePrefix 
    end // ( Self .ReadsField )
    Self .MethodName
   ; // OutRead
 
   : OutWrite
    \n cSpace 'write' cSpace
    if ( Self .WritesField ) then
     'f_'
    else
    begin
     Self .AsSetterDo: .MethodNamePrefix
    end // ( Self .WritesField )
    Self .MethodName
   ; // OutWrite
 
   RULES
    ( Self .IsReadonlyProperty )
     OutRead
    ( Self .IsWriteonlyProperty )
     ()
    ( Self .IsProperty )
     OutRead
   ; // RULES
   RULES
    ( Self .IsReadonlyProperty )
     ()
    ( Self .IsWriteonlyProperty )
     OutWrite
    ( Self .IsProperty )
     OutWrite
   ; // RULES
 
   if ( Self .UPisTrue "needs stored directive" ) then
   begin
    \n
    ' stored '
    Self .MethodName
    'Stored'
   end // ( Self .UPisTrue "needs stored directive" )
 
   VAR l_Value
   Self .ExtValue &gt;&gt;&gt; l_Value
   if ( l_Value .IsValueValid ) then
   begin
    \n
    ' default ' l_Value
   end // ( l_Value .IsValueValid )
   
   ';'
 
   if ( Self .UPisTrue "is default" ) then
   begin
    \n
    ' default;'
   end // ( Self .UPisTrue "is default" )
  ] .Out? ?
   ( Self .OutDocumentation )
 ) // Self .IfDef:
; // OutProperty

PROCEDURE .ByVisibility&gt;
  ARRAY IN anArray
  ^ IN aFilter
  ^ IN aOut
  
  BOOLEAN VAR l_WasOut
  STRING VAR l_Separator
  
  PROCEDURE DoOut
    IN anItem
   if ( l_WasOut ! ) then
   begin
    true &gt;&gt;&gt; l_WasOut
    l_Separator .Out
   end // ( l_WasOut )
   Indented: ( anItem aOut DO )
  ; // DoOut
  
 false &gt;&gt;&gt; l_WasOut 
 'private' &gt;&gt;&gt; l_Separator
 anArray .filter&gt; ( aFilter DO PrivateAccess == ) .for&gt; DoOut
 false &gt;&gt;&gt; l_WasOut 
 'protected' &gt;&gt;&gt; l_Separator
 anArray .filter&gt; ( aFilter DO ProtectedAccess == ) .for&gt; DoOut
 false &gt;&gt;&gt; l_WasOut 
 'public' &gt;&gt;&gt; l_Separator
 anArray .filter&gt; ( aFilter DO PublicAccess == ) .for&gt; DoOut
 'published' &gt;&gt;&gt; l_Separator
 anArray .filter&gt; ( aFilter DO PublishedAccess == ) .for&gt; DoOut
; // .ByVisibility&gt;

elem_proc OutField
 Self .IfDef:
 (
  [ 
   Self .FieldName
   ': '
   Self .MethodType .TypeName
   ';'
  ] .Out? ? (
   Self .OutDocumentation
  ) // .Out? ?
 ) // Self .IfDef:
; // OutField

INTEGER elem_func MethodVisibility
 Cached:
 (
  RULES
   ( Self .IsProperty )
    ProtectedAccess
   ( Self .IsStereotype st_Test )
    PublishedAccess 
   ( Self .OpKind opkind_Implemented == )
    RULES
     ( Self .Parent .IsPureMixIn )
      PublicAccess
     ( Self .ParentIsInterface )
      ProtectedAccess
     ( Self .IsStaticMethod ) 
      PublicAccess
     (
      ( Self .Visibility PrivateAccess == ) 
      AND ( Self .Abstraction at_abstract == )
     ) 
      ProtectedAccess
     DEFAULT
      ( Self .Visibility )
    ; // RULES
   ( Self .OpKind opkind_Overridden == )
    RULES
     ( 
      Self .IsStaticMethod 
      AND ( Self .Abstraction at_abstract == )
     )
      PublicAccess
     ( Self .Visibility PrivateAccess == ) 
      ProtectedAccess
     DEFAULT
      ( Self .Visibility )
    ; // RULES
   DEFAULT
    ( Self .Visibility )
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // MethodVisibility

elem_iterator ClassProperties
 Cached:
 (
  Self .Properties
  .join&gt; ( 
   ( Self .ImplementedEx )
   .filter&gt; .IsProperty
   .filter&gt; ( .Parent .IsContract )
  ) 
 )
 &gt;&gt;&gt; Result
; // ClassProperties

INTEGER elem_func FieldVisibility
 RULES
  ( Self .IsProperty )
   PrivateAccess
  DEFAULT
   ( Self .Visibility )
 ; // RULES
 &gt;&gt;&gt; Result
; // FieldVisibility

elem_proc OutClassInner
 Indented: (
  Self .Fields .ByVisibility&gt; .FieldVisibility .OutField
  
  TF g_Implementor (
   Self &gt;&gt;&gt; g_Implementor
   VAR l_AllOps
   Self .AllOperationsForOverload &gt;&gt;&gt; l_AllOps
   
   Self .AllOperationsForDefine 
   .ByVisibility&gt; .MethodVisibility
   .MethodInterfaceFor: l_AllOps
 
   Self .ClassProperties .ByVisibility&gt; .Visibility .OutProperty
  ) // TF g_Implementor
  
  if ( Self .IsStaticObject ) then
  begin
   VAR l_WasSection
   false &gt;&gt;&gt; l_WasSection
   ( Self .Attributes .filter&gt; ( .Target .IsUnion ) ) .for&gt; (
     IN aProp
    aProp .Target .Attributes 
    .filter&gt; ( .IsStereotype st_switch::Attribute ! ) 
    .filter&gt; ( .Name 'void' SWAP StartsStr )
    .for&gt; (
      IN aField
     aField .Target .Attributes .for&gt; (
       IN aField
       
      if ( l_WasSection ! ) then
      begin
       'public' .Out
       true &gt;&gt;&gt; l_WasSection
      end // ( l_WasSection ! )
      
      Indented:
      (
       [ 
        'property ' aField .Name ': ' aField .Target .TypeName
        \n 
        cSpace 'read' cSpace aProp .Name cDot aField .Name
        \n
        cSpace 'write' cSpace aProp .Name cDot aField .Name
        ';'
       ] .Out 
      ) // Indented:
     )
    )
   )
  end // ( Self .IsStaticObject )
 ) // Indented:
 
 if ( Self .UPisTrue "need UC" ) then
 begin
  Self .UserCode: 'publ' ()
 end // ( Self .UPisTrue "need UC" )
  
; // OutClassInner

elem_iterator InheritsNotMixIn
 Cached:
 (
  Self .InheritsEx .filterMixIns&gt;
 )
 &gt;&gt;&gt; Result
; // InheritsNotMixIn

BOOLEAN elem_func IsInheritsNotMixInCount
 Cached:
 (
  Self .InheritsNotMixIn .NotEmpty
 )
 &gt;&gt;&gt; Result
; // IsInheritsNotMixInCount

ModelElement elem_func TagClass
 %SUMMARY 
  'Класс, реализующий тег.' 
  'Возможно будет расширяться, когда будем делать генерацию EVD-схемы.'
  'И станет полноценным классом с реализуемыми и перекрытыми методами.'
 ;
 Cached:
 (
  Self .TypeName 'Class' Cat nil MakeClass
 ) 
 &gt;&gt;&gt; Result
; // TagClass
        
ModelElement elem_func MainAncestorThatNotMixIn
 %SUMMARY 
  'Возвращает имя родительский класс, который не является примесью.' 
  'Или умолчательного предка'.
 ;
/*
	[{}{\
	%S%f_pas_DefaultAncestor()\
	}\
	&lt;{}{%G#f_IsMixIn()!=true}\
	%f_pas_TypeName(%G)[{%GS=Tag}Class]\
	&gt;\
        ]
*/
 Cached:
 (
  RULES
   ( Self .IsInheritsNotMixInCount ! )
    ( Self .DefaultAncestor )
   ( Self .InheritsNotMixIn .filter&gt; .IsTag .IsEmpty ) 
    ( Self .InheritsNotMixIn .FirstElement )
   DEFAULT
    begin
     Self .InheritsNotMixIn 
     .filter&gt; .IsTag 
     .map&gt; .TagClass
     .FirstElement
    end // DEFAULT
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // MainAncestorThatNotMixIn

ModelElement elem_func MixInParentName
 %SUMMARY 'Псевдо класс для указания родительсого типа примеси.' ;
 Cached:
 (
  Self .TypeName 'Parent_' Cat nil MakeClass
 ) 
 &gt;&gt;&gt; Result
; // MixInParentName
        
STRING elem_func PasPathOnly
 Cached:
 (
  Self .GetUP 'intf.pas:PathOnly' &gt;&gt;&gt; Result
  if ( Result .IsNil ) then
  begin
   Self .Parent call.me &gt;&gt;&gt; Result
  end // ( Result .IsNil )
  else
  begin
   Result '\MDProcess\components\' '\common\components\' string:ReplaceFirst &gt;&gt;&gt; Result
  end // ( Result .IsNil )
  Result
 )
 &gt;&gt;&gt; Result
; // PasPathOnly

STRING elem_func PathOnly
 Cached:
 (
  Self .FinalFileName sysutils:ExtractFilePath &gt;&gt;&gt; Result
  if ( Result .IsNil ) then
  begin
   Self .PasPathOnly &gt;&gt;&gt; Result
   if ( Result .IsNotNil ) then
   begin
    Result '\' .CutPrefix &gt;&gt;&gt; Result
    [ cRoot 
    // - это потому, что в пути нету диска, а для ExtractFileName он нужен
    Result ] cPathSep strings:CatSep &gt;&gt;&gt; Result
    Result cPathSep Cat &gt;&gt;&gt; Result
   end // ( Result .IsNotNil )
  end // ( Result .IsNil )
  Result
 )
 &gt;&gt;&gt; Result
; // PathOnly

elem_proc OutMixInInclude
 [ cOpenComment '$Include' ' ' Self .PathOnly Self .UnitName '.pas' cCloseComment ] .Out
; // OutMixInInclude

BOOLEAN elem_func HasNonMixInAncestor
 Cached:
 (
  RULES
   ( Self .IsInheritsNotMixInCount )
    true
   ( Self .InheritsEx .filter&gt; call.me .NotEmpty )
    true
   DEFAULT
    false
  ; // RULES   
 ) 
 &gt;&gt;&gt; Result
; // HasNonMixInAncestor

ModelElement elem_func_with_side_effects CalcParentAndInclude
 RULES
  ( Self .IsMixIn )
   RULES
    ( Self .IsInheritsNotMixInCount )
     ( Self .MainClassAncestor )
    DEFAULT
     ( Self .MixInParentName )
   ; // RULES  
  DEFAULT
   ( Self .MainAncestorThatNotMixIn )
 ; // RULES 
 &gt;&gt;&gt; Result
 
 : RefG
   IN aG
  if ( Result .IsNotNil ) then
  begin 
   [ aG .MixInParentName .TypeName ' = ' Result .TypeName ';' ] .Out
  end // ( Result .IsNotNil )
 ; // RefG
 
 VAR l_WasProlog
 false &gt;&gt;&gt; l_WasProlog
 
 : DoG
   IN aG
  aG &gt;&gt;&gt; Result
  //aG .TypeName &gt;&gt;&gt; Result
  
  if ( l_WasProlog ! ) then
  begin
   true &gt;&gt;&gt; l_WasProlog
   if ( aG GarantModel::l3Items .InheritsFrom ) then
   begin
   
    : OutIsProto
     [ cOpenComment '$Define ' 'l3Items_IsProto' cCloseComment ] .Out
    ; // OutIsProto
    
    RULES
     ( Self GarantModel::Tl3ProtoObject .InheritsFrom )
      OutIsProto
     ( 
      ( Self GarantModel::Tl3DataContainerWithoutIUnknownPrim .InheritsFrom )
      AND NOT ( Self GarantModel::Tl3DataContainerWithoutIUnknown .InheritsFrom )
     ) 
      OutIsProto
    ; // RULES
   end // ( aG GarantModel::l3Items .InheritsFrom )
  end // ( l_WasProlog ! )
  
  aG .OutMixInInclude
 ; // DoG
 
 Self .InheritsEx .filter&gt; .IsMixIn .for&gt; (
   IN aG
  if ( Result .IsNotNil ) then
  begin 
   if ( aG .HasNonMixInAncestor ! ) then
   begin
    aG RefG 
   end // ( aG .HasNonMixInAncestor ! )
  end // ( Result .IsNotNil )
  aG DoG
 )
 Self .ImplementsEx .filter&gt; .IsMixIn .for&gt; (
   IN aG
  aG RefG 
  aG DoG
 )
; // CalcParentAndInclude
        
elem_proc DefineMixInValues
 Self .MixInValues .for&gt; (
   IN aValue
  g_MixInParamTypes -&gt;^ ( aValue .Name ) ^:= ( aValue .Target )
 ) // Self .MixInValues .for&gt;
; // DefineMixInValues

elem_proc UndefineMixInValues
 Self .MixInValues .for&gt; (
   IN aValue
  g_MixInParamTypes -&gt;^ ( aValue .Name ) ^:= nil
 ) // Self .MixInValues .for&gt;
; // UndefineMixInValues

elem_proc DefineImplementedMixInValues
 Self .ImplementsIsInterface .for&gt; .DefineMixInValues
; // DefineImplementedMixInValues

elem_proc UndefineImplementedMixInValues
 Self .ImplementsIsInterface .for&gt; .UndefineMixInValues
; // DefineImplementedMixInValues

ARRAY CompileTime-VAR g_MixInValues nil

elem_iterator AllInlinedOperations
 Cached:
 (
  Self .ImplementedAndOverridden
  .filter&gt; .IsInline
 )
 &gt;&gt;&gt; Result
; // AllInlinedOperations

elem_proc OutOtherMixinValues
 Self .InheritsEx .for&gt; (
   IN aG
  aG .MixInValues .for&gt; (
    IN aValue
   if ( aValue .Name .TextNotInArray: g_MixInValues ) then
   begin
    aValue .Name .AddToArray: g_MixInValues
    [ 
     '{$If not Declared(' cUnderline aValue .Name cUnderline ')' '}'
     'type' ' '
     cUnderline aValue .Name cUnderline ' = ' aValue .Target .TypeName ';' 
     '{$IfEnd}'
     \n
    ] .Out
   end // ( aValue .Name .TextNotInArray: g_MixInValues )
  ) // aG .MixInValues .for&gt;
  aG call.me
 ) // Self .InheritsEx .for&gt;
; // OutOtherMixinValues

elem_proc OutClass

 Self .DefineImplementedMixInValues

 if ( Self .UPisTrue "need UC" ) then
 begin
  Self .UserCode: 'ci' ()
 end // ( Self .UPisTrue "need UC" ) 

 Self .MixInValues .for&gt; (
   IN aValue
  aValue .Name .AddToArray: g_MixInValues 
  [ cUnderline aValue .Name cUnderline ' = ' aValue .Target .TypeName ';' ] .Out
 )
 
 VAR l_Parent
 Self .CalcParentAndInclude &gt;&gt;&gt; l_Parent
 
 if ( Self .UPisTrue "need UC" ) then
 begin
  Self .UserCode: 'cit' ()
 end // ( Self .UPisTrue "need UC" ) 
 
 [ 
  Self .TypeName 
  ' = ' 
  
  Self .Abstraction CASE
   at_abstract
    [ cOpenComment 'abstract' cCloseComment cSpace ]
   at_final
    [ cOpenComment 'final' cCloseComment cSpace ]
  END // CASE
  
  'class'

  ARRAY VAR l_Implements 
  [] &gt;&gt;&gt; l_Implements

  VAR l_WasComma
  false &gt;&gt;&gt; l_WasComma
  
  l_Parent .ToArray
  .join&gt; ( 
   Self .ClassImplements 
   .filter&gt; (
     IN anItem
    if ( anItem .NotInArray: l_Implements ) then
    begin
     anItem .AddToArray: l_Implements
     true
    end // ( anItem .NotInArray: l_Implements )
    else
    begin
     false
    end // ( anItem .NotInArray: l_Implements )
   ) // .filter&gt;
  ) // .join&gt;
  .With()&gt; (
    IN anItem
   RULES 
    ( anItem .IsMixIn )
     ( anItem .TypeName .WithComma: l_WasComma .KeepInStack )
    DEFAULT
    begin
     anItem .IfDefBraceLn:
     ( 
      anItem .TypeName .WithComma: l_WasComma .KeepInStack
     ) // anItem .IfDefBraceLn:
    end // DEFAULT
   ; // RULES
  ) // .With()&gt;
 ] .Out
 
 Self .OutDocumentation
 Self .OutClassInner
 
 [ 'end;//' Self .TypeName ] .Out
 
 Self .UndefineImplementedMixInValues
; // OutClass

elem_proc OutInterfaceBody
 Indented: (
  VAR l_Ops
  Self .AllOperationsForDefine &gt;&gt;&gt; l_Ops
  VAR l_AllOps
  Self .AllOperationsForOverload &gt;&gt;&gt; l_AllOps
  l_Ops .for&gt; .MethodInterfaceFor: l_AllOps
  Self .InterfaceProperties .for&gt; .OutProperty
 ) // Indented:
; // OutInterfaceBody

elem_proc OutInterface

 Self .DefineMixInValues
 
 Self .MixInValues .for&gt; (
   IN aValue
  [ '//' cUnderline aValue .Name cUnderline ' = ' aValue .Target .TypeName ';' ] .Out
 ) // Self .MixInValues .for&gt;
 
 [ Self .TypeName ' = interface' Self .MainAncestor .TypeName .With() ] .Out
 Self .OutDocumentation
 
 VAR l_GUID
 Self .GUID &gt;&gt;&gt; l_GUID
 if ( l_GUID .IsNotNil ) then
 begin
  Indented: ( [ '[' cQuote cOpenComment l_GUID cCloseComment cQuote ']' ] .Out )
 end // ( l_GUID .IsNotNil )
 
 Self .OutInterfaceBody
 [ 'end;//' Self .TypeName ] .Out
 
 Self .UndefineMixInValues
 
; // OutInterface

elem_proc OutRecord
 [ 
  Self .TypeName ' = ' 

  Self .UPisTrue "packed" ? 'packed '

  'record' 
 ] .Out
 Self .OutDocumentation
 
 Indented: ( 
  VAR l_Switch
  Self .Attributes 
  .filter&gt; ( .IsStereotype st_switch::Attribute ) 
  .FirstElement
  &gt;&gt;&gt; l_Switch
  
  if ( l_Switch .IsNotNil ) then
  begin
   [ 
    'Case ' 
    
    if ( l_Switch .Name 'void' != ) then
    begin
     l_Switch .Name ': '
    end // ( l_Switch .Name 'void' != )
    
    l_Switch .Target .TypeName
    ' of' 
   ] .Out 
   Indented: (
    Self .Fields .for&gt; (
      IN aField
     [ 
      VAR l_Value
      aField .GetUP 'Value' &gt;&gt;&gt; l_Value
      
      if ( l_Value .IsValueValid ) then
       l_Value
      else
       '!!!' 
      ': ' 
      '('
      if ( 'void' aField .Name StartsStr ) then 
      begin
       VAR l_WasField
       false &gt;&gt;&gt; l_WasField
       aField .Target .Fields .for&gt; (
         IN aField
         
        if l_WasField then
         '; ' 
         
        aField .Name 
        ': '
        aField .Target .TypeName
        true &gt;&gt;&gt; l_WasField
       ) // aField .Target .Fields .for&gt;
      end // ( 'void' aField .Name StartsStr )
      else
      begin
       aField .Name 
       ': '
       aField .Target .TypeName
      end // ( 'void' aField .Name StartsStr )
      ');'
     ] .Out? ? (
      aField .OutDocumentation
     ) // .Out? ?
    ) // Self .Fields .for&gt;
   ) // Indented:
  end // ( l_Switch .IsNotNil )
  else
  begin
   Self .Fields .for&gt; .OutField 
  end // ( l_Switch .IsNotNil )
 ) // Indented:
 
 if ( Self .UPisTrue "need UC" ) then
 begin
  Self .UserCode: 'publ' ()
 end // ( Self .UPisTrue "need UC" ) 
 
 [ 'end;//' Self .TypeName ] .Out
; // OutRecord

elem_proc OutDefine
 [ cOpenComment '$Define ' Self .Name cCloseComment ] .Out
; // OutDefine

elem_proc OutUndef
 [ cOpenComment '$Undef ' Self .Name cCloseComment ] .Out
; // OutUndef

elem_proc OutStaticObject
 if ( Self .IsConstructorsHolder ! ) then
 begin
  if ( Self .UPisTrue "need UC" ) then
  begin
   Self .UserCode: 'ci' ()
  end // ( Self .UPisTrue "need UC" ) 
 
  [ 
   Self .TypeName ' = ' 

   Self .UPisTrue "packed" ? 'packed '

   'object' Self .MainAncestor .TypeName .With() 
  ] .Out
  
  Self .OutDocumentation
  Self .OutClassInner
  
  [ 'end;//' Self .TypeName ] .Out
 end // ( Self .IsConstructorsHolder ! )
; // OutStaticObject

elem_proc OutPureMixIn
 '(*' .Out
 Self .OutInterface
 '*)' .Out
; // OutPureMixIn

ANY elem_func ExtValueOrName
 Self .ExtValue &gt;&gt;&gt; Result
 if ( Result .IsValueValid ! ) then
 begin
  Self .Name &gt;&gt;&gt; Result
 end // ( Result .IsValueValid ! 
; // ExtValueOrName
 
elem_proc OutRange
 [ Self .TypeName 
   ' = ' 
   VAR l_First
   Self .FirstAttribute &gt;&gt;&gt; l_First
   VAR l_Second
   Self .SecondAttribute &gt;&gt;&gt; l_Second
   if ( l_Second .IsNil ) then
   begin
    l_First &gt;&gt;&gt; l_Second
   end // ( l_Second .IsNil )
   
   VAR l_ElementPrefix
   if ( Self .GetUP "elements prefix" '&lt;none&gt;' == ) then
   begin
    '' &gt;&gt;&gt; l_ElementPrefix
   end
   else
   begin 
    Self .MainAncestor .GetUP 'extprop:pas:ElementPrefix' &gt;&gt;&gt; l_ElementPrefix
   end
   
   : .ValueWithPrefix
     IN aValue
    if ( aValue IsString ! ) then
     aValue
    else 
    if ( l_ElementPrefix aValue StartsStr ) then
     aValue
    else
    begin
     l_ElementPrefix aValue
    end 
   ; // .ValueWithPrefix
   
   l_First .ExtValueOrName .ValueWithPrefix
   ' .. '
   l_Second .ExtValueOrName .ValueWithPrefix
   ';' 
 ] .Out
 Self .OutDocumentation
; // OutRange

elem_proc OutTypedef
 ModelElement VAR l_MainAncestor
 Self .MainAncestor &gt;&gt;&gt; l_MainAncestor
 [ Self .TypeName 
   ' = ' 
   if ( Self .UPisTrue "newRTTI" ) then
    'type '
   if ( Self .IsPointer ) then
    '^'
   if ( Self .IsClassRef ) then
   begin
    true &gt;&gt;&gt; g_WasForwarded
    'class of '
   end // ( Self .IsClassRef )
   if ( Self .IsPointer ! ) then
   begin
    STRING VAR l_OtherUnit
    l_MainAncestor .EffectiveUnitName &gt;&gt;&gt; l_OtherUnit
    if ( l_OtherUnit .IsNotNil ) then
    begin
     if ( Self .TypeName l_MainAncestor .TypeName SameText ) then
     begin
      STRING VAR l_OurUnit
      Self .EffectiveUnitName &gt;&gt;&gt; l_OurUnit
      if ( l_OurUnit l_OtherUnit != ) then
      begin
       l_OtherUnit cDot
      end // l_OurUnit l_OtherUnit !=
     end // Self .TypeName l_MainAncestor .TypeName ==
    end // l_OtherUnit .IsNotNil
   end // Self .IsPointer !
   l_MainAncestor .TypeName 
   ';' 
 ] .Out
 Self .OutDocumentation
; // OutTypedef

elem_proc OutEnum
 [ Self .TypeName ' = (' ] .Out
 Self .OutDocumentation
  STRING VAR l_Prefix
  Self .GetUP 'extprop:pas:ElementPrefix' &gt;&gt;&gt; l_Prefix
  VAR l_NeedComma
  false &gt;&gt;&gt; l_NeedComma
  Indented: ( 
   Self .Attributes .for&gt; (
     IN aChild
    aChild .IfDef: 
    (
     [ 
      l_Prefix aChild .Name
     
      VAR l_Value
      aChild .ExtValue &gt;&gt;&gt; l_Value
      if ( l_Value .IsValueValid ) then
      begin
       ' = ' l_Value ToPrintable
      end // ( l_Value .IsValueValid )
     ] strings:Cat 
      .WithComma: l_NeedComma .Out
     aChild .OutDocumentation
    ) // aChild .IfDef:
   ) // Self .Attributes .for&gt;
  ) // Indented:
 [ ');//' Self .TypeName ] .Out
; // OutEnum

elem_proc OutSetOf
 [ Self .TypeName ' = set of ' Self .MainAncestor .TypeName ';' ] .Out
 Self .OutDocumentation
; // OutSetOf

elem_proc OutFunction
 Self .MethodInterfaceEx: (
  Self .TypeName 
  ' = ' 
 ) () (
  if ( Self .UPisTrue "of object" ) then
  begin
   ' of object'
  end // ( Self .UPisTrue "of object" )
 )
 ( IN aMethod )
; // OutFunction

elem_proc OutArray
 if ( Self .IsOpenArray ! ) then
 begin
  [ 
   Self .TypeName ' = array ' 
   if ( Self .MainAncestor .IsNotNil ) then
   begin
    '[' Self .MainAncestor .TypeName '] '
   end // ( Self .MainAncestor .IsNotNil )
   'of ' 
   Self .FirstAttribute .Target .TypeName ';'
  ] .Out
  Self .OutDocumentation
 end // ( Self .IsOpenArray ! )
; // OutArray

ARRAY CompileTime-VAR g_OutedTypes nil
ARRAY CompileTime-VAR g_ForwardedTypes nil

elem_proc OutTypeKeyword

 : DoOutTypeKeyword
   if ( g_WasType ! ) then
   begin
    'type' .Out
    true &gt;&gt;&gt; g_WasType
    Self &gt;&gt;&gt; g_WasTypeOpener
    false &gt;&gt;&gt; g_WasConst
   end // g_WasType !
 ; // DoOutTypeKeyword
 
 RULES
  ( Self .IsType )
   DoOutTypeKeyword
  ( Self .IsMixIn )
  begin
   if g_WasConst then
    DoOutTypeKeyword
  end // ( Self .IsMixIn ) 
 ; // RULES
; // OutTypeKeyword
  
elem_proc OutForward
 if ( Self .NotInArray: g_OutedTypes ) then
 begin
  if ( Self .NotInArray: g_ForwardedTypes ) then
  begin
   Self .AddToArray: g_ForwardedTypes
   RULES
    ( Self .IsPureMixIn ) 
     ()
    DEFAULT 
    begin
     Self .IfDef: (
      Self .OutTypeKeyword
      Indented: (
       RULES
        ( Self .IsClass )
         ( 
          true &gt;&gt;&gt; g_WasForwarded
          [ Self .TypeName ' = class;' ] .Out OutLn 
         )
        ( Self .IsInterface )
         ( 
          true &gt;&gt;&gt; g_WasForwarded
          [ Self .TypeName ' = interface;' ] .Out OutLn 
         )
       ; // RULES  
      ) // Indented:
     ) // Self .IfDef:
    end // DEFAULT
   ; // RULES  
  end // ( Self .NotInArray: g_ForwardedTypes )
 end // ( Self .NotInArray: g_OutedTypes )
; // OutForward

BOOLEAN elem_func SomeOwnChildrenInheritsOrImplementsMixIn
 RULES
  (
   Self .ChildrenWithoutOwnFile 
   .filter&gt; .InheritsOrImplementsMixIn
   .NotEmpty
  )
   true
  DEFAULT
   false
 ; // RULES
 &gt;&gt;&gt; Result
; // SomeOwnChildrenInheritsOrImplementsMixIn

elem_iterator ForwardedEx
 Self .Forwarded
 RULES
  ( Self .IsPureMixIn )
   ()
  ( Self .IsTypedef )
   ()
  ( Self .IsInterface )
  begin
   RULES
    ( Self .Parent .IsInterface )
     ( .join&gt; ToArray: ( Self .Parent ) )
    ( Self .Parent .IsClass )
     RULES
      ( Self .Parent .IsService )
       ()
      ( Self .Parent .InheritsOrImplementsMixIn )
       ()
      ( Self .Parent .SomeOwnChildrenInheritsOrImplementsMixIn )
       ()
      DEFAULT
       ( .join&gt; ToArray: ( Self .Parent ) )
     ; // RULES  
   ; // RULES  
  end // ( Self .IsInterface )
 ; // RULES
 //.joinWithLambded&gt; ( Self .AllOwnChildren ) call.me
 &gt;&gt;&gt; Result 
; // ForwardedEx

elem_proc OutForwarded
 Self .ForwardedEx .for&gt; .OutForward
; // OutForwarded

elem_proc OutType
 RULES
  ( Self .IsElementProxy )
   ()
  ( Self .IsUtilityPack )
   ()
  ( Self .IsInterfaces )
   ()
  ( Self .IsTarget )
   ()
  ( Self .IsOpenArray )
   ()
  ( ( Self .IsStaticObject ) AND ( Self .IsConstructorsHolder ) )
   ()
  ( Self .IsUserType )
   ()
  ( Self .IsTestClass )
   ()
  ( Self .IsVCMOperations )
   () 
  ( Self .IsConstantsButNotType )
   () 
  ( Self .IsTestUnit )
   () 
  ( Self .IsUnit )
   () 
  ( Self .IsImpl )
   () 
  ( Self .IsTestLibrary )
   () 
  DEFAULT
   (
    if ( Self .NotInArray: g_OutedTypes ) then
    begin
     Self .AddToArray: g_OutedTypes
     Self .OutForwarded
     Self .IfDef:
     (
      Self .OutTypeKeyword
      Indented: (
       RULES
        ( Self .IsSetOf )
         ( Self .OutSetOf )
        ( Self .IsArray )
         ( Self .OutArray )
        ( Self .IsEnum )
         ( Self .OutEnum )
        ( Self .IsRange )
         ( Self .OutRange )
        ( Self .IsTypedef )
         ( Self .OutTypedef )
        ( Self .IsException )
         ( Self .OutClass )
        ( Self .IsMixIn )
         ( Self .OutClass )
        //( Self .IsTestClass )
        // ( Self .OutClass )
        ( Self .IsClass )
         ( Self .OutClass )
        ( Self .IsPureMixIn ) 
         ( Self .OutPureMixIn )
        ( Self .IsInterface )
         ( Self .OutInterface )
        ( Self .IsStaticObject )
         ( Self .OutStaticObject )
        ( Self .IsUnion )
         ( Self .OutRecord )
        ( Self .IsRecord )
         ( Self .OutRecord )
        ( Self .IsUndef )
         ( Self .OutUndef )
        ( Self .IsDefine )
         ( Self .OutDefine )
        ( Self .IsFunction )
         ( Self .OutFunction )
        DEFAULT
         ( [ '// ' Self .TypeName ] .Out )
       ; // RULES 
      ) // Indented:
      OutLn
     ) // Self .IfDef:
    end // ( Self .NotInArray: g_OutedTypes )
   ) // DEFAULT
 ; // RULES
; // OutType

BOOLEAN elem_func NeedForwarded
 RULES
  ( Self .IsType )
   true
  ( Self .IsPureMixIn )
   true
  DEFAULT
   false
 ; // RULES
 &gt;&gt;&gt; Result  
; // NeedForwarded

elem_proc OutChildrenRecPrim
  IN aValid
  IN aOut
  IN aNeedIfDef
  
  elem_proc DoOut
   if ( aNeedIfDef
       AND ( Self .NeedForwarded )
       AND ( Self aValid DO )
      ) then
   begin
    Self .OutForwarded
    Self .IfDef:
    (
     if ( Self .InheritsOrImplementsMixIn ! ) then
     begin
      if ( Self .SomeOwnChildrenInheritsOrImplementsMixIn ! ) then
      begin
       Self .ConstantsAndChildrenWithoutOwnFile
       .filter&gt; ( Self .InheritsFrom )
       .for&gt; .OutForward
      end // ( Self .SomeOwnChildrenInheritsOrImplementsMixIn ! )
     end // ( Self .InheritsOrImplementsMixIn ! )
     
     Self .ConstantsAndChildrenWithoutOwnFile
     .filter&gt; ( Self .InheritsFrom ! )
     .for&gt; call.me
     
     if ( Self aValid DO ) then
     begin
      Self aOut DO
     end // ( Self aValid DO )
     
     Self .ConstantsAndChildrenWithoutOwnFile
     .filter&gt; ( Self .InheritsFrom )
     .for&gt; call.me
     
    ) // Self .IfDef:
   end // ( Self .IsType )
   else
   begin
    Self .ConstantsAndChildrenWithoutOwnFile
    .filter&gt; ( Self .InheritsFrom ! )
    .for&gt; call.me
    if ( Self aValid DO ) then
    begin
     Self aOut DO
    end // ( Self aValid DO )
    Self .ConstantsAndChildrenWithoutOwnFile
    .filter&gt; ( Self .InheritsFrom )
    .for&gt; call.me
   end // ( Self .IsType )
  ; // DoOut
  
 Self .DoOut 
; // OutChildrenRecPrim

elem_proc OutChildrenRec
  IN aValid
  IN aOut
 Self aValid aOut false .OutChildrenRecPrim
; // OutChildrenRec  
  
elem_proc OutTypeRec
  IN aValid
  IN aOut
 Self aValid aOut true .OutChildrenRecPrim
; // OutTypeRec

elem_proc OutChildrenRec:
  ^ IN aValid
  ^ IN aOut
 Self aValid aOut .OutChildrenRec
; // OutChildrenRec:

WordAlias .ForChildren&gt; .OutChildrenRec:
  
elem_proc OutTypes
  ^ IN aValid
  
 DropWasType
 
 : DoOutType
   IN aChild
  //aChild .IfDef: 
  ( 
   aChild .OutType
  ) // aChild .IfDef:
 ; // DoOutType
 
/*{ 
 Self @ ( 
   IN aChild 
  aChild aValid DO 
  AND ( aChild .IsEnum )
 ) @ DoOutType .OutTypeRec

 Self @ ( 
   IN aChild 
  aChild aValid DO 
  AND ( aChild .IsSetOf )
 ) @ DoOutType .OutTypeRec
}*/

 Self @ ( 
   IN aChild 
  aChild aValid DO 
  AND ( aChild .UPisTrue "is default ancestor" )
 ) @ DoOutType .OutTypeRec
 
 Self @ ( 
   IN aChild 
  aChild aValid DO 
  AND ( aChild .IsPointer )
 ) @ DoOutType .OutTypeRec

 Self @ ( 
   IN aChild 
  aChild aValid DO 
  AND ( aChild .IsClassRef )
 ) @ DoOutType .OutTypeRec
 
/*{ 
 Self @ ( 
   IN aChild 
  aChild aValid DO 
  AND ( aChild .IsPureMixIn )
 ) @ DoOutType .OutTypeRec
}*/ 
 
 Self @ ( 
   IN aChild 
  aChild aValid DO 
 ) @ DoOutType .OutTypeRec
; // OutTypes

elem_proc OutConstants
 RULES
  ( Self .IsConstantArray )
   (
    VAR l_MainAncestor
    [ 
     Self .Name 
     ': array '
     '['
     VAR l_MainImplements
     Self .MainImplements &gt;&gt;&gt; l_MainImplements
     if ( l_MainImplements .IsNil ) then
     begin
     '0 .. ' Self .Attributes .CountIt 1 -
     end // ( l_MainImplements .IsNil )
     else
     begin
      l_MainImplements .TypeName
     end // ( l_MainImplements .IsNil )
     ']'
     ' of ' 
     Self .MainAncestor &gt;&gt;&gt; l_MainAncestor
     l_MainAncestor .TypeName
     ' = ('
    ] .Out 
     
     VAR l_WasComma
     false &gt;&gt;&gt; l_WasComma
     
     VAR l_IsPointer
     l_MainAncestor .IsPointer &gt;&gt;&gt; l_IsPointer
     
     Self .Attributes
/*{     .map&gt; ( 
      .ExtValue
      if l_IsPointer then
      begin
       '@'
       SWAP
       Cat
      end // l_IsPointer
     ) }*/
     .for&gt; (
       IN anItem
      anItem .IfDef:
      ( 
       ( 
        anItem .ExtValue 
        if l_IsPointer then
        begin
         '@'
         SWAP
         Cat
        end // l_IsPointer
       ) 
       .WithComma: l_WasComma .Out
      ) // anItem .IfDef:
     ) 
     
    [ 
     ');' 
    ] .Out
   ) // ( Self .IsConstantArray )
   ( Self .IsSetConst )
    (
     [ 
      Self .Name ' = '
      RULES 
       ( Self .Attributes .NotEmpty )
        ( 
         STRING VAR l_Prefix
         Self .MainAncestor .GetUP 'extprop:pas:ElementPrefix' &gt;&gt;&gt; l_Prefix
         VAR l_WasComma
         false &gt;&gt;&gt; l_WasComma
         '['
         Self .Attributes 
         .map&gt; .ExtValue
         .filter&gt; .IsValueValid
         .map&gt; ( l_Prefix SWAP Cat )
         .for&gt; (
          .WithComma: l_WasComma .KeepInStack
         ) // .for&gt;
         ']'
        )
       ( Self .MainAncestor .IsSetConst )
        ( 
         if ( Self .EffectiveUnitName Self .MainAncestor .EffectiveUnitName != ) then
         begin
          Self .MainAncestor .EffectiveUnitName cDot
         end // ( Self .EffectiveUnitName Self .MainAncestor .EffectiveUnitName != )
         Self .MainAncestor .Name 
        )
       DEFAULT
        (
         VAR l_MainAncestor
         Self .MainAncestor &gt;&gt;&gt; l_MainAncestor
         if ( l_MainAncestor .IsSetOf ) then
         begin
          l_MainAncestor .MainAncestor &gt;&gt;&gt; l_MainAncestor
         end // ( l_MainAncestor .IsSetOf )
         '[' 'Low(' l_MainAncestor .TypeName ')' ' .. ' 'High(' l_MainAncestor .TypeName ')' ']'
        )
      ; // RULES   
      ';' 
     ] .Out
    ) // ( Self .IsSetConst )
  DEFAULT
   (
    STRING VAR l_Prefix
    Self .GetUP 'extprop:pas:ElementPrefix' &gt;&gt;&gt; l_Prefix
    Self .Attributes .for&gt; (
      IN anItem
     anItem .IfDef: 
     ( 
      [ 
       l_Prefix anItem .Name
    
       if ( anItem .UPisTrue "is define" ! ) then
       begin
        VAR l_Type 
        anItem .Target &gt;&gt;&gt; l_Type
        l_Type .IsNotNil ? ( ': ' l_Type .TypeName )
       end // ( anItem .UPisTrue "is define" ! )
    
       BOOLEAN VAR l_NeedSuffix
       false &gt;&gt;&gt; l_NeedSuffix
       VAR l_Value
       anItem .ExtValue &gt;&gt;&gt; l_Value
       if ( l_Value .IsValueValid ! ) then
       begin
        anItem .GetUP 'Value' &gt;&gt;&gt; l_Value
        true &gt;&gt;&gt; l_NeedSuffix
       end
    
       ' = ' l_Value
    
       if l_NeedSuffix then
       begin
        VAR l_Suffix
        anItem .GetUP "suffix expr" &gt;&gt;&gt; l_Suffix
        if ( l_Suffix .IsValueValid ) then
        begin
         cSpace l_Suffix 
        end // ( l_Suffix .IsValueValid )
       end // l_NeedSuffix
    
       ';' 
      ] .Out? ? (
       anItem .OutDocumentation
      ) // ] .Out? ?
     ) // anItem .IfDef: 
    ) // Self .Attributes .for&gt;
   ) // DEFAULT 
 ; // RULES  
; // OutConstants

PROCEDURE .OutConstantsList
  ARRAY IN aList
 BOOLEAN VAR l_WasConst
 false &gt;&gt;&gt; l_WasConst
 aList .for&gt; (
   IN anItem
  RULES
   ( anItem .IsLocalConst )
    ()
   DEFAULT
    (
     if ( l_WasConst ! ) then
     begin
      true &gt;&gt;&gt; l_WasConst
      true &gt;&gt;&gt; g_WasConst
      DropWasType
      'const' .Out
     end
     anItem .IfDef: 
     (
      anItem .OutDocumentation
      Indented: ( 
       anItem .OutConstants 
      ) // Indented:
     ) // anItem .IfDef:
    ) // DEFAULT
  ; // RULES 
 )
 if l_WasConst then
  OutLn
; // .OutConstantsList

INTEGER elem_func ConstantsListVisibility
 Cached:
 (
  RULES
   ( Self .IsNil )
    PrivateAccess
   ( Self .IsConstantArray )
    (
     INTEGER VAR l_Vis 
     Self .Visibility &gt;&gt;&gt; l_Vis
     RULES
      ( l_Vis PublicAccess == )
       (
        VAR l_MainImplements
        Self .MainImplements &gt;&gt;&gt; l_MainImplements
        RULES
         ( l_MainImplements .IsNotNil )
          (
           RULES
            ( Self .UnitProducer l_MainImplements .UnitProducer == )
             ProtectedAccess
            DEFAULT
             l_Vis
           ; // RULES
          ) 
         DEFAULT
          l_Vis
        ; // RULES
       ) // ( l_Vis PublicAccess == )
      DEFAULT
       l_Vis
     ; // RULES  
    ) // ( Self .IsConstantArray )
   ( Self .IsLocalConst )
    ( Self .Visibility ) 
   ( Self .IsSetConst )
    (
     INTEGER VAR l_Vis 
     Self .Visibility &gt;&gt;&gt; l_Vis
     RULES
      ( l_Vis PublicAccess == )
       ProtectedAccess
      DEFAULT
       l_Vis
     ; // RULES 
    ) // ( Self .IsSetConst ) 
   ( Self .IsConstants )
    (
     INTEGER VAR l_Vis 
     Self .Visibility &gt;&gt;&gt; l_Vis
     RULES
      ( l_Vis PublicAccess == )
       (
        BOOLEAN VAR l_Protected
        Self .Attributes
        .mapToTarget&gt;
        .filterNil&gt;
        .filter&gt; (
         .UnitProducer Self .UnitProducer .IsSameModelElement
        )
        .NotEmpty
        &gt;&gt;&gt; l_Protected
        
        if ( l_Protected ! ) then
        begin
         Self .Attributes
         .map&gt; .ValueType
         .filterNil&gt;
         .filter&gt; (
          .UnitProducer Self .UnitProducer .IsSameModelElement
         )
         .NotEmpty
         &gt;&gt;&gt; l_Protected
        end // ( l_Protected ! )
        
        RULES
         l_Protected
          ProtectedAccess
         DEFAULT
          l_Vis
        ; // RULES   
       ) // ( l_Vis PublicAccess == )
      DEFAULT 
       l_Vis
     ; // RULES  
    ) // ( Self .IsConstants )   
   DEFAULT
    ( Self .Visibility )
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // ConstantsListVisibility

elem_proc OutDefinitionsSection:
  ^ IN aValid
  
 : .Suitable aValid DO ; 
  
 Self .ForChildren&gt; .Suitable (
  .ConstantsEx .filter&gt; ( .ConstantsListVisibility PublicAccess == ) .OutConstantsList
 )

 Self .OutTypes .Suitable
 
 Self .ForChildren&gt; .Suitable (
  .ConstantsEx .filter&gt; ( .ConstantsListVisibility ProtectedAccess == ) .OutConstantsList
 )

; // OutDefinitionsSection:

elem_iterator GlobalOperationsForOverload
 RULES
  ( ( Self .IsStaticObject ) AND ( Self .IsConstructorsHolder ) )
   ( ( Self .MainAncestor .GlobalOperations ) .join&gt; ( Self .GlobalOperations ) )
  DEFAULT
   ( Self .GlobalOperations )
 ; // RULES
 &gt;&gt;&gt; Result
; // GlobalOperationsForOverload

elem_proc OutVar
 Self .IfDef:
 (
  [
   'var '
   
   if ( Self .IsGlobalVar ) then
    'g_'
   else 
   if ( Self .IsLocalVar ) then
    'l_'
    
   Self .Name
   ': '
   if ( Self .Target .IsMethod ) then
   begin
    Self .Target .MainAncestor .TypeName
    ' = ' Self .Target .MethodName
   end // ( Self .Target .IsMethod )
   else
   begin
    Self .Target .TypeName
    
    if ( Self .UPisTrue "IsResult" ) then
    begin
     ' absolute Result'
    end // ( Self .UPisTrue "IsResult" )
    
    VAR l_Value
    Self .ExtValue &gt;&gt;&gt; l_Value
    if ( l_Value .IsValueValid ) then
    begin
     ' = ' l_Value
    end // ( l_Value .IsValueValid )
   end // ( Self .Target .IsMethod )
   
   ';'
  ] .Out
  Self .OutDocumentation
 ) // Self .IfDef:
; // OutVar

elem_proc OutInterfaceSection
 Self .OutDefinitionsSection: .IsForInterface
 
 VAR l_WasOut
 false &gt;&gt;&gt; l_WasOut
 Self .ForChildren&gt; .IsForInterface (
   IN anItem
  VAR l_GlobalOperations
  anItem .GlobalOperations &gt;&gt;&gt; l_GlobalOperations
  VAR l_GlobalOperationsForOverload
  anItem .GlobalOperationsForOverload &gt;&gt;&gt; l_GlobalOperationsForOverload
  l_GlobalOperations 
  .filter&gt; ( .Visibility PrivateAccess != )
  .for&gt; .MethodInterfaceForEx: l_GlobalOperationsForOverload ( IN aMethod true &gt;&gt;&gt; l_WasOut )
 )
 
 l_WasOut ? OutLn
 
 false &gt;&gt;&gt; l_WasOut
 Self .ForChildren&gt; .IsForInterface (
  .GlobalVars 
  .filter&gt; ( .Visibility PrivateAccess != ) 
  .for&gt; ( .OutVar true &gt;&gt;&gt; l_WasOut )
 ) 
 
 l_WasOut ? OutLn
; // OutInterfaceSection

elem_iterator LocalMethods
 Self .OperationsEx
 .filter&gt; .IsLocalMethod
 &gt;&gt;&gt; Result
; // LocalMethods

elem_iterator LocalVars
 Self .Attributes
 .filter&gt; .IsLocalVar
 .filter&gt; ( .IsGlobalVar ! )
 &gt;&gt;&gt; Result
; // LocalVars

elem_proc MethodBody
 if ( Self .UPisTrue 'extprop:isAsm' ) then
 begin
  'asm' .Out
  ' jmp l3LocalStub' .Out
 end 
 else 
 begin
  if ( Self .IsIteratorF ! ) then
  begin
   TF g_MethodParentPrefix (
    '' &gt;&gt;&gt; g_MethodParentPrefix
    
    Self .LocalVars .for&gt; .OutVar
     
    Indented:
    (
     Self .LocalMethods .for&gt; (
       IN aMethod
      OutLn 
      aMethod .MethodInterfaceForEx: nil ( call.me )
     ) // Self .LocalMethods .for&gt;
    ) // Indented:
   ) // TF g_MethodParentPrefix
  end // ( Self .IsIteratorF ! )
   
  Self .UserCode: cVarUserCodeSuffix ()
  'begin' .Out
  
  VAR l_WasOut
  false &gt;&gt;&gt; l_WasOut
  
  if ( Self .IsIteratorF ! ) then
  begin
   Indented:
   (
    Self .Dependencies
    .filter&gt; ( .IsStereotype st_call::Dependency )
    .filter&gt; ( .Target .IsIterator )
    .for&gt; (
      IN aDep
     Self .UserCode: 'iter' () 
     
     VAR l_Target
     aDep .Target &gt;&gt;&gt; l_Target
     
     VAR l_NeedsParams
     aDep .UPisTrue "iterator needs params" &gt;&gt;&gt; l_NeedsParams
     
     if l_NeedsParams then
     begin
      if ( l_Target .MethodParameters .filter&gt; .IsInParam .IsEmpty ) then
      begin
       false &gt;&gt;&gt; l_NeedsParams
      end // ( l_Target .MethodParameters .filter&gt; .IsInParam .IsEmpty )
     end // l_NeedsParams
     
     VAR l_NeedsAfter
     aDep .UPisTrue "needs after iterator UC" &gt;&gt;&gt; l_NeedsAfter
     [
      if ( l_Target .IsServiceIterator ) then
      begin
       l_Target .Parent .TypeName '.Instance.'
      end // ( l_Target .IsServiceIterator )
      
      VAR l_Name 
      l_Target .MethodName &gt;&gt;&gt; l_Name
      l_Name
      
      if ( 'F' l_Name EndsStr ! ) then
       'F'
       
      '('
      l_Target .IteratorStub .MethodName
      '('
      '@'
      
      VAR l_IteratorFuncName
      aDep .GetUP "iterator func name" &gt;&gt;&gt; l_IteratorFuncName
      if ( l_IteratorFuncName .IsNil ) then
      begin
       'DoIt' &gt;&gt;&gt; l_IteratorFuncName
      end // ( l_IteratorFuncName .IsNil )
      
      l_IteratorFuncName
      ')' 
      
      if ( l_NeedsParams ! ) then
      begin
       ')'
       if ( l_NeedsAfter ! ) then
        ';' 
      end // ( l_NeedsParams ! )
     ] .Out
     
     if l_NeedsParams then
     begin
      Self .UserCode: 'iterparam' ()
      [ 
       ')' 
       if ( l_NeedsAfter ! ) then
        ';' 
      ] .Out
     end // l_NeedsParams
     
     if l_NeedsAfter then
     begin
      Self .UserCode: 'afteriter' ()
     end // l_NeedsAfter
     
     true &gt;&gt;&gt; l_WasOut
    ) // .for&gt;
   ) // Indented:
  end // ( Self .IsIteratorF ! ) 
  
  if ( l_WasOut ! ) then
  begin
   Self .UserCode: cImplementationUserCodeSuffix ( ' !!! Needs to be implemented !!!' )
  end // ( l_WasOut ! )
 end
 [ 'end;//' g_MethodParentPrefix Self .MethodNamePrefix Self .MethodName ] .Out
 OutLn
; // MethodBody

BOOLEAN elem_func NeedsInstanceR
 Cached:
 (
  RULES
   ( Self .UPisTrue "needs InstanceR" )
    true
   ( Self .InheritsEx .filter&gt; call.me .NotEmpty )
    true 
   ( Self .ImplementsEx .filter&gt; call.me .NotEmpty )
    true 
   DEFAULT
    false
  ; // RULES
 )
 &gt;&gt;&gt; Result
; // NeedsInstanceR

elem_proc OutClassImplementation
 Self .IfDef:
 (
  Self .DefineImplementedMixInValues
  
  if ( Self .ImplementsMixIn ) then
  begin
   if ( Self .AllInlinedOperations .NotEmpty ) then
   begin
    Self .OutOtherMixinValues
   end // ( Self .AllInlinedOperations .NotEmpty )
  end // ( Self .ImplementsMixIn )
  
  TF g_Implementor (
   Self &gt;&gt;&gt; g_Implementor
   BOOLEAN VAR l_WasFirst
   false &gt;&gt;&gt; l_WasFirst
   TF g_EnableAutoEOL (
    false &gt;&gt;&gt; g_EnableAutoEOL
    TF g_EnableMethodDocumentation (
     false &gt;&gt;&gt; g_EnableMethodDocumentation
     Self .AllInlinedOperations 
     .filter&gt; (
       IN aMethod
      if l_WasFirst then
       true
      else
      begin
       true &gt;&gt;&gt; l_WasFirst
       false
      end
     ) // .filter&gt;
     .for&gt; .MethodInterfaceForEx: nil (
       IN aMethod
      ' forward;' .Out
      OutLn
      OutLn
     ) // .for&gt; .MethodInterfaceForEx: nil
    ) // TF g_EnableMethodDocumentation
   ) // TF g_EnableAutoEOL 
   Self .AllInlinedOperations .for&gt; .MethodInterfaceForEx: nil .MethodBody
  ) // TF g_Implementor
  
  VAR l_WasInstanceR
  Self .IsMixIn &gt;&gt;&gt; l_WasInstanceR
  
  Self .InheritsEx
  .join&gt; ( Self .ImplementsEx )
  .filter&gt; .IsMixIn 
  .for&gt; ( 
    IN aG
    
   if ( l_WasInstanceR ! ) then
   begin
    if ( aG .NeedsInstanceR ) then
    begin
     true &gt;&gt;&gt; l_WasInstanceR
     [ 'type _Instance_R_ = ' Self .TypeName ';' ] .Out
     OutLn
    end // ( aG .NeedsInstanceR )
   end // ( l_WasInstanceR ! )
   
   aG .OutMixInInclude
   OutLn
  ) // .for&gt;
  
  TF g_Implementor (
   Self &gt;&gt;&gt; g_Implementor
   TF g_MethodParentPrefix (
    Self .TypeName &gt;&gt;&gt; g_MethodParentPrefix
    g_MethodParentPrefix cDot Cat &gt;&gt;&gt; g_MethodParentPrefix
    TF g_EnableMethodDirectives (
     false &gt;&gt;&gt; g_EnableMethodDirectives
     Self .AllOperationsForDefine 
     .filter&gt; ( .MethodAbstraction at_abstract != )
     .for&gt; .MethodInterfaceForEx: nil .MethodBody
    ) // TF g_EnableMethodDirectives
   ) // TF g_MethodParentPrefix
  ) // TF g_Implementor 
  
  if ( Self .UPisTrue "need UC" ) then
  begin
   Self .UserCode: 'impl' ()
   OutLn
  end // ( Self .UPisTrue "need UC" ) 
 
  Self .UndefineImplementedMixInValues
 ) // Self .IfDef:

; // OutClassImplementation

elem_proc OutTestClassImplementation

 elem_proc MethodBody
  Self .UserCode: cVarUserCodeSuffix ()
  'begin' .Out
  ' with Self do' .Out
  ' begin' .Out
   Self .UserCode: cImplementationUserCodeSuffix ( ' !!! Needs to be implemented !!!' )
  ' end;//with Self' .Out 
  [ 'end;//' g_MethodParentPrefix Self .MethodNamePrefix Self .MethodName ] .Out
  OutLn
 ; // MethodBody
 
 elem_iterator ParamsOrKeys
  if ( Self .IsProperty ) then
   ( Self .PropertyKeys )
  else 
   ( Self .MethodParameters )
  .filter&gt; ( 'Self' .HasName ! ) 
  &gt;&gt;&gt; Result 
 ; // ParamsOrKeys
 
 elem_iterator OperationsAndProperties
  Self .OperationsEx
  .join&gt; ( Self .Properties )
  &gt;&gt;&gt; Result
 ; // OperationsAndProperties
 
 TF g_MethodParentPrefix (
  Self .TypeName &gt;&gt;&gt; g_MethodParentPrefix
  g_MethodParentPrefix cUnderline Cat &gt;&gt;&gt; g_MethodParentPrefix
  
  Self .OperationsAndProperties .for&gt; .MethodInterfaceForEx: nil .MethodBody

  [ 5 6 ] .for&gt; (
    IN aNum
   
   STRING elem_func ToVariant
    RULES
     ( Self .IsSimpleClass )
      ( [ 'tc' aNum IntToStr 'PublicInfo.VarFromObject' ] strings:Cat )
     DEFAULT
      ''
    ; // RULES
    &gt;&gt;&gt; Result   
   ; // ToVariant
   
   STRING elem_func FromVariant
    RULES
     ( Self .Name 'String' == )
      '__coerce_String'
     ( Self .Name 'AnsiString' == )
      '__coerce_String'
     DEFAULT
      'OleVariant'
    ; // RULES
    &gt;&gt;&gt; Result   
   ; // ToVariant
   
   Self .OperationsAndProperties .for&gt; (
     IN aMethod
    if ( aMethod .IsWriteonlyProperty ! ) then
    begin 
     VAR l_MethodName
     [ 
      g_MethodParentPrefix 
      
      if ( aMethod .IsProperty ) then
       'Get_'
      
      aMethod .Name 
     ] strings:Cat &gt;&gt;&gt; l_MethodName
     
     [ 'procedure ' l_MethodName '_Pub' aNum '(Instance: TObject; Args: PVariantArgList; out Value: OleVariant; Cookie: Cardinal); stdcall;' ] .Out
     'begin' .Out
     [ ' Assert(Instance is ' Self .MainAncestor .TypeName ');' ] .Out
     ' try' .Out
     [ '  ' 
      if ( aMethod .MethodType .IsNotNil ) then
      begin
       'Value := ' aMethod .MethodType .ToVariant '('
      end // ( aMethod .MethodType .IsNotNil )
      l_MethodName 
      '(' 
      Self .EffectiveType .TypeName '(' 'Instance' ')' 
      
      VAR l_Index
      0 &gt;&gt;&gt; l_Index
      aMethod .ParamsOrKeys .for&gt; ( 
        IN aParam
       ', ' 
       aParam .Target .FromVariant
       '('
       'Args^['
       l_Index
       ']'
       ')'
       INC l_Index
      ) // aMethod .ParamsOrKeys .for&gt;
      ')' 
      if ( aMethod .MethodType .IsNotNil ) then
       ')'
      ';' 
     ] .Out
     ' except' .Out
     '  // - гасим исключения' .Out
     if ( aMethod .MethodType .IsNotNil ) then
     begin
      '  Value := Unassigned;' .Out
     end // ( aMethod .MethodType .IsNotNil )
     ' end;//try..except' .Out
     'end;' .Out
     OutLn
    end // ( aMethod .IsWriteonlyProperty ! ) 
    
    if ( aMethod .IsProperty ) then
    if ( aMethod .IsReadonlyProperty ! ) then
    begin 
     VAR l_MethodName
     [ 
      g_MethodParentPrefix 
      
       'Set_'
      
      aMethod .Name 
     ] strings:Cat &gt;&gt;&gt; l_MethodName
     
     [ 'procedure ' l_MethodName '_Pub' aNum '(Instance: TObject; Args: PVariantArgList; out Value: OleVariant; Cookie: Cardinal); stdcall;' ] .Out
     'begin' .Out
     [ ' Assert(Instance is ' Self .MainAncestor .TypeName ');' ] .Out
     ' try' .Out
     [ '  ' 
      l_MethodName 
      '(' 
      Self .EffectiveType .TypeName '(' 'Instance' ')' 
      
      ', ' 
      aMethod .Target .FromVariant
      '('
      'Args^['
      0
      ']'
      ')'
      
      ')' 
      ';' 
     ] .Out
     ' except' .Out
     '  // - гасим исключения' .Out
     ' end;//try..except' .Out
     'end;' .Out
     OutLn
    end // ( aMethod .IsReadonlyProperty ! )
    
   ) // Self .OperationsAndProperties .for&gt;
   
   [ 'procedure _RegisterPublicInformation' aNum ';' ] .Out
   'begin' .Out
    Self .OperationsAndProperties .for&gt; (
      IN aMethod
     if ( aMethod .IsWriteonlyProperty ! ) then
     begin 
      VAR l_MethodName
      [ 
       g_MethodParentPrefix 
       
       if ( aMethod .IsProperty ) then
        'Get_'
       
       aMethod .Name 
       '_Pub'
       aNum IntToStr
      ] strings:Cat &gt;&gt;&gt; l_MethodName
      [ 
       ' ' 'tc' aNum 'PublicInfo._RegisterMethod' 
       '(' 
       Self .MainAncestor .TypeName
       ', '
       'tc' aNum 'OpenAppClasses' cDot 
       
       if ( aMethod .IsProperty ) then
        'mtGet'
       else
        'mtInvoke'
       
       ', '
       cQuote aMethod .Name cQuote
       
       ', '
       if ( aMethod .MethodType .IsNil ) then
        'nil'
       else
       begin
        'TypeInfo(' aMethod .MethodType .TypeName ')'
       end 
       
       ', '
       '['
       (
        VAR l_WasComma
        false &gt;&gt;&gt; l_WasComma
        aMethod .ParamsOrKeys .map&gt; ( .Target .TypeName 'TypeInfo(' SWAP Cat ')' Cat ) .for&gt; (
         .WithComma: l_WasComma .KeepInStack
        )
       )
       ']'
       
       ', '
       '['
       (
        VAR l_WasComma
        false &gt;&gt;&gt; l_WasComma
        aMethod .ParamsOrKeys .map&gt; ( .Name cQuote SWAP Cat cQuote Cat ) .for&gt; (
         .WithComma: l_WasComma .KeepInStack
        )
       )
       ']'
       
       ', '
       l_MethodName
       
       ')' ';' 
      ] .Out 
     end // ( aMethod .IsWriteonlyProperty ! )
     
     if ( aMethod .IsProperty ) then
     if ( aMethod .IsReadonlyProperty ! ) then
     begin 
      VAR l_MethodName
      [ 
       g_MethodParentPrefix 
       
       'Set_'
       
       aMethod .Name 
       '_Pub'
       aNum IntToStr
      ] strings:Cat &gt;&gt;&gt; l_MethodName
      [ 
       ' ' 'tc' aNum 'PublicInfo._RegisterMethod' 
       '(' 
       Self .MainAncestor .TypeName
       ', '
       'tc' aNum 'OpenAppClasses' cDot 
       
       'mtPut'
       
       ', '
       cQuote aMethod .Name cQuote
       
       ', '
       'nil'
       
       ', '
       '['
       ']'
       
       ', '
       '['
       ']'
       
       ', '
       l_MethodName
       
       ')' ';' 
      ] .Out 
     end // ( aMethod .IsReadonlyProperty ! )
    ) // Self .OperationsAndProperties .for&gt;
   'end;' .Out
   OutLn
   
  ) // [ 5 6 ] .for&gt;
 ) // TF g_MethodParentPrefix
; // OutTestClassImplementation

elem_proc OutImplementation
 RULES
  ( Self .IsClassOrMixIn )
   ( Self .OutClassImplementation )
  ( Self .IsStaticObject )
   ( Self .OutClassImplementation )
  ( Self .IsException )
   ( Self .OutClassImplementation )
  ( Self .IsTestClass )
   ( Self .OutTestClassImplementation )
 ; // RULES
; // OutImplementation

elem_proc OutIniOrFini
 Self .IfDef:
 (
  Self .UserCode: cEmptyStr ()
  Self .OutDocumentation
 ) // Self .IfDef:
; // OutIniOrFini

INTERFACE elem_func RegisterTestCaseMethod
 (
  'RegisterTestCase' MakeIniProcedure: (
    IN aMade
   aMade -&gt;^ cUserCodePrefix ^:= [ 
   ' TestFramework.RegisterTest(' Self .TypeName '.Suite);'
   ]
  ) // MakeIniProcedure:
 )
 &gt;&gt;&gt; Result
; // RegisterTestCaseMethod

INTERFACE elem_func RegisterTestClassMethod
 (
  'RegisterTestClass' MakeIniProcedure: (
    IN aMade
   aMade -&gt;^ cUserCodePrefix ^:= [ 
   ' _RegisterPublicInformation5;' \n ' _RegisterPublicInformation6;'
   ]
  ) // MakeIniProcedure:
 )
 &gt;&gt;&gt; Result
; // RegisterTestClassMethod

INTERFACE elem_func RegisterTagTableMethod
 (
  'RegisterTagTable' MakeIniProcedure: (
    IN aMade
   aMade -&gt;^ cUserCodePrefix ^:= [ 
   cSpace Self .TypeName '.SetAsDefault;'
   ]
  ) // MakeIniProcedure:
 )
 &gt;&gt;&gt; Result
; // RegisterTagTableMethod

INTERFACE elem_func RegisterServiceImplementationMethod
 (
  'bind' MakeIniProcedure: (
    IN aMade
   aMade -&gt; %SUM := ( 'Регистрация ' Self .TypeName Cat )
   aMade .AddMethodWithParams: cUserCodePrefix Self .BindServiceImplementationUC
  ) // MakeIniProcedure:
 )
 &gt;&gt;&gt; Result
; // RegisterServiceImplementationMethod

INTERFACE elem_func MakeIniStr
  STRING IN aName
  ModelElement IN aSpeller
  STRING IN aPrefix
 (
  aName MakeIniProcedure: (
    IN aMade
   aMade -&gt; %SUM := ( [ 'Инициализация ' aPrefix Self .Name ] strings:Cat )
   aMade -&gt; "ifdef" := ( Self .IfDefStr )
   aMade -&gt; "ifndef" := ( Self .IfNDefStr )
   aMade .AddMethodWithParams: cUserCodePrefix ( Self aSpeller ) .InitStrUCPrim
  ) // MakeIniProcedure:
 )
 &gt;&gt;&gt; Result
; // MakeIniStr

elem_iterator IniOperationsPrim
 Self .OperationsEx
 .filter&gt; .IsIni
 &gt;&gt;&gt; Result
; // IniOperationsPrim

ModelElement elem_func ElementOrParentThatCanHaveIniOperations
 RULES
  ( Self .IsClassOrMixIn )
   Self
  ( Self .IsUtilityPack )
   Self
  ( Self .Parent .IsNil )
   nil
  DEFAULT 
   ( Self .Parent call.me )
 ; // RULES
 &gt;&gt;&gt; Result
; // ElementOrParentThatCanHaveIniOperations

INTERFACE elem_func RegTypeMethod
 Cached:
 (
  VAR l_TypeName
  Self .TypeName &gt;&gt;&gt; l_TypeName
  VAR l_Name 
  'Reg_Type_' l_TypeName Cat &gt;&gt;&gt; l_Name
  l_Name MakeIniProcedure: (
    IN aMade
   aMade -&gt; "ifndef" := 'NoScripts'
   aMade -&gt; %SUM := ( 'Регистрация типа ' l_TypeName Cat ) 
   aMade -&gt;^ cUserCodePrefix ^:= [ 
    ' ' 
    'TtfwTypeRegistrator.RegisterType('
    Self .TypeInfo
    ');'
   ] // aMade -&gt;^ cUserCodePrefix
  ) // MakeIniProcedure:
 )
 &gt;&gt;&gt; Result
; // RegTypeMethod

elem_iterator IniOperations
 VAR l_IniOperations
 Self .IniOperationsPrim &gt;&gt;&gt; l_IniOperations
 l_IniOperations
 RULES
  ( Self .IsConstants )
   begin 
    VAR l_Speller
    Self .Speller &gt;&gt;&gt; l_Speller
    RULES
     ( l_Speller .IsNotNil )
      begin
       VAR l_Parent
       Self .ElementOrParentThatCanHaveIniOperations &gt;&gt;&gt; l_Parent
       VAR l_Prefix
       Self .GetUP 'extprop:pas:ElementPrefix' &gt;&gt;&gt; l_Prefix
       Self .Attributes
       .for&gt;
       (
         IN aConst
         VAR l_Name
         [ 'Init_Str_' aConst .Name ] strings:Cat &gt;&gt;&gt; l_Name
         RULES
          (
           l_Parent call.me
           .filter&gt; ( .Name l_Name == )
           .IsEmpty
          ) 
           ( 
            .join&gt; ToArray: ( aConst l_Name aConst .Speller l_Prefix .MakeIniStr )
           ) 
        ; // RULES
       ) // .for&gt;
      end // ( l_Speller .IsNotNil )
    ; // RULES
   end // ( Self .IsConstants )
  (
   ( Self .IsTestCase )
   AND ( Self .Abstraction at_abstract != )
   AND ( Self .IsMixIn ! )
  ) 
   ( .join&gt; ToArray: ( Self .RegisterTestCaseMethod ) )
  ( Self .IsTestClass )
   ( .join&gt; ToArray: ( Self .RegisterTestClassMethod ) )
  ( Self .IsTagTable )
   ( .join&gt; ToArray: ( Self .RegisterTagTableMethod ) )
  ( 
   ( Self .IsServiceImplementation ) 
   AND ( l_IniOperations 'bind' .HasModelElementWithName ! )
  ) 
   ( .join&gt; ToArray: ( Self .RegisterServiceImplementationMethod ) )
  ( Self .IsClassOrMixIn )
   (
    VAR l_WasRegisterInEngine
    false &gt;&gt;&gt; l_WasRegisterInEngine
    
    if ( Self .IsMixIn ! ) then
    begin
     if ( Self .Abstraction at_abstract != ) then
     begin
      if ( Self GarantModel::TtfwRegisterableWord .InheritsFromOrSomeAncestorImplements ) then
      begin
       true &gt;&gt;&gt; l_WasRegisterInEngine
       if ( l_IniOperations 'Ini_Reg' .HasModelElementWithName ! ) then
       begin     
        .join&gt; ToArray: ( 
          'Ini_Reg' MakeIniProcedure: (
            IN aMade
           VAR l_TypeName
           Self .TypeName &gt;&gt;&gt; l_TypeName
           aMade -&gt; Parent := ( Self .WeakRef )
           aMade -&gt; "ifndef" := 'NoScripts'
           aMade -&gt; %SUM := ( 'Регистрация ' Self .Name Cat ) 
           aMade -&gt;^ cUserCodePrefix ^:= [ cSpace l_TypeName '.RegisterInEngine;' ]
          ) // MakeIniProcedure:
         ) // .join&gt;
       end // ( l_IniOperations GarantModel::l3UnknownPrim.ClearFields .HasModelElement )
      end // ( l_IniOperations 'Ini_Reg' .HasModelElementWithName ! )
     end // ( Self .Abstraction at_abstract != )
    end // ( Self .IsMixIn ! )
    
    if ( l_WasRegisterInEngine ! ) then
    begin
     if ( Self .NeedRegisterInScripts ) then
     begin
      if ( l_IniOperations 'Ini_Reg_Class' .HasModelElementWithName ! ) then
      begin     
       .join&gt; ToArray: ( 
         'Ini_Reg_Class' MakeIniProcedure: (
           IN aMade
          VAR l_TypeName
          Self .TypeName &gt;&gt;&gt; l_TypeName
          aMade -&gt; Parent := ( Self .WeakRef )
          aMade -&gt; "ifndef" := 'NoScripts'
          aMade -&gt; %SUM := ( 'Регистрация ' Self .Name Cat ) 
          aMade -&gt;^ cUserCodePrefix ^:= [ 
           if ( Self GarantModel::TtfwWord .InheritsFrom ) then
           begin
            ' ' Self .TypeName '.RegisterClass;'
           end
           else
           begin
            ' TtfwClassRef.Register(' Self .TypeName ');' 
           end 
          ] // aMade -&gt;^ cUserCodePrefix
         ) // MakeIniProcedure:
        ) // .join&gt;
      end // ( l_IniOperations 'Ini_Reg_Class' .HasModelElementWithName ! )
     end // ( Self .NeedRegisterInScripts )
    end // ( l_WasRegisterInEngine ! )
    
   ) // ( Self .IsClassOrMixIn )
   
  ( Self .IsEnum ) 
   begin
    if ( Self .NeedRegisterInScripts ) then
    begin
     .join&gt; ToArray: ( Self .RegTypeMethod )
    end // ( Self .NeedRegisterInScripts )
   end // ( Self .IsEnum )
   
  ( Self .IsException ) 
   begin
    if ( Self .NeedRegisterInScripts ) then
    begin
     .join&gt; ToArray: ( Self .RegTypeMethod )
    end // ( Self .NeedRegisterInScripts )
   end // ( Self .IsException )
   
  ( Self .IsInterface ) 
   begin
    if ( Self .NeedRegisterInScripts ) then
    begin
     .join&gt; ToArray: ( Self .RegTypeMethod )
    end // ( Self .NeedRegisterInScripts )
   end // ( Self .IsInterface )
   
  ( Self .IsScriptKeywordsPack )
   begin
    Self .InheritsEx 
    .join&gt; ( Self .ImplementsEx )
    
    .join&gt; ( 
     Self .OperationsEx
     .filter&gt; .IsSomeKeyWord
     .mapToTarget&gt;
    ) // .join&gt;
    
    .joinWithLambded&gt; 
    ( Self .OperationsEx ) ( .Parameters .mapToTarget&gt; )
    
    .filter&gt; .IsAcceptableForScripts
    .map&gt; .RegTypeMethod
    .filter&gt; ( .Name l_IniOperations SWAP .HasModelElementWithName ! )
    .for&gt; (
      IN aMethod
     .join&gt; ToArray: aMethod 
     array:Copy &gt;&gt;&gt; l_IniOperations
     // - перекопируем массив, чтобы убрать дубликаты
     l_IniOperations
     // - кладём его обратно на стек
    ) // .for&gt;
   end // ( Self .IsScriptKeywordsPack )
 ; // RULES
 
 &gt;&gt;&gt; Result
; // IniOperations

elem_iterator FiniOperations
 Self .OperationsEx
 .filter&gt; .IsFini
 &gt;&gt;&gt; Result
; // FiniOperations

ARRAY CompileTime-VAR g_DeferredInitialization nil

elem_proc OutIniFiniSection

 : OutInitialization
  if ( g_DeferredInitialization .IsNil ) then
  begin
   'initialization' .Out
  end // ( g_DeferredInitialization .IsNil )
  else
  begin
   g_DeferredInitialization .Out
   nil &gt;&gt;&gt; g_DeferredInitialization
  end // ( g_DeferredInitialization .IsNil )
 ; // OutInitialization
 
 VAR l_WasOut
 false &gt;&gt;&gt; l_WasOut
 VAR l_WasInitialization
 false &gt;&gt;&gt; l_WasInitialization
 Self .ForChildren&gt; .All (
  .IniOperations .for&gt; (
   if ( l_WasOut ! ) then
   begin
    true &gt;&gt;&gt; l_WasOut
    true &gt;&gt;&gt; l_WasInitialization
    OutInitialization
   end // ( l_WasOut ! )
   .OutIniOrFini
  ) // .IniOperations .for&gt;
 ) // Self .ForChildren&gt; .All
 l_WasOut ? OutLn
 
 false &gt;&gt;&gt; l_WasOut
 Self .ForChildren&gt; .All (
  .FiniOperations .for&gt; (
   if ( l_WasOut ! ) then
   begin
    true &gt;&gt;&gt; l_WasOut
    if ( l_WasInitialization ! ) then
    begin
     true &gt;&gt;&gt; l_WasInitialization
     OutInitialization
     OutLn
    end // ( l_WasInitialization ! )
    'finalization' .Out
   end // ( l_WasOut ! )
   .OutIniOrFini
  ) // .FiniOperations .for&gt;
 ) // Self .ForChildren&gt; .All
 l_WasOut ? OutLn
; // OutIniFiniSection

elem_proc OutImplementationSection
 Self .OutDefinitionsSection: .IsForImplementation
 
 VAR l_WasOut
 false &gt;&gt;&gt; l_WasOut
 Self .ForChildren&gt; .IsForImplementation (
  .GlobalVars 
  .filter&gt; ( .Visibility PrivateAccess != ) 
  .for&gt; ( .OutVar true &gt;&gt;&gt; l_WasOut )
 ) 
 Self .ForChildren&gt; .All (
  .GlobalVars 
  .filter&gt; ( .Visibility PrivateAccess == ) 
  .for&gt; ( .OutVar true &gt;&gt;&gt; l_WasOut )
 ) 
 
 l_WasOut ? OutLn
 
 Self .ForChildren&gt; .All (
  .ConstantsEx .filter&gt; ( .ConstantsListVisibility PrivateAccess == ) .OutConstantsList
 )

 Self .ForChildren&gt; .IsForImplementation (
   IN anItem
  VAR l_GlobalOperations
  anItem .GlobalOperations &gt;&gt;&gt; l_GlobalOperations
  VAR l_GlobalOperationsForOverload
  anItem .GlobalOperationsForOverload &gt;&gt;&gt; l_GlobalOperationsForOverload
  l_GlobalOperations 
  .for&gt; .MethodInterfaceForEx: l_GlobalOperationsForOverload .MethodBody
 )
 
 TF g_EnableMethodDirectives (
  false &gt;&gt;&gt; g_EnableMethodDirectives
  Self .ForChildren&gt; .IsForInterface (
    IN anItem
   VAR l_GlobalOperations
   anItem .GlobalOperations &gt;&gt;&gt; l_GlobalOperations
   VAR l_GlobalOperationsForOverload
   anItem .GlobalOperationsForOverload &gt;&gt;&gt; l_GlobalOperationsForOverload
   
   l_GlobalOperations 
   .filter&gt; ( .Visibility PrivateAccess == )
   .for&gt; .MethodInterfaceForEx: l_GlobalOperationsForOverload .MethodBody
   
   l_GlobalOperations 
   .filter&gt; ( .Visibility PrivateAccess != )
   .for&gt; .MethodInterfaceForEx: nil .MethodBody
  )
 ) // TF g_EnableMethodDirectives
 
 Self .ForChildren&gt; .All .OutImplementation
 
 Self .OutIniFiniSection
 
; // OutImplementationSection

STRING elem_func Defines
 Self .GetUP "defines" &gt;&gt;&gt; Result
 if ( Result .IsNil ) then
 begin
  VAR l_Parent
  Self .Parent &gt;&gt;&gt; l_Parent
  if ( l_Parent .IsNotNil ) then
  begin
   l_Parent call.me &gt;&gt;&gt; Result
  end // ( l_Parent .IsNotNil )
 end // ( Result .IsNil )
 else
 begin
  Self .PathOnly Result Cat &gt;&gt;&gt; Result
 end // ( Result .IsNil )
; // Defines

elem_proc OutUnitHeader
 [ '// Модуль: "' Self .FinalFileName '"' ] .Out
 [ '// Стереотип: "' Self .Stereotype .Name '"' ] .Out
 if ( Self .Name .IsNotNil ) then
 begin
  [ 
   '// Элемент модели: "' Self .Name '"' 
   if ( Self .UID .IsNotNil ) then
   begin
    ' MUID: (' Self .UID ')'
   end // ( Self .UID .IsNotNil )
  ] .Out
  if ( Self .TypeName .IsNotNil ) then
  begin
   if ( Self .Name Self .TypeName ?!= ) then
   begin
    [ '// Имя типа: "' Self .TypeName '"' ] .Out
   end // ( Self .Name Self .TypeName ?!= )
  end // ( Self .TypeName .IsNotNil ) 
 end // ( Self .Name .IsNotNil )
 OutLn
; // OutUnitHeader

PROCEDURE DoOutUnit
 ^ IN aLambda
 TF g_Implementor (
  nil &gt;&gt;&gt; g_Implementor
  TF g_WasTypeOpener (
   nil &gt;&gt;&gt; g_WasTypeOpener
   TF g_WasConst (
    false &gt;&gt;&gt; g_WasConst
    TF g_WasForwarded (
     false &gt;&gt;&gt; g_WasForwarded
     TF g_WasType (
      DropWasType
      TF g_MixInValues (
       [] &gt;&gt;&gt; g_MixInValues
       TF g_OutedTypes (
        [] &gt;&gt;&gt; g_OutedTypes
        TF g_ForwardedTypes (
         [] &gt;&gt;&gt; g_ForwardedTypes
         aLambda DO
        ) // TF g_ForwardedTypes
       ) // TF g_OutedTypes 
      ) // TF g_MixInValues
     ) // TF g_WasType
    ) // TF g_WasForwarded
   ) // TF g_WasConst
  ) // TF g_WasTypeOpener
 ) // TF g_Implementor
; // DoOutUnit

elem_proc OutApplicationBody
 RULES
  ( Self .IsTestTarget )
   begin
    [
     ' {$IfDef nsTest}' \n
     ' g_CVSPath := ' 
     cQuote 
     Self .FinalFileName sysutils:ExtractFilePath '\' .CutSuffix
     cQuote ';' \n
     ' {$EndIf nsTest}'
    ] .Out
    Indented: ( Self .UserCode: 'CVSPath' () )
    
    RULES
     ( Self .UPisTrue "need UC in project" )
      begin
       Indented: ( Self .UserCode: 'manualcode' () )
      end // ( Self .UPisTrue "need UC in project" )
     ( Self .IsVCMTestTarget )
      begin
       RULES
        (
         Self .DependsVCMGUI
         .filter&gt; ( .GetUP "F1Like" false ?== )
         .IsEmpty
        )
         ( ' TF1AutoTestSuite.Register;' .Out )
        DEFAULT
         ( ' TAutoTestsSuite.Register;' .Out )
       ; // RULES 
       
       Self .DependsVCMGUI
       .for&gt; (
         IN anItem
        anItem call.me 
       ) // .for&gt;
      end // ( Self .IsVCMTestTarget )
     DEFAULT
      begin
       if ( Self .UPisTrue "no scripts" ! ) then
       begin
        ' TAutoTestsSuite.Register;' .Out
       end // ( Self .UPisTrue "no scripts" ! )

       ' try' .Out
       [
       '  if KTestRunner.NeedKTestRunner(['
       
       VAR l_WasComma
       false &gt;&gt;&gt; l_WasComma
       
       Self .ChildrenEx
       .filter&gt; .IsTestResults
       .map&gt; .TypeName
       .for&gt; ( .WithComma: l_WasComma .KeepInStack )
       
       ']) then'
       ] .Out
       '   KTestRunner.RunRegisteredTests' .Out
       '  else' .Out
       '  if System.IsConsole then' .Out
       '   TextTestRunner.RunRegisteredTests' .Out
       '  else' .Out
       '   GUITestRunner.RunRegisteredTests;' .Out
       ' except' .Out
       '  on E: Exception do' .Out
       '  begin' .Out
       '   {$If defined(MTDORB) AND defined(NoKPageTool)}' .Out
       '   if TKBridge.Exists then' .Out
       '    TKBridge.Instance.Logout;' .Out
       '   {$IfEnd}' .Out
       '   l3System.Exception2Log(E);' .Out
       '   Halt(2);' .Out
       '  end;//Exception' .Out
       ' end;//try..except' .Out
       ' if (TestsExitCode &lt;&gt; 0) then' .Out
       '  Halt(TestsExitCode);' .Out
      end // DEFAULT
    ; // RULES  
    
   end // ( Self .IsTestTarget )
  ( Self .IsVCMGUI )
   begin
    [
     ' ' 'StdRes.TdmStdRes.Run(str_' Self .Name 'Title' ',' ' ' 
     cQuote Self .GetUP "HelpFile" '.chm' cQuote 
     ');'
    ] .Out 
   end // ( Self .IsVCMGUI )
  DEFAULT
   begin
    Indented: ( Self .UserCode: 'manualcode' () )
   end // DEFAULT
 ; // RULES
; // OutApplicationBody

STRING elem_func ProjectUnitPath
 Cached:
 (
  VAR l_Path
  RULES
   ( Self IsString )
    RULES
     ( Self GarantModel::StdRes .Name == )
      ( GarantModel::StdRes .Name '.pas' Cat )
     DEFAULT
      '' 
    ; // RULES
   ( Self .Name GarantModel::StdRes .Name == )
    ( GarantModel::StdRes .Name '.pas' Cat )
   ( Self .InTie )
    // - тут надо брать путь для адаптера
    ( 
     VAR l_pasPath
     Self .GetUP 'pas:Path' &gt;&gt;&gt; l_pasPath
     RULES
      ( l_pasPath .IsNil )
       ''
      DEFAULT 
       ( [ cRoot l_pasPath ] cPathSep strings:CatSep )
     ; // RULES  
    )   
   ( Self .UnitName 'GblAdapter' == )
    ''  
   DEFAULT
    ( Self .FinalFileName )
  ; // RULES
  &gt;&gt;&gt; l_Path
  
  if ( l_Path .IsNotNil ) then
  begin
   if ( l_Path 'NotFinished\Borland\Delphi\Rtl\Sys' string:Pos -1 != ) then
   begin
    '' &gt;&gt;&gt; l_Path
   end // ( l_Path 'NotFinished\Borland\Delphi\Rtl\Sys' string:Pos -1 != )
  end // ( l_Path .IsNotNil )
  
  if ( l_Path .IsNotNil ) then
  begin
   l_Path cNotFinished '' string:Replace &gt;&gt;&gt; l_Path
   l_Path cNotCompleted '' string:Replace &gt;&gt;&gt; l_Path
   l_Path 'NotFinished\' '' string:Replace &gt;&gt;&gt; l_Path
  end // ( l_Path .IsNotNil )
  l_Path 
 ) 
 &gt;&gt;&gt; Result
; // ProjectUnitPath

STRING elem_func ProjectUnitName
 Self .UnitName
 
 VAR l_Path
 Self .ProjectUnitPath &gt;&gt;&gt; l_Path
 
 if ( l_Path .IsNotNil ) then
 begin
  [ ' in ' cQuote l_Path cQuote ] strings:Cat Cat
 end // ( l_Path .IsNotNil )
 
 &gt;&gt;&gt; Result
; // ProjectUnitName

elem_proc OutUnit
 DoOutUnit (
  TF g_DefaultInterfaceAncestor (
  
   Self .ChildrenEx .filter&gt; ( .UPisTrue "is default ancestor" ) .FirstElement &gt;&gt;&gt; g_DefaultInterfaceAncestor
   
   [ 
    RULES
     ( Self .IsDLL )
      'library'
     ( Self .IsExe )
      'program'
     DEFAULT
      'unit' 
    ; // RULES  
    cSpace
    Self .UnitNamePrim ';' 
   ] .Out
   Self .OutDocumentation
   OutLn
   
   Self .OutUnitHeader
   
   VAR l_Defines
   Self .Defines &gt;&gt;&gt; l_Defines
   if ( l_Defines .IsNotNil ) then
   begin
    [ cOpenComment '$Include ' l_Defines cCloseComment ] .Out
    OutLn
   end // ( l_Defines .IsNotNil )
   
   if ( Self .IsExe ) then
   begin
    if ( Self .UPisTrue "console" ) then
    begin
     '{$APPTYPE CONSOLE}' .Out
     OutLn
    end // ( Self .UPisTrue "console" )
   end // ( Self .IsExe )
   
   if ( Self .IsTarget ! ) then
   begin
    'interface' .Out
    OutLn
   end // ( Self .IsTarget ! )
   
   ARRAY VAR l_Used
   [] &gt;&gt;&gt; l_Used
   
   Self .IfDef: ( 
    if ( Self .IsTarget ) then
    begin
     Self 'intf_uses' .OutUses: l_Used ( Self .ProjectUses ) .ProjectUnitName
    end // ( Self .IsTarget )
    else
    begin
     Self 'intf_uses' .OutUses: l_Used ( Self .IntfUses ) .UnitName
    end // ( Self .IsTarget )
   
    Self .OutInterfaceSection
    
    if ( Self .IsElementProxy ) then
    begin
     Self .UserCode: 'intf_code' ()
     OutLn
    end // ( Self .IsElementProxy )
   ) // Self .IfDef:
   
   if ( Self .IsTarget ! ) then
   begin
    'implementation' .Out
    OutLn
   end // ( Self .IsTarget ! )
   
   Self .IfDef: ( 
    if ( Self .IsTarget ! ) then
    begin
     Self 'impl_uses' .OutUses: l_Used ( Self .ImplUses ) .UnitName
    end // ( Self .IsTarget ! )
    
    RULES
     ( Self .IsTestClass )
      ( 
       Self .MainAncestor .IfDef: 
       ( 
        Self .OutImplementationSection 
       ) // Self .MainAncestor .IfDef:
      ) // ( Self .IsTestClass )
     ( Self .IsSimpleClass )
      ( 
       Self .MainAncestor .IfDef: 
       ( 
        Self .OutImplementationSection 
       ) // Self .MainAncestor .IfDef:
      ) // ( Self .IsSimpleClass )
     DEFAULT
      ( Self .OutImplementationSection )
    ; // RULES   
    
    RULES
     ( Self .IsElementProxy )
      (
       Self .UserCode: 'impl_code' ()
       OutLn
      )
     ( Self .IsDLL )
      (
       'exports' .Out
       Self .UserCode: 'exports' ( )
       ';' .Out
       OutLn
      )
    ; // RULES
   ) // Self .IfDef:
   
   RULES
    ( Self .IsExe )
     (
      if ( Self .UPisTrue "console" ! ) then
      begin
       [ '{$R ' Self .UnitName '.res' '}' ] .Out
       if ( Self .UPisTrue "needs second icon" ) then
       begin
        [ '{$R main_icon2.res}' ' // вторая иконка приложения' ] .Out
       end // ( Self .UPisTrue "needs second icon" )
       OutLn
      end // ( Self .UPisTrue "console" ! )
      
      if ( Self .UPisTrue "need UC in project" ) then
      begin
       Self .UserCode: 'manualres' ()
       OutLn
      end // ( Self .UPisTrue "need UC in project" )
      
      'begin' .Out
      Self .OutApplicationBody
     ) // ( Self .IsExe )
    ( Self .IsDLL ) 
     (
      [ '{$R ' Self .UnitName '.res' '}' ] .Out
      OutLn
      'begin' .Out
     ) // ( Self .IsDLL )
   ; // RULES
   
   'end.' .Out
  ) // TF g_DefaultInterfaceAncestor 
 ) // DoOutUnit
; // OutUnit

STRING elem_func DefineName
 Cached:
 (
  Self .UnitName cDot cUnderline string:Replace
 ) 
 &gt;&gt;&gt; Result
; // DefineName

elem_proc OutMixIn
 DoOutUnit (
  VAR l_DefineName
  Self .DefineName &gt;&gt;&gt; l_DefineName
  
  [ cOpenComment '$IfNDef ' l_DefineName cCloseComment \n ] .Out
  
  Self .OutUnitHeader
  
  [ cOpenComment '$Define ' l_DefineName cCloseComment \n ] .Out
  
  Self .IfDefElse: 
  ( 
   Self .OutInterfaceSection
  ) 
  (
   VAR l_Parent
   Self .CalcParentAndInclude &gt;&gt;&gt; l_Parent
   [ Self .TypeName ' = ' l_Parent .TypeName ';' \n ] .Out
  )
  // Self .IfDefElse:
  
  [ cOpenComment '$Else ' l_DefineName cCloseComment \n ] .Out
  
  VAR l_DefineNameImpl
  [ l_DefineName '_impl' ] &gt;&gt;&gt; l_DefineNameImpl
  
  [ cOpenComment '$IfNDef ' l_DefineNameImpl cCloseComment \n ] .Out
  
  [ cOpenComment '$Define ' l_DefineNameImpl cCloseComment \n ] .Out
  
  TF g_DeferredInitialization (
   [ cOpenComment '$Else ' l_DefineNameImpl cCloseComment \n ] &gt;&gt;&gt; g_DeferredInitialization
   
   Self .IfDef: ( 
    Self .OutImplementationSection
   ) // Self .IfDef:
  )
  
  [ cOpenComment '$EndIf ' l_DefineNameImpl cCloseComment \n ] .Out
  
  [ cOpenComment '$EndIf ' l_DefineName cCloseComment \n ] .Out
 ) // DoOutUnit
; // OutMixIn

STRING elem_func PasFinalFileName
 Self .GetUP 'intf.pas:Path' &gt;&gt;&gt; Result
 if ( Result .IsNil ) then
 begin
  RULES
   ( Self .IsTestLibrary )
    begin
     Self .PasPathOnly &gt;&gt;&gt; Result
     if ( Result .IsNotNil ) then
     begin
      [ 
       Result 
       [ Self .Name cSpace cUnderline string:Replace '_TestLibrary' '.pas' ] strings:Cat 
      ] cPathSep strings:CatSep &gt;&gt;&gt; Result
     end // ( Result .IsNotNil )
    end // ( Self .IsTestLibrary )
   ( Self .IsTestUnit )
    begin
     Self .PasPathOnly &gt;&gt;&gt; Result
     if ( Result .IsNotNil ) then
     begin
      [ Result 
       [ 
        [ Self .Parent .Name cUnderline Self .Name ] strings:Cat
        cSpace cUnderline string:Replace
        cDot cUnderline string:Replace
        '_TestUnit' '.pas' 
       ] strings:Cat 
      ] cPathSep strings:CatSep &gt;&gt;&gt; Result
     end // ( Result .IsNotNil )
    end // ( Self .IsTestUnit )
   ( Self .IsElementProxy )
    begin
     Self .PasPathOnly &gt;&gt;&gt; Result
     if ( Result .IsNotNil ) then
     begin
      [ 
       Result 
       [ Self .Name cProxy '.pas' ] strings:Cat 
      ] cPathSep strings:CatSep &gt;&gt;&gt; Result
     end // ( Result .IsNotNil )
    end // ( Self .IsElementProxy )
  ; // RULES
 end // ( Result .IsNil )
; // PasFinalFileName

elem_generator pas
 
 CONST Ext '.pas'

 BOOLEAN elem_func CanCopyToFinalFile
  RULES
   ( Self .UseNewGen )
    true
   DEFAULT
    false 
  ; // RULES
  &gt;&gt;&gt; Result
 ; // CanCopyToFinalFile
 
 STRING elem_func FinalFileNamePrim
  Self .PasFinalFileName &gt;&gt;&gt; Result 
 ; // FinalFileNamePrim
 
 RULES
  ( Self .IsMixIn )
   ( Self .OutMixIn )
  ( Self .IsUserType ) 
   ( Self .OutUnit )
  ( Self .IsInterfaces )
   ( Self .OutUnit )
  ( Self .IsEvdSchemaElement )
   ( Self .OutUnit )
  ( Self .IsSimpleClass )
   ( Self .OutUnit )
  ( Self .IsElementProxy )
   ( Self .OutUnit )
  ( Self .IsUtilityPack )
   ( Self .OutUnit )
  ( Self .IsTestClass ) 
   ( Self .OutUnit )
  ( Self .IsTarget ) 
   ( Self .OutUnit )
  ( Self .IsTagTable ) 
   ( Self .OutUnit )
  ( Self .IsTestLibrary ) 
   ( Self .OutUnit )
  ( Self .IsTestUnit ) 
   ( Self .OutUnit )
  DEFAULT
   ( Self .Name .Out )
 ; // RULES
; // pas

elem_generator pas_dependent
 
 Inherits .pas
 
 STRING elem_func FinalFileNamePrim
  Self .PasFinalFileName &gt;&gt;&gt; Result 
  if ( Result .IsNotNil ) then
  begin
   Result .? Ext sysutils:ChangeFileExt &gt;&gt;&gt; Result
  end // ( Result .IsNotNil )
 ; // FinalFileNamePrim
 
; // pas_dependent

STRING elem_func AttrName
 RULES
  ( Self .IsOverride )
   ( Self .MainAncestor call.me )
  DEFAULT
   ( Self .Name )
 ; // RULES  
 &gt;&gt;&gt; Result
; // AttrName

ModelElement elem_func AttrType
 RULES
  //( Self .IsOverride )
  // ( Self .MainAncestor call.me )
  DEFAULT
   ( Self .MethodType )
 ; // RULES  
 &gt;&gt;&gt; Result
; // AttrType

ARRAY CompileTime-VAR g_FormControls nil

elem_proc ToDFM
//	&lt;%C#f_ToDFM()&gt;\
//	&lt;%G#f_ToDFM()&gt;\
//      &lt;%R#f_ToDFM()&gt;

//	[{%S%f_NeedPutToDFM()=true}\
//	[{%f_exists_in_list(FORM_CONTROLS,"%S%f_pas_AttrName()")=false}\
//	%f_add_to_list(FORM_CONTROLS,"%S%f_pas_AttrName()")\
//	\n# object %S%f_pas_AttrName(): %S%f_pas_ResultTypeName()\
//	[{"%SD"!=""&%S{need Caption}!=false}\n#  Caption = '%SD']\
//	&lt;%C#f_ToDFM()&gt;\
//	[{%S%f_IsOverride()=true}\
//	&lt;{}{}{r}%g&lt;%C#f_ToDFM()&gt;&gt;\
//	]
//	# end\
//	]\
//      ]

 RULES
  ( Self .IsVCMCustomForm )
   (
    Self .Attributes .for&gt; call.me
    Self .InheritsEx .for&gt; call.me
    Self .ImplementsEx .for&gt; call.me
   )
  ( Self .IsControlPrim )
   (
    if ( Self .NeedPutToDFM ) then
    begin
     if ( Self .AttrName .TextNotInArray: g_FormControls ) then
     begin
      Self .AttrName .AddToArray: g_FormControls
      Indented: (
       [ ' object ' Self .AttrName ': ' Self .AttrType .TypeName ] .Out
       Self .Attributes .for&gt; call.me
       
       if ( Self .IsOverride ) then
       begin
        Self .InheritsEx .for&gt; ( .Attributes .for&gt; call.me )
       end // ( Self .IsOverride )
       
       [ ' end' ] .Out
      ) // Indented:
     end // ( Self .AttrName .TextNotInArray: g_FormControls )
    end // ( Self .NeedPutToDFM )
   ) 
 ; // RULES

; // ToDFM

elem_proc BeforeDFMControls
 RULES
  ( Self .IsVCMForm )
   (
    [ '  Caption = ' cQuote Self .Documentation cQuote ] .Out
    [ '  Color = $00F9F8FA' ] .Out
    
    VAR l_ZoneType
    Self .GetUP "ZoneType" &gt;&gt;&gt; l_ZoneType
    if ( l_ZoneType .IsNotNil ) then
     if ( l_ZoneType 'Any' != ) then
     begin
      [ '  ZoneType = vcm_zt' l_ZoneType ] .Out
     end // ( l_ZoneType 'Any' != )
     
    [ '  PixelsPerInch = 96' ] .Out
    [ '  TextHeight = 13' ] .Out
    [ '  object Entities: TvcmEntities' ] .Out
    [ '    Left = 24' ] .Out
    [ '    Top = 24' ] .Out
    [ '  end' ] .Out
   )
 ; // RULES  
; // BeforeDFMControls

elem_generator dfm
 
 Inherits .pas_dependent

 CONST Ext '.dfm'

 BOOLEAN elem_func NeedOwnFilePrim
  Self .IsVCMCustomForm
  AND ( Self .Abstraction at_final == )
  &gt;&gt;&gt; Result 
 ; // NeedOwnFilePrim
 
 BOOLEAN elem_func CanCopyToFinalFile
  Self .GetUP "finished dfm" false ?!= &gt;&gt;&gt; Result
 ; // CanCopyToFinalFile
 
 TF g_FormControls (
  [] &gt;&gt;&gt; g_FormControls
  [ 'object ' Self .TypeName .CutT ': ' Self .TypeName ] .Out
  [ '  Left = 204' ] .Out
  [ '  Top = 118' ] .Out
  [ '  Width = 320' ] .Out
  [ '  Height = 240' ] .Out
  Self .BeforeDFMControls
  Self .ToDFM
  [ 'end' ] .Out
 ) // TF g_FormControls
 
; // dfm
 
elem_generator res.cmd
 
 Inherits .pas_dependent

 CONST Ext '.res.cmd'
 
 BOOLEAN elem_func NeedOwnFilePrim
  Self .NeedsScript &gt;&gt;&gt; Result 
 ; // NeedOwnFilePrim
  
 BOOLEAN elem_func CanCopyToFinalFile
  true &gt;&gt;&gt; Result
 ; // CanCopyToFinalFile
 
 VAR l_Name
 WithGen: .pas ( Self .EffectiveUnitName &gt;&gt;&gt; l_Name )
 [ 'MakeCo ' l_Name '.rc.script' ] .Out
 [ 'brcc32 ' l_Name '.rc' ] .Out
 //call.inherited
; // res.cmd

BOOLEAN elem_func NeedsWordsAliases
 Cached:
 (
  RULES
   ( Self .IsScriptKeywordsPack ! )
    false
   ( Self .UPisTrue "no class name" )
    true
   ( Self .UPisTrue "no_pop" ) 
    true
   DEFAULT
    false 
  ; // RULES
 ) 
 &gt;&gt;&gt; Result
; // NeedsWordsAliases

elem_generator rc.script
 
 Inherits .res.cmd

 CONST Ext '.rc.script'

 BOOLEAN elem_func CanCopyToFinalFile
  /*{
  RULES
   ( Self .NeedsWordsAliases ! )
    true
   DEFAULT
    false
  ; // RULES
  }*/
  true &gt;&gt;&gt; Result
 ; // CanCopyToFinalFile
 
 Self .OutUnitHeader
 
 VAR l_WasManUses
 false &gt;&gt;&gt; l_WasManUses
 
 : OutManUses
  l_WasManUses ! ? (
   true &gt;&gt;&gt; l_WasManUses
   OutLn
   Self .UserCode: 'man_uses' () 
   OutLn
  ) // l_WasManUses ! ? 
 ; // OutManUses
 
 Self .NeedsWordsAliases ?
  OutManUses
  
 : OutScriptFrameWorkAliases
 
  : OutWordAlias
    IN aG
    
   if ( 
       ( Self .UPisTrue "no class name" ! ) 
       AND ( aG .SelfName 'SV' != )
      ) then
   begin
    'USES' .Out
    [ cSpace 'axiom:' aG .SelfName ] .Out
    ';' .Out
    OutLn
   end // ( Self .UPisTrue "no class name" ! )
   
   [ '// Класс ' aG .Name ' - ' aG .SelfName ] .Out 
   
   Self .OperationsEx
   .filter&gt; .IsKeyWord
   .for&gt; (
     IN anOp
    VAR l_NameForScript 
    anOp .NameForScript &gt;&gt;&gt; l_NameForScript
    [ 
      '//  Операция ' anOp .Name 
      if ( l_NameForScript .IsNotNil ) then
      begin
       ' - ' l_NameForScript
      end // ( l_NameForScript .IsNotNil )
    ] .Out
    
    if ( anOp .Speller .NotIsNil ) then
    begin
     anOp .Speller .NameForScript &gt;&gt;&gt; l_NameForScript
     [
      '//  Класс реализующий операцию '
      anOp .Speller .Name
      ' - '
      l_NameForScript
     ] .Out
     
     if ( anOp .IsCreator ! ) then
     begin
      VAR l_CanonicName
      [ 
       'pop:' 
       aG .SelfName
       ':' 
       anOp .Name 
        'pop_' .CutPrefix
        [ aG .SelfName string:Lower cUnderline ] strings:Cat .CutPrefix
        cUnderline ':' string:Replace
      ] strings:Cat &gt;&gt;&gt; l_CanonicName
      
      if ( l_CanonicName l_NameForScript != ) then
      begin
       [ 'WordAlias ' l_CanonicName cSpace l_NameForScript ] .Out
      end // ( l_CanonicName l_NameForScript != )
     end // ( anOp .IsCreator ! )
    end // ( anOp .Speller .NotIsNil )
    
   ) // Self .OperationsEx
   
   OutLn
   
  ; // OutWordAlias
  
  if ( Self .NeedsWordsAliases ) then
  begin
   Self .InheritsEx
   .join&gt; ( Self .ImplementsEx )
   .filter&gt; .IsAcceptableForScripts
   //.filter&gt; ( DROP Self .NeedsWordsAliases /* Тут надо ещё проверку на SV */ )
   .for&gt; OutWordAlias
  end // ( Self .NeedsWordsAliases )
  
 ; // OutScriptFrameWorkAliases 
  
 Self .IsScriptKeywordsPack ?
  OutScriptFrameWorkAliases
 
 Self .UserCode: 'impl' ()
 OutLn
 'EXPORTS' .Out
 Self .UserCode: 'exports' ( ' *' )
 OutLn
; // rc.script
 
elem_generator rc
 
 Inherits .res.cmd

 CONST Ext '.rc'
 
 Self .OutUnitHeader
 
 VAR l_Name
 WithGen: .pas ( Self .EffectiveUnitName &gt;&gt;&gt; l_Name )
 [ l_Name ' RCDATA LOADONCALL MOVEABLE DISCARDABLE ' l_Name '.rc.script.co' ] .Out
 //call.inherited
; // rc

ARRAY CompileTime-VAR g_GeneratedElements []
%REMARK 'Ранее сгенерированные элементы'

elem_proc GenerateWithChildren
 Sequence IN aGenerators
 
 if ( Self .NotInArray: g_GeneratedElements ) then
 begin
  Self .AddToArray: g_GeneratedElements
  aGenerators CodeIterator .for&gt; (
  // - цикл по генераторам для Self
   TtfwWord IN aGenerator
   TF g_CurrentGenerator (
    aGenerator &gt;&gt;&gt; g_CurrentGenerator
    if ( Self .NeedOwnFile ) then
    begin
     VAR l_Name
     Self .Name &gt;&gt;&gt; l_Name
     [ l_Name ' ' g_CurrentGenerator .WordName ] strings:Cat &gt;&gt;&gt; l_Name
     Log: [ l_Name ' generation start' ]
     VAR l_Time
     StartTimer
     TRY
      ( Self .GenerateWordToFileWith: .CurrentGenerator )
     FINALLY
      l_Name StopTimerNoLog &gt;&gt;&gt; l_Time
     END // TRY..FINALLY 
     l_Time 1000 DIV &gt;&gt;&gt; l_Time
     if ( l_Time &gt; 3 ) then
     begin
      Log: [ l_Name ' generation end ' l_Time ' seconds' ]
     end // ( l_Time &gt; 3 )
    end // ( Self .NeedOwnFile )
    else
     ( Self .DeleteWordFile ) 
   ) // TF g_CurrentGenerator
  ) // aGenerators CodeIterator .for&gt;
  
  Self .ChildrenEx .for&gt; ( aGenerators call.me )
  // - тут генерируем детей  
 end // Self .NotInArray: g_GeneratedElements
; // GenerateWithChildren

elem_proc call.generators.in.list
 Sequence ^ IN aGenerators
 Self aGenerators .GenerateWithChildren
; // call.generators.in.list

elem_proc Generate
 g_GeneratedFiles .IsNil ?FAIL 'Массив g_GeneratedFiles не инициализирован'
 g_GeneratedElements .IsNil ?FAIL 'Массив g_GeneratedElements не инициализирован'
 
 Self .call.generators.in.list ( .pas .res.cmd .rc .rc.script .dfm )
; // Generate