<div dir="ltr" style="text-align: left;" trbidi="on">
По мотивам - &nbsp;<a href="http://programmingmindstream.blogspot.ru/2015/12/1162.html?showComment=1450717154802#c256225446808977907">http://programmingmindstream.blogspot.ru/2015/12/1162.html?showComment=1450717154802#c256225446808977907</a><br />
<br />
Предыдущая серия была тут -&nbsp;<a href="http://programmingmindstream.blogspot.ru/2015/12/1149.html">#1149. О кешировании. Поговорим про добавление вложенных элементов</a>.<br />
<br />
Ну и тут поступил вопрос про параметры слов (функций) -&nbsp;<a href="http://programmingmindstream.blogspot.ru/2015/12/1162.html?showComment=1450717154802#c256225446808977907">http://programmingmindstream.blogspot.ru/2015/12/1162.html?showComment=1450717154802#c256225446808977907</a>.<br />
<br />
Раз есть вопрос, то постараюсь описать - как определяются слова и их параметры.<br />
<br />
Историю коммитов можно посмотреть тут - <a href="https://bitbucket.org/lulinalex/mindstream/commits/branch/B284_Inheritance_Try">https://bitbucket.org/lulinalex/mindstream/commits/branch/B284_Inheritance_Try</a>.<br />
<br />
Ещё раз оговорюсь:<br />
<br />
Идеологически наша скриптовая машина построена на стековой FORTH-машине - <a href="https://ru.wikipedia.org/wiki/%D0%A4%D0%BE%D1%80%D1%82_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)">https://ru.wikipedia.org/wiki/%D0%A4%D0%BE%D1%80%D1%82_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)</a><br />
.<br />
<br />
Так что - было бы неплохо ознакомится с языком FORTH.<br />
<br />
Для "общего понимания".<br />
<br />
Итак.<br />
<br />
Простейшее слово определяется так:<br />
<br />
<pre class="brush:delphi">: // - признак начала слова
A // - имя слова
 1 &gt;&gt;std::out // - код слова - печатает число 1 или
 1 . // - также печатает число 1
; // - признак конца слова

A // - вызов слова A
</pre>
<br />
Пример можно скопировать в файл Example.script и запустить:<br />
<br />
call.ms.script.exe Example.script или<br />
call.ms.script.exe Example.script &gt; a.out<br />
<br />
Утилита call.ms.script.exe находится тут - <a href="https://bitbucket.org/lulinalex/mindstream/src/0bea4adaed7cbc645faa484fcb38f8aae6562827/Examples/Scripts/call.ms.script.exe?at=B284_Inheritance_Try">https://bitbucket.org/lulinalex/mindstream/src/0bea4adaed7cbc645faa484fcb38f8aae6562827/Examples/Scripts/call.ms.script.exe?at=B284_Inheritance_Try</a><br />
<br />
<b>Замечение:</b><br />
Утилита может молча не запускаться, это значит, что её блокирует антивирус. Так как она "получена не из благонадёжного источника".<br />
<br />
В этом случае её стоит проверить антивирусом и включить в список разрешённых программ.<br />
Продолжим.<br />
<br />
Естественно, как и в любом другом языке программирования, у нас слова могут иметь параметры.<br />
<br />
Простейший пример:<br />
<br />
<pre class="brush:delphi">: A
  IN aParam // - определяем параметр aParam, слева от нашего слова A
 aParam // - получаем значение параметра
 . // - печатаем значение параметра
: // A

1 A // - вызов нашего слова A с передачей ему ЗНАЧЕНИЯ числа 1 как значения параметра
</pre>
<br />
Можно расширить пример и определить ТИП параметра. Вот так:<br />
<br />
<pre class="brush:delphi">: A
  INTEGER IN aParam // - определяем ЦЕЛОЧИСЛЕННЫЙ параметр aParam, слева от нашего слова A
 aParam // - получаем значение параметра
 . // - печатаем значение параметра
: // A

1 A // - вызов нашего слова A с передачей ему ЗНАЧЕНИЯ числа 1 как значения параметра
</pre>
<br />
Тогда в нашу функцию можно будет передать ТОЛЬКО ЦЕЛОЧИСЛЕННЫЕ значения.<br />
<br />
Но о типах параметров и переменных мы поговорим чуть позже. В <b>отдельной</b> статье.<br />
<br />
В качестве "лирического отступления" рекомендую ознакомиться с описанием "базовой аксиоматики" - <a href="https://bitbucket.org/lulinalex/mindstream/src/a071353dbd21d3afaf8f42b774cc890e0f5a74ce/Examples/ScriptedAxiomatics/kwMain.rc.script?at=B284_Inheritance_Try&amp;fileviewer=file-view-default">https://bitbucket.org/lulinalex/mindstream/src/a071353dbd21d3afaf8f42b774cc890e0f5a74ce/Examples/ScriptedAxiomatics/kwMain.rc.script?at=B284_Inheritance_Try&amp;fileviewer=file-view-default</a><br />
<br />
До сих пор мы рассмотрели ОДИН параметр слева.<br />
<br />
Рассмотрим теперь НЕСКОЛЬКО параметров слева.<br />
<br />
Пример:<br />
<br />
<pre class="brush:delphi">: A
  INTEGER IN aParam1 // - определяем первый параметр
  INTEGER IN aParam2 // - определяем второй параметр
 aParam1 // - получаем значение параметра aParam1
 aParam2 // - получаем значение параметра aParam2
 + // - получаем сумму двух значений
 . // - печатаем получившийя результат
; // A

1 2 A // - вызываем наше слово A для двух ЦЕЛОЧИСЛЕННЫХ значений - 1 и 2
</pre>
<br />
Хорошо. Мы поговорили про передачу параметров <b>в</b> слово.<br />
<br />
А как получить значение <b>из</b> слова?<br />
<br />
Разберём этот вопрос.<br />
<br />
Простейший пример:<br />
<br />
<pre class="brush:delphi">: A
  INTEGER IN aParam1 // - определяем первый параметр
  INTEGER IN aParam2 // - определяем второй параметр
 aParam1 // - получаем значение параметра aParam1
 aParam2 // - получаем значение параметра aParam2
 + // - получаем сумму двух значений
 // - тут ничего не печатаем, а просто оставляем полученное значение на стеке
; // A

1 2 A // - вызываем наше слово A для двух ЦЕЛОЧИСЛЕННЫХ значений - 1 и 2
. // - печатаем значение со стека, фактически то, что нам вернула функция A
</pre>
<br />
Методика "оставления значения на стеке" используется не только в "допотопном FORTH", но и во вполне себе "современном Ruby" - <a href="https://ru.wikipedia.org/wiki/Ruby">https://ru.wikipedia.org/wiki/Ruby</a>.<br />
<br />
Тут есть один <b>недостаток</b> (он же на самом деле - <b>преимущество</b>) - вызываемая функция может не положить на стек НИЧЕГО, может положить ОДНО значение, а может положить НЕСКОЛЬКО значений.<br />
<br />
А вызывающая сторона этот факт <b>не сможет</b> проконтроллировать.<br />
<br />
Как быть?<br />
<br />
Для этого нам надо определить ТИП ВОЗВРАЩАЕМОГО значения.<br />
<br />
Пример:<br />
<pre class="brush:delphi">
INTEGER // - определяем тип возвращаемого значения и "неявную переменную" Result
: A
  INTEGER IN aParam1 // - определяем первый параметр
  INTEGER IN aParam2 // - определяем второй параметр
 aParam1 // - получаем значение параметра aParam1
 aParam2 // - получаем значение параметра aParam2
 + // - получаем сумму двух значений
 // - тут ничего не печатаем, а просто оставляем полученное значение на стеке
; // A

1 2 A // - вызываем наше слово A для двух ЦЕЛОЧИСЛЕННЫХ значений - 1 и 2
. // - печатаем значение со стека, фактически то, что нам вернула функция A
</pre>
<br/>
<br /></div>
