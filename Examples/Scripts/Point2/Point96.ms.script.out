VOID Test PointTest
 IMMEDIATE VOID NamedWordProducer %FIELDS
  %FIELDS
  Ctx:SetWordProducerForCompiledClass
  '%Fld'
  Ctx:SetNewWordName
  @
  OPERATOR
  DO
 ; // IMMEDIATE VOID NamedWordProducer %FIELDS
 
 ARRAY FUNCTION %Fld
  IN %S
  VAR l_List
  %S
  %%
  '%Fld'
  >>>
  l_List
  if
   (
    l_List
    NotValid
   )
  then
   (
    Result :=
    [
    ]
   )
  else
   (
    Result :=
    (
     l_List
     CodeIterator
    )
   )
 ; // ARRAY FUNCTION %Fld
 
 ARRAY FUNCTION %G
  IN %S
  Result :=
  (
   '%G'
   %S
   ELEMLIST
  )
 ; // ARRAY FUNCTION %G
 
 ARRAY FUNCTION %R
  IN %S
  Result :=
  (
   '%R'
   %S
   ELEMLIST
  )
 ; // ARRAY FUNCTION %R
 
 class_impl _:Object
  %FIELDS %Fld
   'VMT'
  ; // %FIELDS %Fld
  
 ; // class_impl _:Object
 
 class_impl _:Point
  %FIELDS %Fld
   'VMT'
   'X'
   'Y'
  ; // %FIELDS %Fld
  
  %INHERITS %G
   @
   _:Object
  ; // %INHERITS %G
  
 ; // class_impl _:Point
 
 class_impl _:Rectangle
  %FIELDS %Fld
   'VMT'
   'TopLeft'
   'BottomRight'
  ; // %FIELDS %Fld
  
  %INHERITS %G
   @
   _:Object
  ; // %INHERITS %G
  
 ; // class_impl _:Rectangle
 
 INTEGER CONST c:Object:Instance:Size
  1
 INTEGER CONST c:Object:Offset:VMT
  0
 INTEGER CONST c:Point:Instance:Size
  3
 INTEGER CONST c:Point:Offset:VMT
  0
 INTEGER CONST c:Point:Offset:X
  1
 INTEGER CONST c:Point:Offset:Y
  2
 INTEGER CONST c:Rectangle:Instance:Size
  3
 INTEGER CONST c:Rectangle:Offset:BottomRight
  2
 INTEGER CONST c:Rectangle:Offset:TopLeft
  1
 INTEGER CONST c:Rectangle:Offset:VMT
  0
 IMMEDIATE VOID OPERATOR class
  ^L IN aName
  g_CurrentClassMembers :=
  [
  ]
  g_ClassFieldOffset :=
  0
  aName
  |N
  >>>
  g_CurrentClass
  [
   ':'
   @
   class_impl
   Ctx:SetWordProducerForCompiledClass
   [
    '_:'
    g_CurrentClass
   ]
   strings:Cat
   >>>
   g_CurrentClassImpl
   g_CurrentClassImpl
   if
    (
     g_CurrentClass
     <>
     cObjectName
    )
   then
    BEGIN
     '%INHERITS'
     '@'
     [
      '_:'
      cObjectName
     ]
     strings:Cat
     ';'
    END
   ';'
  ]
  Ctx:Parser:PushArray
  [
   'array'
   'type'
   g_CurrentClass
  ]
  Ctx:Parser:PushArray
  axiom:PushSymbol
  classExpander
  g_CurrentClassImpl
  Ctx:Parser:PushSymbol
 ; // IMMEDIATE VOID OPERATOR class
 
 VOID OPERATOR class_impl
 ; // VOID OPERATOR class_impl
 
 IMMEDIATE VOID OPERATOR class-end
 ; // IMMEDIATE VOID OPERATOR class-end
 
 IMMEDIATE VOID OPERATOR classExpander
  ^ IN anImpl
  for
  (
   (
    anImpl |@
   )
   %G
  )
  (
   IN anItem
   for
   (
    anItem
    %Fld
   )
   (
    IN anItem
    @
    member
    pop:Word:Name
    Ctx:Parser:PushSymbol
    anItem
    |N
    Ctx:Parser:PushSymbol
   )
  )
 ; // IMMEDIATE VOID OPERATOR classExpander
 
 STRING CONST cObjectName
  'Object'
 IMMEDIATE VOID OPERATOR constructor
  ^L IN aName
  constructor
  Ctx:SetWordProducerForCompiledClass
  g_CurrentClass
  Ctx:Parser:PushSymbol
  aName
  |N
  MakeMethodSignature
 ; // IMMEDIATE VOID OPERATOR constructor
 
 VOID OPERATOR define_member
  STRING IN aName
  INTEGER IN aOffset
  axiom:PushSymbol
  PRIVATE
  axiom:PushSymbol
  CONST
  aName
  MakeFieldOffsetName
  Ctx:Parser:PushSymbol
  aOffset
  Ctx:Parser:PushInt
 ; // VOID OPERATOR define_member
 
 PRIVATE OPERATOR do-get-member
  STRING IN aName
  'FieldByOffset'
  Ctx:Parser:PushSymbol
  aName
  MakeFieldOffsetName
  Ctx:Parser:PushSymbol
 ; // PRIVATE OPERATOR do-get-member
 
 OBJECT FUNCTION DoMember
  OBJECT IN aMember
  aMember
  DO
  >>>
  Result
 ; // OBJECT FUNCTION DoMember
 
 ARRAY FUNCTION ELEMLIST
  IN %S
  STRING IN aListName
  if
   (
    %S
    NotValid
   )
  then
   (
    Result :=
    [
    ]
   )
  else
   (
    VAR l_List
    l_List :=
    (
     %S
     %%
     aListName
    )
    if
     (
      l_List
      NotValid
     )
    then
     (
      Result :=
      [
      ]
     )
    else
     (
      Result :=
      (
       @
       FilterMember
       (
        @
        DoMember
        (
         l_List
         CodeIterator
        )
        Array:Map
       )
       Array:Filter
      )
     )
   )
 ; // ARRAY FUNCTION ELEMLIST
 
 IMMEDIATE OPERATOR end.
  pop:Finder:SetToCtx
  pop:Compiler:SetToCtx
 ; // IMMEDIATE OPERATOR end.
 
 : FieldByOffset
  ^ IN _anOffset
  IMMEDIATE VOID OPERATOR anOffset
   '_anOffset'
   MangledNamePusher
  ; // IMMEDIATE VOID OPERATOR anOffset
  
  Object IN Self
  (
   _anOffset |^
  )
  Self
  Array:GetItem
 ; // : FieldByOffset
 
 IMMEDIATE VOID TYPE FieldOffset
  TtfwValueTypes
  Ctx:IncludeValueTypes
 ; // IMMEDIATE VOID TYPE FieldOffset
 
 BOOLEAN FUNCTION FilterMember
  OBJECT IN aMember
  Result :=
  (
   aMember
   NotValid
   !
  )
 ; // BOOLEAN FUNCTION FilterMember
 
 INTEGER VAR g_ClassFieldOffset
 STRING VAR g_CurrentClass
 STRING VAR g_CurrentClassImpl
 ARRAY VAR g_CurrentClassMembers
 STRING : getClassName
  IN Self
  Self
  |N
  ':'
  string:Split
  >>>
  Result
  DROP
 ; // STRING : getClassName
 
 IMMEDIATE VOID OPERATOR get-member
  ^L IN aName
  aName
  |N
  do-get-member
 ; // IMMEDIATE VOID OPERATOR get-member
 
 IMMEDIATE OPERATOR implementation
  LINK ^ IN aWordToWork
  OBJECT VAR l_NewCompiler
  Ctx:PushCompiler
  Ctx:PushFinder
  aWordToWork |^@
  >>>
  l_NewCompiler
  if
   (
    l_NewCompiler
    IS
    class::TkwCompiledWordWorkerWord
   )
  then
   BEGIN
    l_NewCompiler
    pop:CompiledWordWorkerWord:Compiled
    >>>
    l_NewCompiler
   END
  l_NewCompiler
  pop:Compiler:SetToCtx
  l_NewCompiler
  pop:Finder:SetToCtx
 ; // IMMEDIATE OPERATOR implementation
 
 ARRAY VAR l_Points
 ARRAY VAR l_Rectangles
 PRIVATE STRING OPERATOR MakeFieldOffsetName
  STRING IN aName
  [
   'c:'
   g_CurrentClass
   ':Offset:'
   aName
  ]
  strings:Cat
  >>>
  Result
 ; // PRIVATE STRING OPERATOR MakeFieldOffsetName
 
 PRIVATE VOID OPERATOR MakeMethodSignature
  STRING IN aName
  axiom:PushSymbol
  :
  [
   g_CurrentClass
   ':'
   aName
  ]
  strings:Cat
  Ctx:Parser:PushSymbol
 ; // PRIVATE VOID OPERATOR MakeMethodSignature
 
 PRIVATE VOID OPERATOR MakeSelfParam
  g_CurrentClass
  Ctx:Parser:PushSymbol
  axiom:PushSymbol
  IN
  'Self'
  Ctx:Parser:PushSymbol
 ; // PRIVATE VOID OPERATOR MakeSelfParam
 
 IMMEDIATE VOID OPERATOR member
  ^L IN aName
  Ctx:ClearTypeInfo
  aName
  |N
  g_ClassFieldOffset
  define_member
  INC
  g_ClassFieldOffset
  aName
  |N
  >>>[]
  g_CurrentClassMembers
 ; // IMMEDIATE VOID OPERATOR member
 
 IMMEDIATE VOID OPERATOR members-end
  'private'
  Ctx:Parser:PushSymbol
  'Const'
  Ctx:Parser:PushSymbol
  [
   'c:'
   g_CurrentClass
   ':Instance:Size'
  ]
  strings:Cat
  Ctx:Parser:PushSymbol
  g_ClassFieldOffset
  Ctx:Parser:PushInt
  'RunCompileFields'
  Ctx:Parser:PushSymbol
 ; // IMMEDIATE VOID OPERATOR members-end
 
 IMMEDIATE VOID OPERATOR method
  ^L IN aName
  method
  Ctx:SetWordProducerForCompiledClass
  aName
  |N
  MakeMethodSignature
  MakeSelfParam
 ; // IMMEDIATE VOID OPERATOR method
 
 IMMEDIATE VOID OPERATOR new[
  '['
  Ctx:Parser:PushSymbol
  '@'
  Ctx:Parser:PushSymbol
  g_CurrentClassImpl
  Ctx:Parser:PushSymbol
 ; // IMMEDIATE VOID OPERATOR new[
 
 Object VAR O1
 IMMEDIATE VOID OPERATOR Object
  TtfwValueTypes
  Ctx:IncludeValueTypes
 ; // IMMEDIATE VOID OPERATOR Object
 
 TtfwWord readonly Object:class
  Object IN Self
  Self
  FieldByOffset
  c:Object:Offset:VMT
  >>>
  Result
 ; // TtfwWord readonly Object:class
 
 STRING readonly Object:ClassName
  Object IN Self
  Self
  Object:class
  getClassName
  >>>
  Result
 ; // STRING readonly Object:ClassName
 
 Point VAR P1
 Point VAR P10
 Point VAR P11
 Point VAR P2
 Point VAR P3
 Point VAR P4
 Point VAR P5
 Point VAR P6
 Point VAR P7
 Point VAR P8
 Point VAR P9
 IMMEDIATE VOID TYPE Pixel
  TtfwValueTypes
  Ctx:IncludeValueTypes
 ; // IMMEDIATE VOID TYPE Pixel
 
 IMMEDIATE VOID TYPE PixelList
  TtfwValueTypes
  Ctx:IncludeValueTypes
 ; // IMMEDIATE VOID TYPE PixelList
 
 IMMEDIATE VOID OPERATOR Point
  TtfwValueTypes
  Ctx:IncludeValueTypes
 ; // IMMEDIATE VOID OPERATOR Point
 
 Point method Point:-
  ^ IN _aPoint
  IMMEDIATE VOID OPERATOR aPoint
   '_aPoint'
   MangledNamePusher
  ; // IMMEDIATE VOID OPERATOR aPoint
  
  Point IN Self
  Point:OF
  (
   Self
   Point:+
   (
    (
     _aPoint |^
    )
    Point:Neg
   )
  )
  >>>
  Result
 ; // Point method Point:-
 
 Point constructor Point::
  ^ IN _aX
  ^ IN _aY
  IMMEDIATE VOID OPERATOR aX
   '_aX'
   MangledNamePusher
  ; // IMMEDIATE VOID OPERATOR aX
  
  IMMEDIATE VOID OPERATOR aY
   '_aY'
   MangledNamePusher
  ; // IMMEDIATE VOID OPERATOR aY
  
  [
   @
   _:Point
   (
    _aX |^
   )
   (
    _aY |^
   )
  ]
  >>>
  Result
 ; // Point constructor Point::
 
 Point method Point:+
  ^ IN _aPoint
  IMMEDIATE VOID OPERATOR aPoint
   '_aPoint'
   MangledNamePusher
  ; // IMMEDIATE VOID OPERATOR aPoint
  
  Point IN Self
  Point::
  (
   Self
   Point:X
   (+)
   (
    (
     _aPoint |^
    )
    Point:X
   )
  )
  (
   Self
   Point:Y
   (+)
   (
    (
     _aPoint |^
    )
    Point:Y
   )
  )
  >>>
  Result
 ; // Point method Point:+
 
 Point constructor Point:0
  Point::
  0
  0
  >>>
  Result
 ; // Point constructor Point:0
 
 Point method Point:Neg
  Point IN Self
  Point::
  Neg
  (
   Self
   Point:X
  )
  Neg
  (
   Self
   Point:Y
  )
  >>>
  Result
 ; // Point method Point:Neg
 
 Point constructor Point:OF
  ^ IN _aPoint
  IMMEDIATE VOID OPERATOR aPoint
   '_aPoint'
   MangledNamePusher
  ; // IMMEDIATE VOID OPERATOR aPoint
  
  Point::
  (
   (
    _aPoint |^
   )
   Point:X
  )
  (
   (
    _aPoint |^
   )
   Point:Y
  )
  >>>
  Result
 ; // Point constructor Point:OF
 
 VOID method Point:Print
  Point IN Self
  Self
  Point:ToPrintable
  .
 ; // VOID method Point:Print
 
 STRING method Point:ToPrintable
  Point IN Self
  [
   '( '
   'X: '
   Self
   Point:X
   ToPrintable
   ', Y: '
   Self
   Point:Y
   ToPrintable
   ' )'
  ]
  strings:Cat
  >>>
  Result
 ; // STRING method Point:ToPrintable
 
 Pixel readonly Point:X
  Point IN Self
  Self
  FieldByOffset
  c:Point:Offset:X
  >>>
  Result
 ; // Pixel readonly Point:X
 
 Point constructor Point:XY
  ^ IN _aPoint
  IMMEDIATE VOID OPERATOR aPoint
   '_aPoint'
   MangledNamePusher
  ; // IMMEDIATE VOID OPERATOR aPoint
  
  ARRAY VAR Points
  [
   (
    _aPoint |^
   )
  ]
  >>>
  Points
  Point::
  (
   Points
   FieldByOffset
   0
  )
  (
   Points
   FieldByOffset
   1
  )
  >>>
  Result
 ; // Point constructor Point:XY
 
 Pixel readonly Point:Y
  Point IN Self
  Self
  FieldByOffset
  c:Point:Offset:Y
  >>>
  Result
 ; // Pixel readonly Point:Y
 
 Rectangle VAR R1
 Rectangle VAR R2
 IMMEDIATE VOID OPERATOR read
  ^L IN aName
  'Self'
  Ctx:Parser:PushSymbol
  aName
  |N
  do-get-member
  '=:'
  Ctx:Parser:PushSymbol
  'Result'
  Ctx:Parser:PushSymbol
  ';'
  Ctx:Parser:PushSymbol
 ; // IMMEDIATE VOID OPERATOR read
 
 IMMEDIATE VOID OPERATOR readonly
  ^L IN aName
  readonly
  Ctx:SetWordProducerForCompiledClass
  aName
  |N
  MakeMethodSignature
  MakeSelfParam
 ; // IMMEDIATE VOID OPERATOR readonly
 
 IMMEDIATE VOID OPERATOR Rectangle
  TtfwValueTypes
  Ctx:IncludeValueTypes
 ; // IMMEDIATE VOID OPERATOR Rectangle
 
 Rectangle constructor Rectangle::
  ^ IN _aBottomRight
  ^ IN _aTopLeft
  IMMEDIATE VOID OPERATOR aBottomRight
   '_aBottomRight'
   MangledNamePusher
  ; // IMMEDIATE VOID OPERATOR aBottomRight
  
  IMMEDIATE VOID OPERATOR aTopLeft
   '_aTopLeft'
   MangledNamePusher
  ; // IMMEDIATE VOID OPERATOR aTopLeft
  
  [
   @
   _:Rectangle
   (
    _aTopLeft |^
   )
   (
    _aBottomRight |^
   )
  ]
  >>>
  Result
 ; // Rectangle constructor Rectangle::
 
 Point readonly Rectangle:BottomRight
  Rectangle IN Self
  Self
  FieldByOffset
  c:Rectangle:Offset:BottomRight
  >>>
  Result
 ; // Point readonly Rectangle:BottomRight
 
 VOID method Rectangle:Print
  Rectangle IN Self
  Self
  Rectangle:ToPrintable
  .
 ; // VOID method Rectangle:Print
 
 Point readonly Rectangle:TopLeft
  Rectangle IN Self
  Self
  FieldByOffset
  c:Rectangle:Offset:TopLeft
  >>>
  Result
 ; // Point readonly Rectangle:TopLeft
 
 STRING method Rectangle:ToPrintable
  Rectangle IN Self
  [
   '( '
   'TopLeft: '
   Self
   Rectangle:TopLeft
   Point:ToPrintable
   ', BottomRight: '
   Self
   Rectangle:BottomRight
   Point:ToPrintable
   ' )'
  ]
  strings:Cat
  >>>
  Result
 ; // STRING method Rectangle:ToPrintable
 
 IMMEDIATE VOID OPERATOR RunCompileFields
  [
   'implementation'
   g_CurrentClassImpl
   '%FIELDS'
   for
   g_CurrentClassMembers
   (
    STRING IN aName
    [
     '`'
     aName
     '`'
    ]
    strings:Cat
   )
   ';'
   'end.'
  ]
  Ctx:Parser:PushArray
 ; // IMMEDIATE VOID OPERATOR RunCompileFields
 
 g_CurrentClass :=
 ''
 g_CurrentClassImpl :=
 ''
 g_ClassFieldOffset :=
 0
 (
  g_CurrentClassMembers :=
  [
  ]
 )
 PointTest
 DumpElement
 P1 :=
 Point:0
 P2 :=
 Point:0
 P3 :=
 Point::
 1
 1
 P4 :=
 Point:XY
 (
  2
  2
 )
 P5 :=
 Point:OF
 P4
 P6 :=
 (
  P3
  Point:+
  P4
 )
 P7 :=
 (
  P3
  Point:-
  P4
 )
 P8 :=
 (
  P4
  Point:-
  P3
 )
 P9 :=
 (
  P4
  Point:Neg
 )
 P10 :=
 (
  P3
  Point:Neg
 )
 P11 :=
 Point:XY
 (
  -2
  2
 )
 O1 :=
 P1
 O1
 Point:Print
 [
  P1
  P2
  P3
  P4
  P5
  P6
  P7
  P8
  P9
  P10
  P11
 ]
 >>>
 l_Points
 for
 l_Points
 Point:Print
 for
 l_Points
 (
  Point:X
  .
 )
 for
 l_Points
 (
  Point:Y
  .
 )
 for
 l_Points
 (
  Object:class
  .
 )
 for
 l_Points
 (
  Object:ClassName
  .
 )
 for
 l_Points
 (
  for
  (
   Object:class
   %G
  )
  (
   getClassName
   .
  )
 )
 R1 :=
 Rectangle::
 P1
 P4
 R2 :=
 Rectangle::
 P6
 P7
 [
  R1
  R2
 ]
 >>>
 l_Rectangles
 for
 l_Rectangles
 Rectangle:Print
 'Hello '
 (+)
 'world'
 .
 'Hello '
 (+)
 'world'
 .
 'Hello '
 (+)
 'world'
 .
 1
 (+)
 2
 .
 10
 (+)
 20
 .
 0
 (-)
 10
 .
 Neg
 10
 .
 Neg
 -10
 .
; // VOID Test PointTest

( X: 0, Y: 0 )
( X: 0, Y: 0 )
( X: 0, Y: 0 )
( X: 1, Y: 1 )
( X: 2, Y: 2 )
( X: 2, Y: 2 )
( X: 3, Y: 3 )
( X: -1, Y: -1 )
( X: 1, Y: 1 )
( X: -2, Y: -2 )
( X: -1, Y: -1 )
( X: -2, Y: 2 )
0
0
1
2
2
3
-1
1
-2
-1
-2
0
0
1
2
2
3
-1
1
-2
-1
2
TkwCompiledProcedure
TkwCompiledProcedure
TkwCompiledProcedure
TkwCompiledProcedure
TkwCompiledProcedure
TkwCompiledProcedure
TkwCompiledProcedure
TkwCompiledProcedure
TkwCompiledProcedure
TkwCompiledProcedure
TkwCompiledProcedure
Point
Point
Point
Point
Point
Point
Point
Point
Point
Point
Point
Object
Object
Object
Object
Object
Object
Object
Object
Object
Object
Object
( TopLeft: ( X: 0, Y: 0 ), BottomRight: ( X: 2, Y: 2 ) )
( TopLeft: ( X: 3, Y: 3 ), BottomRight: ( X: -1, Y: -1 ) )
Hello world
Hello world
Hello world
3
30
-10
-10
10
