[ 0 0 ]
[ 0 0 ]
[ 1 1 ]
[ 2 2 ]
[ 2 2 ]
[ 3 3 ]
[ -1 -1 ]
[ 1 1 ]
[ -2 -2 ]
[ -1 -1 ]
VOID Test PointTest
 VOID CALLER OPERATOR ?ASSURE
  BOOLEAN IN aCondition
  ^ IN aMessage
  TtfwWord IN Caller
  aCondition
  !
  ?
  BEGIN
   aMessage
   Caller
   private:ERROR
  END
 ; // VOID CALLER OPERATOR ?ASSURE
 
 INTEGER CONST c:Point:CoordCount
  2
 CONST
 CONST
 IMMEDIATE VOID TYPE FieldOffset
  TtfwValueTypes
  Ctx:IncludeValueTypes
 ; // IMMEDIATE VOID TYPE FieldOffset
 
 IMMEDIATE VOID TYPE Object
  TtfwValueTypes
  Ctx:IncludeValueTypes
 ; // IMMEDIATE VOID TYPE Object
 
 Point VAR P1
 Point VAR P10
 Point VAR P2
 Point VAR P3
 Point VAR P4
 Point VAR P5
 Point VAR P6
 Point VAR P7
 Point VAR P8
 Point VAR P9
 IMMEDIATE VOID TYPE Pixel
  TtfwValueTypes
  Ctx:IncludeValueTypes
 ; // IMMEDIATE VOID TYPE Pixel
 
 IMMEDIATE VOID TYPE Point
  TtfwValueTypes
  Ctx:IncludeValueTypes
 ; // IMMEDIATE VOID TYPE Point
 
 Point : Point:
  ^ IN aX
  ^ IN aY
  [
   aX |^
   aY |^
  ]
  >>>
  Result
 ; // Point : Point:
 
 Point : Point:-
  ^ IN aPoint
  FieldOffset VAR i
  Point IN Self
  i :=
  0
  [
   for
   (
    aPoint |@
    DO
   )
   (
    Pixel IN aPx
    aPx
    i
    Self
    Array:GetItem
    SWAP
    -
    INC
    i
   )
  ]
  >>>
  Result
 ; // Point : Point:-
 
 Point : Point:+
  ^ IN aPoint
  FieldOffset VAR i
  Point IN Self
  i :=
  0
  [
   for
   (
    aPoint |@
    DO
   )
   (
    Pixel IN aPx
    aPx
    i
    Self
    Array:GetItem
    +
    INC
    i
   )
  ]
  >>>
  Result
 ; // Point : Point:+
 
 Point : Point:0
  [
   0
   0
  ]
  >>>
  Result
 ; // Point : Point:0
 
 Point : Point:Neg
  Point IN Self
  [
   for
   Self
   (
    Pixel IN aPx
    aPx
    0
    SWAP
    -
   )
  ]
  >>>
  Result
 ; // Point : Point:Neg
 
 Point : Point:OF
  ^ IN aPoint
  [
   for
   (
    aPoint |@
    DO
   )
   (
    Pixel IN aPx
    aPx
   )
  ]
  >>>
  Result
  (
   Result
   Array:Count
   =
   c:Point:CoordCount
  )
  ?ASSURE
  '“очка должна содержать две координаты'
 ; // Point : Point:OF
 
 VOID : Point:Print
  Point IN aPoint
  aPoint
  .
 ; // VOID : Point:Print
 
 Point : Point:XY
  ^ IN aPoint
  [
   aPoint |@
   DO
  ]
  >>>
  Result
  (
   Result
   Array:Count
   =
   c:Point:CoordCount
  )
  ?ASSURE
  '“очка должна содержать две координаты'
 ; // Point : Point:XY
 
 IMMEDIATE VOID OPERATOR PRIVATE
  TtfwAccessType::tfw_atPrivate
  Ctx:IncludeAccessType
 ; // IMMEDIATE VOID OPERATOR PRIVATE
 
 IMMEDIATE VOID OPERATOR PRIVATE
  TtfwAccessType::tfw_atPrivate
  Ctx:IncludeAccessType
 ; // IMMEDIATE VOID OPERATOR PRIVATE
 
 IMMEDIATE OPERATOR TYPE
  ^L IN aName
  aName
  |N
  Ctx:ValueTypes
  pop:ValueTypes:MakeCustomName
  Ctx:ClearTypeInfo
  TYPE
  Ctx:SetWordProducerForCompiledClass
  'IMMEDIATE'
  Ctx:Parser:PushSymbol
  'VOID'
  Ctx:Parser:PushSymbol
  'axiom:operator'
  Ctx:Parser:PushSymbol
  aName
  |N
  Ctx:Parser:PushSymbol
  'axiom:CompileSetValueTypes'
  Ctx:Parser:PushSymbol
  ';'
  Ctx:Parser:PushSymbol
 ; // IMMEDIATE OPERATOR TYPE
 
 IMMEDIATE OPERATOR TYPE
  ^L IN aName
  aName
  |N
  Ctx:ValueTypes
  pop:ValueTypes:MakeCustomName
  Ctx:ClearTypeInfo
  TYPE
  Ctx:SetWordProducerForCompiledClass
  'IMMEDIATE'
  Ctx:Parser:PushSymbol
  'VOID'
  Ctx:Parser:PushSymbol
  'axiom:operator'
  Ctx:Parser:PushSymbol
  aName
  |N
  Ctx:Parser:PushSymbol
  'axiom:CompileSetValueTypes'
  Ctx:Parser:PushSymbol
  ';'
  Ctx:Parser:PushSymbol
 ; // IMMEDIATE OPERATOR TYPE
 
 IMMEDIATE VOID OPERATOR VAR
  ^L IN aName
  aName
  |N
  VAR
  axiom:DefineVar
 ; // IMMEDIATE VOID OPERATOR VAR
 
 P1 :=
 Point:0
 P2 :=
 Point:0
 P3 :=
 Point:
 1
 1
 P4 :=
 Point:XY
 (
  2
  2
 )
 P5 :=
 Point:OF
 P4
 P6 :=
 (
  P3
  Point:+
  P4
 )
 P7 :=
 (
  P3
  Point:-
  P4
 )
 P8 :=
 (
  P4
  Point:-
  P3
 )
 P9 :=
 (
  P4
  Point:Neg
 )
 P10 :=
 (
  P3
  Point:Neg
 )
 P1
 Point:Print
 P2
 Point:Print
 P3
 Point:Print
 P4
 Point:Print
 P5
 Point:Print
 P6
 Point:Print
 P7
 Point:Print
 P8
 Point:Print
 P9
 Point:Print
 P10
 Point:Print
 PointTest
 DumpElement
; // VOID Test PointTest

